[{"title":"美好事物","date":"2020-09-22T03:34:30.000Z","path":"2020/09/22/2020.09.22 停下来听首歌/","text":"美好事物​ ——— 房东的猫 热夏 你归来 听蝉 再游于 北方 知寒 沿途 不枉为 少年 终有个 结局圆满 你看 顽皮细雨招摇过远航 修理过小店某处忽明忽暗的灯盏 你听 江水流过人家吵着要上岸 你去过烟花三月的江南 你看 秋月温柔撕破了花瓣 却只为迎着暮冬大雪纷飞时贪玩 你说 要忘却所有不愉快的片段 把美好事物纯真的走完 把疲乏往期 装进朴质的长街 把失败恋爱 藏进路人的详谈 把起舞的今日 写成诗篇 多年后 也不遗憾 把无味春风 融进街边的早餐 把仰头月色 化为潇洒的释然 把漫长的故事 变成短暂 才配得起勇敢 把忧愁聚散 又何惧放胆 让幽邃夜晚 静躺入空山","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Altium Designer","date":"2020-09-19T14:11:30.000Z","path":"2020/09/19/2020.09.19 Altium Designer/","text":"安装与注册https://pan.baidu.com/s/1bqSYZbXgsIJ_11mrKu74pg 密码：jykg 这个是从微信 “火耳软件” 找到资源，AD 2019 。 学习途径额，我目前所学的是 ”bilibili 凡亿教育“ 发表的免费学习视频。 他们这个教育机构做得感觉还是不错的，如果感觉白嫖的不足以满足自己，可以去花一点钱，多学点知识。 淘宝课程店：fanyedu.taobao.com 官网：fanyedu.com ——- 里面也有很多免费的课程 其他学习 PCB 设计交流的联盟论坛： PCB联盟网：pcbbar.com —— 可进行一些资料的下载，以及问题的提问。 &#x70;&#x63;&#98;&#113;&#x61;&#x40;&#x66;&#97;&#x6e;&#121;&#45;&#101;&#x64;&#x61;&#46;&#99;&#x6f;&#x6d; ———- PCB图纸公益评审提交邮箱 PCB 生产，外包，制版的话 嘉立创 凡亿PCB 工程建立工程文件* 原理图库 * 原理图 * PCB 库 * PCB * 生产文件 * ...... 新建工程 新建一个工程目录：以后所有所建立的 原理图库、原理图、PCB库、PCB 都保存到这个工程目录内。 新建原理图库 新建原理图 新建PCB库 新建PCB 元件符号的创建1234567891011121314151617181920211. 选中工程文件中的 &#x27;原理图库&#x27;2. 打开 Panels 面板 -&gt; SCH Libarary3. 再此处新建元件符号: 1) 元件符号是元件在原理图上的表现形式 2) 主要由元件 边框、管脚（管脚序号、管脚名称）、元件名称、元件说明组成。4. 注意: 1) 通过&#x27;建立管脚&#x27;来建立&#x27;电气连接&#x27;关系 2) 元件符号中的&#x27;管脚序号&#x27;是与 元件实物 的管脚一一对应的。 3) 图形不一定要与实物完全一样，那是 &#x27;封装&#x27; 所需要考虑的问题。 4) 但是 &#x27;管脚序号&#x27; 和 &#x27;名称&#x27; 一定要严格按照&#x27;元件规格书&#x27;中的说明一一对应号。6. 元件模型的几个基本参数: 1) Design Item ID：元件类型 eg: RES 2) Designator：网络标签 eg: R? # 其中问好表示通配 3) Comment：元件值，如果是电阻就是阻值，；一般设计模型的时候不需要填写。 4) Links：设置产商链接，生产渠道 5) Footprint：设置封装类型 如：0805、0602 操作技巧1234567891011121314151617181920212223242526272829301. 使用系统默认的快捷键: 1) 软件菜单栏里面，每一栏后面都有字母，表示的就是该选项的一个快捷键。 2) 每一个工具栏里面还有许多小选项，配合小选项的快捷键，两个同时按就能唤出对应窗口。2. 自定义快捷键: 1) 按照 ctrl , 然后鼠标左键点击需要设置的功能选项。 2) 就会弹出该功能多对应的快捷键设置页面。3. 设计元件原理图外形的时候，需要放置许多管脚: 1) 在放第一个管脚的时候，按 tab 键设置网络标签的属性起始值。 2) 然后一直放置的时候就是按照顺序了。4. 管脚命名，快捷方式: 1) 复制管脚名称 2) 选中需要命名的管脚，直接 ctrl + V 进行粘贴 3) 剪切板上面的名称就会直接被粘贴到管脚名称属性栏5. 关于元件取名: 1) 电阻：R1、R2、R3...... 2) 电容：C1、C2、C3...... 3) IC芯片：U1、U2、U3..... 4) 排针类：J1、J2、J3......6. 阵列试粘贴: 1) 对于那种有 20 个管脚 或者 40 个管脚的 芯片或者排针。 2) 我们不可能在耗费时间一个个来摆放吧！ 3) 所以，先复制一个排针，然后点击&#x27;编辑 -&gt; 整列式粘贴&#x27;。 4) 主增量表示，给对象 designator代号 进行递增/减。 5) 次增量表示，给对象 name名称 进行递增/减。 6) 水平/垂直放置距离，可以是&#x27;负值&#x27;。 相关经验 看一遍视频，不要边看边操作 看第二遍的时候，可以直接自己做，不会的时候，再回顾视频 这样子效率更加高 对于软件的一些相关操作 设置一个快捷键 然后练它个 50 编，增加肌肉记忆 就像盲敲打字一样，形成一个反射 学习素材 ———– 智能小车制作 链接: https://pan.baidu.com/s/1nH5MC53thHp8AdbWgxsQFw 提取码: 1111","link":"","tags":[{"name":"PCB","slug":"PCB","permalink":"http://www.fangning.xyz.com/tags/PCB/"}]},{"title":"时钟","date":"2020-09-13T14:36:30.000Z","path":"2020/09/13/2020.09.13 时钟/","text":"时钟 cc2530 在正常运行的时候，需要一个高频时钟信号，以及一个低频时钟信号。 高频时钟信号，主要共给CPU ，保证程序的正常运行。他有两个来源： 芯片内部有一个 16M 的 RC震荡电路。 也可以外接一个 32M 的高频石英晶振。 正常工作的时候，其中一个给 cpu 共给。 地频时钟信号，主要共给看门狗，睡眠定时器等片上外设。也有 2 个来源： 芯片内部 32k RC 电路。 d外接 32.768k 石英晶振。 那么四个时钟电路，具体什么时候，是那些时钟在工作呢？ CC2530 芯片默认上电的时候，是默认的两个 RC 震荡电路作为 高 低 频时钟来源。 芯片做串口工作，特别是做无线通信的时候，必须要有 32M 的石英晶振作为时钟来源。 123456789101112131415161718192021222324252627281. 高频时钟特点: 1) 两个高频时钟源，可以同时起振，产生高频时钟信号； ———— 但是&#x27;能有一个供给 cc2530&#x27;作为高频信号。 2) 两个低频时钟源，同时只能有一个起振，作为芯片的低频信号来源。2. 系统高频时钟源切换步骤: 1) 让两个高频时钟源起振。 * 为什么切换的时候需要启动两个时钟呢？ * 因为，一旦cup，没有时钟源来提供时钟信号的话，就会宕机。 * 交接的时候，肯定需要一定时间的，所以两个时钟都需要运行，保证 CPU 的无缝连接。 * &#x27;SLEEPCMD&#x27; 第二位置 0 2) 等待目标时钟源震荡稳定。 * &#x27;SLEEPSTA&#x27; 的第 6 位为 1. 时，高频 32M 时钟信号稳定。 3) 延时一小段时间 ———— 63us； * 超出 63us 也可以的 4) 不分频输出; * 不分频啥意思？ * 当然就是不把一个信号的频率进行改变咯。原来时 32Mhz，以后还是 32M * 不能给它屏蔽一半，变成 16M 或者 8M * &#x27;CLKCONCMD&#x27; 的低三位 置 000 ：表示不分频输出。 5) 选中目标高频时钟源作为系统主时钟； * &#x27;CLKCONCMD&#x27; 的第 6 位置 0：设置外接 32M 作为主时钟。 6) 确认一下当前工作时的系统时钟是不是所选的高频时钟； * &#x27;CLKCONSTA&#x27; 这个寄存器的第 6 位为 0：表示 32M 的时钟源以及作为主时钟。 代码主程序文件1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iocc2530.h&gt;#include &quot;74LS164_8LED.h&quot;void delay()&#123; int i , j; for(i = 0; i &lt; 1000; i++) for(j = 0; j &lt; 800; j++);&#125;/** 以下被注释的代码作用是将系统时钟由默认 16M RC 改成 32M XOSC 高频晶振，可以对比未改之前数码管发现，修改完的数码管显示是原来的两倍，速度快了两倍！void delayms() // 大概延时超过 63us&#123; char k = 63; while(k--);&#125;void Init32M()&#123; SLEEPCMD &amp;= 0xfb; // 1111 1011 开启两个高频时钟沿 while(SLEEPSTA &amp; 0x40); // 判断第四位是否为 1，为 1 的话稳定，等待 32 M 稳点 delayms(); CLKCONCMD &amp;= 0xf8; //1111 1000 后三位清零 不分频输出 CLKCONCMD &amp;= 0xbf; // 1011 1111 设置 32M 作为系统主时钟 while(CLKCONCMD &amp; 0x40); // 等待 32M 成功成为当前系统主时钟&#125;**/void main()&#123; char i; LS164_Cfg(); //数码管初始化操作 //Init32M(); while(1) &#123; for(i = 0; i &lt; 10; i++)&#123; LS164_BYTE(i); //让数码管显示数字 i delay(); &#125; &#125;&#125; 74LS164_8LED.h 头文件123456789#ifndef __74LS164_8LED_H__#define __74LS164_8LED_H__#include&lt;ioCC2530.h&gt;#define LS164_DATA P1_3#define LS164_CLK P1_2#define UCHAR unsigned char void LS164_Cfg();void LS164_BYTE(UCHAR Data);//P1.3 DATA P1.2 CLK#endif 两个函数文件123456789101112131415161718192021222324252627282930#include&lt;ioCC2530.h&gt;#include&quot;74LS164_8LED.h&quot;static UCHAR LED_Map[]=&#123;0x3f,0x06,0x5b,0x4f, 0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x00,0xFF&#125;; //前面 10 个元素表示 0~9 ，后面两个表示全灭和全亮void LS164_Cfg()&#123; P1SEL &amp;=~0x0C;//xxxx 00xx 配置为普通IO模式 P1DIR |=0x0C;//xxxx 11xx 配置为输出模式&#125;void LS164_BYTE(UCHAR Index) //P1.3 DATA P1.2 CLK&#123; UCHAR i=0; UCHAR Data=LED_Map[Index]; // 这里可能芯片引脚资源有限，没有用三八译码器，只用两位输入，控制8种输出，所以用了74LS164一个一个来置字 for(;i&lt;8;i++) &#123; if(0x80 &amp; Data) &#123; LS164_DATA=1; &#125; else &#123; LS164_DATA=0; &#125; Data=Data &lt;&lt; 1; LS164_CLK=0; // 置下一位 LS164_CLK=1; &#125;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"外部中断","date":"2020-09-12T06:20:34.000Z","path":"2020/09/12/2020.09.11 外部中断/","text":"掌握所有引脚的外部中断## 概述 一个水源（EA），下面有三个组开关（P0IE、P1IE、P1IE）。每个组开关内，又分别有 8、8、5 个 I/0 口开关（中断开关 PxIEN）。 ​ 类似于水管，想要最下面的水龙头流水，就得先让最上面的水塔开关打开，然后还得把中间的总管道开关打开，最后，只需要打开龙头开关，就会有水。 ​ 因此，如果需要给某个脚配置成中断，就必须先满足，开总中断使能，组内中断使能，以及对应 I/O 口中断打开。 中断条件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 初始化 IO 口工作在 &#x27;普通IO、上拉输入状态&#x27; 1) 配置 PxSEL 2) 配置 PxDIR 3) 配置 PxINP 4) 配置 P2INP2. 开 IO 口组中断。3. 开组内对应的具体某 IO 口中断。4. 配置&#x27;上升&#x27;还是&#x27;下降&#x27;沿触发: 1) 一个寄存器控制 P0-P1-P2 三组 21 个 IO 脚的中断触发类型，上升沿 或者 下降沿 ———— &#x27;PICTL&#x27; 2) 关于寄存器 PICTL 具体对应控制 IO 口的关系图，如下图所示。 &#x27;D0 控制 P0&#x27;, &#x27;D1 和 D2 控制 P1低四位 P1高四位&#x27;, &#x27;D3 控制 P2&#x27; 。5. 开中断使能 1) 开 CPU 总中断 EA = 1 2) 开小组中断控制位 ———— P0IE | P1IE | P2IE * &#x27;如果一个寄存器的首地址是 8 的倍数，结尾是 0 或 8 ， 那么改寄存器内部所有位都会被 宏定义！！！&#x27; * 反之，如果寄存器首地址不是 8 的倍数，那么该寄存器内部所有位都不会被 宏定义。 * P0IE 处于首地址为 8 的倍数的寄存器内，所以被宏定义了，可以直接赋值 P0IE = 1 * P1IE 和 P2IE 这两个其实是不被定义的，所以用不辽，需要对他们所属寄存器进行值数。 他们都处于寄存器 IEN2 中: P1IE ----&gt; IEN2 第 4 位， P2IE ----&gt; IEN2 第 1 位。 6. 写中断函数: 1) #pragma verctor = P0INT_VECTOR * #pragma 预处理，设定编译器状态，或者制定编译器完成特定动作。 * #pragma verctor 告诉编译器，&#x27;在这里设置中断服务函数入口地址&#x27; * 将 &#x27;中断服务函数入口地址&#x27; 设置为 &#x27;P0INT_VECTOR&#x27; ———— 该地址在头文件中有定义。 * 如果是其他组中断，可以改成 P1INT_VERCTOR | P2INT_VERCTOR 2)&#x27; __interrupt &#x27;: 中断函数声明关键字，后接中断函数就行了。 3) 中断函数出口之前，&#x27;清除中断标志位&#x27;：&#x27;PxIF = 0&#x27; * &#x27;小组中断标志位 PxIF&#x27; ———— 如果值为 1， 表示该小组内有中断触发。 * 为什么要清除中断标志位？ * 加入一个下降沿电位触发的中断，在接受到一个连续的下降沿的时候，中断标志位会置1。如果下降沿持续了较长时间的话，那么处理完第一个中断函数，又会不断的再次处理中断函数，因为没有消除多余的中断触发信号的影响。 * 所以，只有在处理完一个中断函数的时候，顺便清除一下中断标志位，&#x27;这样子同一时间内中断任务就只会被执行一次就够了&#x27;。 * P0IF -- P1IF -- P2IF 4) 中断是否为指定 I/O 口造成的中断: &#x27;函数结束时，也需要清零 PxIFG = 0&#x27; * &#x27;组内中断标记寄存器 ———— PxIFG&#x27; ———— 如果某一位为 1， 表示该位对应 I/O 口触发外部中断。 * 既然以及产生中断了，小组中断标志位也已经触发了，也就进入了小组中断函数入口地址。 * 但是入口地址是组内公用的，那到底具体是哪个 I/O 口引发的中断呢？ 如果同一个小组内，有多个 I/O 作为外部中断触发引脚。可是中断入口是共用的，所以必须在中断函数内，&#x27;再加一个中断标识条件，来确定是否是指定 I/O 口的中断触发&#x27;。 * if( P0IFG &amp; 0x20 == 1) 表示 P0 组第五位 I/O 口触发了中断。 此时在条件语句内写改中断函数内容就行了，就不会受到组内别的中断影响。 5) &#x27;消除&#x27;按钮抖动等&#x27;误操作触发的中断&#x27; * 按钮抖动也可能会触发中断，人工按下的话中断触发时间较长。 * 为了消除按钮抖动的影响，我们在中断触发函数内，加一个延时。 * &#x27;延时一小段时间时候，如果按钮还是按下的状态&#x27;，那么&#x27;表示是人为触发的&#x27;。如果不是，那直接跳出中断函数。 相关经验 什么是外部中断 在没有干预的情况下，单片机的程序在封闭状态下自主运行，如果在某一时刻需要响应一个外部事件(比如有按键按下)**，这时就会用到外部中断。具体来讲，外部中断就是在单片机的一个引脚上，由于外部因素导致了一个电平的变化(比如由高变低)，而通过捕获这个变化，单片机内部自主运行的程序就会被暂时打断，转而去执行相应的中断处理程序，执行完后又回到原来中断的地方继续执行原来的程序**。这个引脚上的电平变化，就申请了一个外部中断事件，而这个能申请外部中断的引脚就是外部中断的触发引脚。 给寄存器某一位位值数的时候 置0与1 ———— P0SEL &amp;= 0xfe // 1111 1110 最后一位置0 置1或0 ———— P0SEL |= 0x01 // 0000 0001 最后一位置1 给一个 0 置 1 或 给 1 置零 与 1 异或 运算。 相同结果为 0， 不相同结果为 1 . a = 1; a ^= 1; a –&gt; 0; a = 0; a ^= 1; a –&gt; 1; C 语言中没有 同或操作。 有按位取反操作 a = ~a ； #pragma optimze = none 关闭 IAR 编译器对下列函数的优化。必须放在函数外部，起始位置。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; //P0_5下，就会接受到一个下降沿（触发中断），让 led3-P0_4 灯亮（中断处理函数） P0SEL &amp;= 0xdf; //1101 1111 普通io P0SEL &amp;= 0xef; //1110 1111 普通io P0DIR &amp;= 0xdf; //1101 1111 输入 P0DIR |= 0x10; //0001 0000 输出 P0INP &amp;= 0xdf; //1101 1111 上下拉 P2INP &amp;= 0xdf; //1101 1111 上拉 EA = 1; //总中断 P0IE = 1; //小组中断 // IEN2 |= 0x10 -------&gt; P1IE = 1 这两个寄存器位地址（0x9A）不是 8 的倍数，所以不被宏定意，只能通过找到相应的寄存器置位。 // IEN2 |= 0x02 -------&gt; P2IE = 1 P0IEN |= 0x20; // 0010 0000 开组内中断 PICTL |= 0x01; // 将 P0 小组配置成下降沿触发。 while(1); //中断已开，啥都不需要管了，就等外部中断触发条件就行了。&#125;#pragma optimize = none#pragma vector = P0INT_VECTOR //设置中断函数向量，给中断函数地址__interrupt void button()&#123; if(P0IFG &amp; 0x20) //增加一个标识 确定是否时 P0_5 引发的中断 &#123; delay(30); if(P0_5 == 0) // 消除按钮抖动触发中断的情况 &#123; P0_4 = ~P0_4; // P0_4 ^= 1 如果中断触发，LED 灯亮/灭 &#125; &#125; P0IFG = 0; //清零中断标志 P0IF = 0;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; x; i++) for(j = 0; j &lt; 1000; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"我的随笔","date":"2020-09-11T08:22:50.000Z","path":"2020/09/11/2020.09.12 第一篇随笔/","text":"建立个人博客了特殊一年​ 2020年，全球爆发新冠状病毒，此时我正读大二下半学期。因为疫情，这一学期全国大部分学校都没开学，我也因此在家过了大半年。 ​ 也就是这段时间，我终于自己搭建了一个，一直让我心心念念的个人博客。 ​ ​ 之前看过许多大佬们的技术博客，很羡慕能够在信息爆发的互联网世界当中，有自己的一块小天地。接触互联网也已经有好几年了，不能再一直白嫖网上大佬们的技术成果了，是时候分享一波自己所学知识，回报社会 🤣😘😘😘，奉献自己的一份微薄之力！ ​ 本人以后会在这里分享自己的一些成长经历，对学习生活的一些思考，以及一些所学过的一些知识的汇总。希望可以给各位一个参考，和帮助。 ​ 大三了，时间过得很快，然而自己的技术沉淀却还很少。想把从大一大二所学的所有东西都写下来，想分享自己心里的千言万语，苦于最近实在有点忙。所以，就只能先写到这里了，以后一有时间就会更新的，相信我 😝，就这样吧 ~","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"cc2530原理图及引脚功能控制","date":"2020-09-11T00:00:00.000Z","path":"2020/09/11/2020.09.10 zigbee原理图理解/","text":"zigbee无线模块的基本工作电路原理图各部分理解12345678910111213141516171819201. 25 26 : 1) RF_P 和 RF_N 号角所连部分为&#x27;无线部分&#x27;，最后面接着一个天线。2. 40 30 : 1) 40：cdoupl 去耦电容。 2) 30 Rbias 为偏置电阻。 3) &#x27;这两个必须正确连接，8051单片机才能正常仿真、烧录程序&#x27;3. 32 33 : 1) 所连接部分接 &#x27;低频精准时钟源&#x27;。可用，可不用。 2) 主要用来做 定时器，或者 看门狗 才能用到。4. 胜达电子 与 TI cc2530基本工作电路的&#x27;不同点&#x27;: 1) 复位电路，实现按键复位 和 通电复位。 * 20 reset 脚提供程序 1us 低电平信号，即可复位。 * 20 号交接复位电路。 2) 下载程序电路 * 下载程序所需条件 电源，GND，reset，34 P2_1，35 P2_2 &#x27;五条线齐全，就可以下载程序&#x27; * 将上面五根线接入一个 JTAG下载接口 ，就可以通过仿真器进行程序烧入了！ 3) 只要有 &#x27;电源，地线，去耦电容，偏执电阻，以及程序烧录口P2_1,P2_2&#x27;，加上基本的&#x27;晶振&#x27;。&#x27;芯片就可以正常工作了！！&#x27; 如何控制 I/O 口输入/出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. i/o 口: 21个 1) P0_0 ~ P0_7 2) P1_0 ~ P1_7 3) p2_0 ~ P2_4 4) 所用引脚都可以作为普通 i/o 口。 5) 部分引脚有特殊功能，可以作为&#x27;片上外设&#x27;。 # 由相应的寄存器控制。 6) 要么某一时刻作为 i/o 要么作为 片上外设，不能冲突。2. P1_0 和 P1_1 有 20mA 的驱动能力。 其余引脚只有 4mA。3. 输出如何配置: 用 P1_0 来进行输出，控制 LED 灯。 1) 先让它处于 &#x27;普通I/O口模式&#x27;，而非片上外设。 * 两种模式的切换，是由寄存器进行控制的。 * &#x27;P0SEL&#x27; | P1SEL | P2SEL 这三个寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组引脚。 * &#x27;寄存器的&#x27;其中 &#x27;0~7 位&#x27;，对应&#x27;引脚 Px_0 ~ Px_7&#x27; 。 * 每一位&#x27;是 0&#x27;，表示对应引脚为 &#x27;普通 i/o 口&#x27;。 &#x27;1&#x27; 表示为 &#x27;片上外设口&#x27;。 * 注意 P2_1 和 P2_2 一般用来作为程序烧入口，不作为 普通I/O 口。 &#x27;其他口随便用&#x27;！ 2) 其次，让 P1_0 处于输出状态。 * 输入/出 状态的控制，也是由一组寄存器进行控制的。 * &#x27;P0DIR&#x27; | P1DIR | P2DIR 这桑寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组 I/O 口 输入或输出。 * 寄存器每一位 &#x27;0&#x27; 表示对应的引脚进行 &#x27;输出&#x27;。&#x27;1 表示&#x27;对应引脚进行 &#x27;输入&#x27;。 3) 最后，根据要求，让其处于 输出 高/低 点平。 * 设置 Px_x = 0 输出高电平， Px_X = 1 输出低电平。 4. # 以上两种寄存器 PxSEL and PxDIR 默认情况下的值都是 0x00;5. 输入如何配置: 读取 P0_6 状态，高电平表示&#x27;跳线帽&#x27;断开，低电平表示&#x27;跳线帽连接&#x27;GND。&#x27;见原理图 指针和等效光敏 模块&#x27;。 1) 让 p0_6 处于普通 I/O 口状态。 P0SEL = 0 2) 让 P0_6 处于输入状态。 P0DIR = 0 3) &#x27;让 P0_6 处于上拉、下拉或者三态 中的一种状态&#x27;。 * 上拉电路，很容易理解，就是引脚与外设之间，接一个电阻与VCC电源，来提高电压。 * 下拉电路，很容易理解，就是引脚与外设之间，接一个电阻与GND接地，来减低电压。 * 那什么是&#x27;三态呢？&#x27;，就是引脚与外设之间，接一个&#x27;无穷大的电阻&#x27;。 为什么要这样做，这样做有什么作用呢？ 当我们的引脚是需要&#x27;读取&#x27;外部设备的&#x27;电压值&#x27;的时候，接&#x27;上拉或者下拉&#x27;会&#x27;影响输入结果&#x27;。此时接一个无穷大的电阻，可以保证它想断路一样，不会分压，又可以通过连通读取到接入点的电压值。 例如: 使用&#x27;热敏电阻传感器&#x27;，或者&#x27;光敏电阻传感器&#x27;的时候，传感器电压值，会随着温度变化，分压也随之变化，我们单片机就需要采集到传感器与地之间的电压值，然后计算出外界环境的变化。&#x27;ADC采集的时候一定要接三态&#x27;。 4) 那么如何设置输入引脚是处于哪一种状态呢？ 用到了另外一组寄存器 &#x27;PxINP&#x27; * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;0&#x27; 表示 P0_6 处于 &#x27;上拉|下拉&#x27; 状态。 * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;1&#x27; 表示 P0_6 处于 &#x27;三态&#x27; 状态。 * 进一步确定，到底是处于上拉，还是下拉状态呢？ 这里用到了 &#x27;P2INP的高三位&#x27;！ * 因为 P2组 实际只存在五个引脚，&#x27;高三位不存在&#x27;，所以！&#x27;P2INP 高三位是闲置的&#x27;！！ * P2INP_5 --&gt; P0组的 上拉/下拉 P2INP_6 --&gt; P1组的 上拉/下拉 P2INP_7 --&gt; P2组的 上拉/下拉 5) 因为 PxSEL, PxDIR, PxINP 三个寄存器都是默认值为0. 所以，我们说这些引脚都是默认&#x27;普通IO口 上拉 输入&#x27;。 相关经验 目前所学的控制寄存器： PxSEL：控制三组引脚的作用，外设或者普通 I/O 口。 PxDIR：控制三组引脚的 I/O 状态，输入或输出。 PxINP：控制三组引脚的输入状态 上拉|下拉 或 三态。 P2INP 的高三位：控制三组引脚的 上拉或下拉 跳线帽 就是开发板上，连接了两个相邻排针的导体，类似给排针戴了顶帽子，所以叫做跳线帽。 zigbee 模块上，cc2580的 P0_6排针 与 GND排针 之间就有一个跳线帽。 zigbee 模块上，LED8 与 GND 之间也有一个跳线帽。 zigbee 常用引脚的位宏定义。 比如其中一个 P0_2 表示的就是 P0 组引脚中的 第三个引脚。 而单片机中，如果需要对寄存器位进行赋值操作，需要先声明一个位变量sbit P0_2 = P0^2 代码123456789101112131415161718192021222324252627#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; // 设置 P0_6 输入，确定 跳线帽的状态 P0SEL &amp;= 0xbe; // 设置 P0_6 , P0_0 为 i/o 口 1011 1110 P0DIR &amp;= 0xbf; // 设置 P0_6 输入 1011 1111 P0DIR |= 0x01; // 设置 P0_0 输出 0000 0001 P0INP &amp;= 0xbf; // 设置 P0_6 组引脚为 上/下拉 1011 1111 P2INP &amp;= 0xdf; // 110 11111 设置 P0 组引脚为上拉 while(1)&#123; //跳线帽插上，灯亮。跳线帽拔掉，灯灭。 if( P0_6 == 0) &#123; P0_0 = 1; &#125;else&#123; P0_0 = 0; &#125; &#125;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee环境搭建","date":"2020-09-10T12:46:25.000Z","path":"2020/09/10/2020.09.10 搭建开发环境编写及仿真/","text":"软件安装，程序编写运行，烧录IAR安装 12345678910111213141. IAR程序下载: 1) 不要从脚本之家之类的网站下载软件。否则，你的浏览器会被恶意串改主页。并且，电脑上会被恶意下载软件。 2) 从官网下载最新版的 IAR for 8051 就行了。 2. IAR程序破解: 教程：&quot; https://blog.csdn.net/qq_38351824/article/details/85005672 &quot; 1) 从可靠途径获得破解软件。 2) 运行破解软件，选择所需要破解的版本。生成密钥 3) 将密钥复制到 IAR程序密钥验证 步骤中，注意断网。 4) IAR 会在生成一个文本，给它放在桌面。 5) 将该文本路径填写到 破解软件 第二栏中，生成另外一个破解 文本。 6) 将破解文本填写到 IAR程序 注册所需文件中，然后一直下一步就行了。 # 注意，最后提取库文件的时候会失败，因为 IAR库文件 是需要另外一套 password 的。 # 但是也不需要担心，我们一般用不到库文件，或者即使要用，也是后期手动下载导入。 使用 新建工程： project -&gt; new project 选择新建一个 8051 的空白文件。 同时新建一个文件夹 lesson1 用来存储所有的工程文件。 工程名取名为 lessonp == lesson project 新建一个空白文件，取名为 lesson.c 用来存储程序文件。 右击工程，add -&gt; add lesson.c 导入源文件到工程。。 写个主函数，然后运行，弹出一个 工作区保存路径，填写 lessonw == lesson workspace 程序编写 1234567891011121314151617181920212223242526272829303132333435361. 头文件 #include &lt;iocc2530.h&gt;2. 配置工程文件: 1) 右击工程 -&gt; 修改常用选项中的 Device 驱动，找到在安装目录下 texas Instruments 中找到相应的 cpu cc2530F256。 2) 选择 linker -&gt; Output 勾选 Override default 和 Allow C-SPY-specific extra output file # 程序可以进行在线烧录，仿真。 3) 选择 Debugger 调试， 驱动器修改虚拟软件仿真 为 &#x27;Texas Instruments&#x27; 真正的硬件仿真器。 3. 安装仿真器(Texas Instruments)驱动。驱动所在路径：&quot; C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.1\\8051\\drivers\\Texas Instruments &quot;4. 仿真器上有两个红灯，其中一个是供电灯，另外一个是是否识别到 zigbee 芯片模块灯: 1) 当能够识别到硬件的时候，其中一个灯不亮。表示正常，可以进行下载程序。 2) 否则，如果两个灯都亮，就需要进行按键复位一下，重新识别硬件。5. IAR 中，先编译 --&gt; 再下载烧录程序。6. 调试: 1) 烧录程序后，直接进入程序执行状态。 2) 点击暂停按钮，可以进入 debug 状态。 3) 曲线图标：逐行运行 4) 向内∟图标: 逐行调试，遇到函数进入。 向外∟图标: 跳出当前所在函数。 5) 小三角加条竖线: 跳转到下一个标记节点。 7. 生成 hex 文件: 1) option -&gt; linker -&gt; extra Output 2) 勾选生成 Overide default文件名取名为 &#x27;lesson1.hex&#x27;。 3) 选择 OutPut fomat 格式为 &#x27;intel-extended&#x27;8. hex 文件作用: 1) 一种 16 进制程序文件，相当于源代码，但是可以不用再结果 IAR 编译器编译。 2) 可以直接使用烧录软件，烧录到 zigbee开发板 中。 3) flash Programmer 下载地址:&quot; https://www.ti.com/licreg/docs/swlicresults.tsp?countryName=China+%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&amp;eeq=Civil&amp;Certify=YES&amp;submitsubmit=Submit &quot; 4) 自动获取仿真驱动软件，选择好 hex 文件，点击开始烧录就行了！！ 相关经验 带排线的那个 zigbee 模块 ———— 是仿真用到。 最小的那个模块 ———— 抓取无线数据包的硬件工具 dongle 代码12345678910111213141516171819202122#include &lt;iocc2530.h&gt;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;// P0组 低四位输出 各自连接一个led灯, 形成流水灯。P0SEL &amp;= 0xf0; // 最后四个引脚设置为 I/OP0DIR |= 0x0f; // 最后四个引脚进行输出int v = 0x01;while(1)&#123; P0 = v; delay(1000); P0 = 0x00; delay(1000); v = v &lt;&lt; 1; if(v == 0x10) v = 0x01;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee概述","date":"2020-09-09T09:00:00.000Z","path":"2020/09/09/2020.09.09 zigbee 概述/","text":"zigbee组成12345678910111213141516171819202122232425262728293031321. zigbee 不像 51单片机 只需要理解里面的寄存器就可以玩转: 1) zigbee 最主要的是协议栈。它包含了很多的协议站，以及相关代码。这是最难的。 2) 资料方面，互联网上关于 zigbee 相关的深入浅出的资料很少。特别是关于讲解&#x27;协议栈&#x27;这一方面。2. 术语: 1) zigbee, zigbee通信方式，zigbee协议 三者都是一个意思。 2) 节点，无线模块，无线设备，三者都是一个意思。3. 计算机之间，局域网采用以太网协议: 1) zigbee之间通信，同样的，采用zigbee协议 2) 作用：&#x27;构建无线局域网！！&#x27;4. 如果一个无线局域网用于传感器的数据收集和监控，那么这个网络就叫做&#x27;无线传感器网络&#x27; 1) 也就是说，无线传感器网络是无线局域网的一个具体应用。5. 已经有了 蓝牙 和 wifi 为什么还要用 zigbee: 1) 蓝牙：功耗低，但是组件网络的节点数少 7~8个。 2) wifi：通信功率 比较大， 功耗大。 3) zigbee：可以组将大概模网络，节点可以上万个！功耗低(cc 2530 正常工作电流8mA, 最低工作达到几个uA)。 缺点：通信速率比较小，250 kbs。比较适合传感器的信息传送。6. 应用方面: 1) 家具方面：可以用电池，或者太阳能供电。 2) 工业方面：传统使用总线组将局域网，如果有zigbee的话，就可以无线组网。 3) 农业方面：组将无线传感器网络，温湿度传感器，二氧化碳浓度等传感器的数据组网收集。 4) 医疗方面：...... 5) 物联网时代，zigbee 使用十分频繁。7. zigbee 模块一般配合上位机构建控制系统: 1) 上位机可以是 pc，也可以是通过互联网的远程服务器。 2) 上位机可以实现对 zigbee 系统中的元件控制。 3) 主 zigbee 与 计算机之间 是&#x27;采用串口进行通信&#x27;的。也就是和 arduino 串口通信一样，需要使用一根数据线连接电脑。计算机获取数据。 zigbee组网组成12345678910111213141516171819202122232425262728291. 局域网内主要有三种成员: 1) 自顶向下：调节器，路由器，终端。三者都是使用zigbee模块来组成的。 2) 上位机主要是与主zigbee进行数据交互通信。 3) 远程服务器，是为了外出也能控制家里的物联网设备。2. 以太网协议通信条件: 1) 硬件：网卡 2) 软件：以太网协议栈（一堆程序代码？？？）3. zigbee 协议通信条件: 1) 软件上：zigbee协议栈（一堆程序代码） 2) 硬件上：&#x27;一种支持zigbee底层协议的芯片&#x27;。4. 几种关键字的含义: 1) zigbee联盟：ambare/飞思卡尔... 制定zigbee协议的一个协会组织，再美国的TI公司。 zigbee厂商，主要把zigbee协议用于推广和实际应用。 2) zstack TI：zigbee软件上&#x27;支持的协议栈&#x27;，由 TI 公司开发，并不是 zigbee 本身的底层协议. 3) cc2530：就是 TI 公司推出的&#x27;其中一&#x27;种&#x27;支持 zigbee 底层协议&#x27;的 &#x27;硬件芯片&#x27;。 4) IAR：编程软件，编译程序，下载烧录程序到 zigbee 开发板。5. cc2530芯片：cc2530F256 TI 50j.. # zigbee芯片上那块小的板子，中间的黑色正方形就是cc2530 1) F 标识flash，存储程序的rom 256kb 最大的一款。 2) 所有的种类芯片，ram 只有8K。 3) 50j：表示的是产品信息。6. 学习方法: 1) 记录学习笔记，做实验，抓包 2) 1~6 节可以按照顺序看，第七部分上半部分协议栈的使用学习完，可以直接先看第八部分 zigbee无线网络通信。熟悉这两部分之后，在学习 OSAL 以及对比学习其他通信方式。 3) 所有内容可以先粗看一遍，所有例子烧录进去观察现象，再来细看学习。 相关经验 手机是不能直接和 zigbee 进行数据通信的。 计算机的作用就是，将 zigbee 网络 与 互联网广域网 进行连接的中间。 国内用的一般都是 TI 公司的协议栈，以及硬件芯片cc2530。免费，稳定，可靠。","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"Hello world","date":"2020-09-03T09:42:39.545Z","path":"2020/09/03/hexo 默认文章/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"http://www.fangning.xyz.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]