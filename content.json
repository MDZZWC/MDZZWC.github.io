[{"title":"外部中断","date":"2020-09-12T06:20:34.000Z","path":"2020/09/12/2020.09.11 外部中断/","text":"掌握所有引脚的外部中断## 概述 一个水源（EA），下面有三个组开关（P0IE、P1IE、P1IE）。每个组开关内，又分别有 8、8、5 个 I/0 口开关（中断开关 PxIEN）。 ​ 类似于水管，想要最下面的水龙头流水，就得先让最上面的水塔开关打开，然后还得把中间的总管道开关打开，最后，只需要打开龙头开关，就会有水。 ​ 因此，如果需要给某个脚配置成中断，就必须先满足，开总中断使能，组内中断使能，以及对应 I/O 口中断打开。 中断条件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 初始化 IO 口工作在 &#x27;普通IO、上拉输入状态&#x27; 1) 配置 PxSEL 2) 配置 PxDIR 3) 配置 PxINP 4) 配置 P2INP2. 开 IO 口组中断。3. 开组内对应的具体某 IO 口中断。4. 配置&#x27;上升&#x27;还是&#x27;下降&#x27;沿触发: 1) 一个寄存器控制 P0-P1-P2 三组 21 个 IO 脚的中断触发类型，上升沿 或者 下降沿 ———— &#x27;PICTL&#x27; 2) 关于寄存器 PICTL 具体对应控制 IO 口的关系图，如下图所示。 &#x27;D0 控制 P0&#x27;, &#x27;D1 和 D2 控制 P1低四位 P1高四位&#x27;, &#x27;D3 控制 P2&#x27; 。5. 开中断使能 1) 开 CPU 总中断 EA = 1 2) 开小组中断控制位 ———— P0IE | P1IE | P2IE * &#x27;如果一个寄存器的首地址是 8 的倍数，结尾是 0 或 8 ， 那么改寄存器内部所有位都会被 宏定义！！！&#x27; * 反之，如果寄存器首地址不是 8 的倍数，那么该寄存器内部所有位都不会被 宏定义。 * P0IE 处于首地址为 8 的倍数的寄存器内，所以被宏定义了，可以直接赋值 P0IE = 1 * P1IE 和 P2IE 这两个其实是不被定义的，所以用不辽，需要对他们所属寄存器进行值数。 他们都处于寄存器 IEN2 中: P1IE ----&gt; IEN2 第 4 位， P2IE ----&gt; IEN2 第 1 位。 6. 写中断函数: 1) #pragma verctor = P0INT_VECTOR * #pragma 预处理，设定编译器状态，或者制定编译器完成特定动作。 * #pragma verctor 告诉编译器，&#x27;在这里设置中断服务函数入口地址&#x27; * 将 &#x27;中断服务函数入口地址&#x27; 设置为 &#x27;P0INT_VECTOR&#x27; ———— 该地址在头文件中有定义。 * 如果是其他组中断，可以改成 P1INT_VERCTOR | P2INT_VERCTOR 2)&#x27; __interrupt &#x27;: 中断函数声明关键字，后接中断函数就行了。 3) 中断函数出口之前，&#x27;清除中断标志位&#x27;：&#x27;PxIF = 0&#x27; * &#x27;小组中断标志位 PxIF&#x27; ———— 如果值为 1， 表示该小组内有中断触发。 * 为什么要清除中断标志位？ * 加入一个下降沿电位触发的中断，在接受到一个连续的下降沿的时候，中断标志位会置1。如果下降沿持续了较长时间的话，那么处理完第一个中断函数，又会不断的再次处理中断函数，因为没有消除多余的中断触发信号的影响。 * 所以，只有在处理完一个中断函数的时候，顺便清除一下中断标志位，&#x27;这样子同一时间内中断任务就只会被执行一次就够了&#x27;。 * P0IF -- P1IF -- P2IF 4) 中断是否为指定 I/O 口造成的中断: &#x27;函数结束时，也需要清零 PxIFG = 0&#x27; * &#x27;组内中断标记寄存器 ———— PxIFG&#x27; ———— 如果某一位为 1， 表示该位对应 I/O 口触发外部中断。 * 既然以及产生中断了，小组中断标志位也已经触发了，也就进入了小组中断函数入口地址。 * 但是入口地址是组内公用的，那到底具体是哪个 I/O 口引发的中断呢？ 如果同一个小组内，有多个 I/O 作为外部中断触发引脚。可是中断入口是共用的，所以必须在中断函数内，&#x27;再加一个中断标识条件，来确定是否是指定 I/O 口的中断触发&#x27;。 * if( P0IFG &amp; 0x20 == 1) 表示 P0 组第五位 I/O 口触发了中断。 此时在条件语句内写改中断函数内容就行了，就不会受到组内别的中断影响。 5) &#x27;消除&#x27;按钮抖动等&#x27;误操作触发的中断&#x27; * 按钮抖动也可能会触发中断，人工按下的话中断触发时间较长。 * 为了消除按钮抖动的影响，我们在中断触发函数内，加一个延时。 * &#x27;延时一小段时间时候，如果按钮还是按下的状态&#x27;，那么&#x27;表示是人为触发的&#x27;。如果不是，那直接跳出中断函数。 相关经验 什么是外部中断 在没有干预的情况下，单片机的程序在封闭状态下自主运行，如果在某一时刻需要响应一个外部事件(比如有按键按下)**，这时就会用到外部中断。具体来讲，外部中断就是在单片机的一个引脚上，由于外部因素导致了一个电平的变化(比如由高变低)，而通过捕获这个变化，单片机内部自主运行的程序就会被暂时打断，转而去执行相应的中断处理程序，执行完后又回到原来中断的地方继续执行原来的程序**。这个引脚上的电平变化，就申请了一个外部中断事件，而这个能申请外部中断的引脚就是外部中断的触发引脚。 给寄存器某一位位值数的时候 置0与1 ———— P0SEL &amp;= 0xfe // 1111 1110 最后一位置0 置1或0 ———— P0SEL |= 0x01 // 0000 0001 最后一位置1 给一个 0 置 1 或 给 1 置零 与 1 异或 运算。 相同结果为 0， 不相同结果为 1 . a = 1; a ^= 1; a –&gt; 0; a = 0; a ^= 1; a –&gt; 1; C 语言中没有 同或操作。 有按位取反操作 a = ~a ； #pragma optimze = none 关闭 IAR 编译器对下列函数的优化。必须放在函数外部，起始位置。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; //P0_5下，就会接受到一个下降沿（触发中断），让 led3-P0_4 灯亮（中断处理函数） P0SEL &amp;= 0xdf; //1101 1111 普通io P0SEL &amp;= 0xef; //1110 1111 普通io P0DIR &amp;= 0xdf; //1101 1111 输入 P0DIR |= 0x10; //0001 0000 输出 P0INP &amp;= 0xdf; //1101 1111 上下拉 P2INP &amp;= 0xdf; //1101 1111 上拉 EA = 1; //总中断 P0IE = 1; //小组中断 // IEN2 |= 0x10 -------&gt; P1IE = 1 这两个寄存器位地址（0x9A）不是 8 的倍数，所以不被宏定意，只能通过找到相应的寄存器置位。 // IEN2 |= 0x02 -------&gt; P2IE = 1 P0IEN |= 0x20; // 0010 0000 开组内中断 PICTL |= 0x01; // 将 P0 小组配置成下降沿触发。 while(1); //中断已开，啥都不需要管了，就等外部中断触发条件就行了。&#125;#pragma optimize = none#pragma vector = P0INT_VECTOR //设置中断函数向量，给中断函数地址__interrupt void button()&#123; if(P0IFG &amp; 0x20) //增加一个标识 确定是否时 P0_5 引发的中断 &#123; delay(30); if(P0_5 == 0) // 消除按钮抖动触发中断的情况 &#123; P0_4 = ~P0_4; // P0_4 ^= 1 如果中断触发，LED 灯亮/灭 &#125; &#125; P0IFG = 0; //清零中断标志 P0IF = 0;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; x; i++) for(j = 0; j &lt; 1000; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"我的随笔","date":"2020-09-11T08:22:50.000Z","path":"2020/09/11/第一篇随笔/","text":"建立个人博客了特殊一年​ 2020年，全球爆发新冠状病毒，此时我正读大二下半学期。因为疫情，这一学期全国大部分学校都没开学，我也因此在家过了大半年。 ​ 也就是这段时间，我终于自己搭建了一个，一直让我心心念念的个人博客。 ​ ​ 之前看过许多大佬们的技术博客，很羡慕能够在信息爆发的互联网世界当中，有自己的一块小天地。接触互联网也已经有好几年了，不能再一直白嫖网上大佬们的技术成果了，是时候分享一波自己所学知识，回报社会 🤣😘😘😘，奉献自己的一份微薄之力！ ​ 本人以后会在这里分享自己的一些成长经历，对学习生活的一些思考，以及一些所学过的一些知识的汇总。希望可以给各位一个参考，和帮助。 ​ 大三了，时间过得很快，然而自己的技术沉淀却还很少。想把从大一大二所学的所有东西都写下来，想分享自己心里的千言万语，苦于最近实在有点忙。所以，就只能先写到这里了，以后一有时间就会更新的，相信我 😝，就这样吧 ~","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.fangning.xyz.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"cc2530原理图及引脚功能控制","date":"2020-09-11T00:00:00.000Z","path":"2020/09/11/2020.09.10 zigbee原理图理解/","text":"zigbee无线模块的基本工作电路原理图各部分理解12345678910111213141516171819201. 25 26 : 1) RF_P 和 RF_N 号角所连部分为&#x27;无线部分&#x27;，最后面接着一个天线。2. 40 30 : 1) 40：cdoupl 去耦电容。 2) 30 Rbias 为偏置电阻。 3) &#x27;这两个必须正确连接，8051单片机才能正常仿真、烧录程序&#x27;3. 32 33 : 1) 所连接部分接 &#x27;低频精准时钟源&#x27;。可用，可不用。 2) 主要用来做 定时器，或者 看门狗 才能用到。4. 胜达电子 与 TI cc2530基本工作电路的&#x27;不同点&#x27;: 1) 复位电路，实现按键复位 和 通电复位。 * 20 reset 脚提供程序 1us 低电平信号，即可复位。 * 20 号交接复位电路。 2) 下载程序电路 * 下载程序所需条件 电源，GND，reset，34 P2_1，35 P2_2 &#x27;五条线齐全，就可以下载程序&#x27; * 将上面五根线接入一个 JTAG下载接口 ，就可以通过仿真器进行程序烧入了！ 3) 只要有 &#x27;电源，地线，去耦电容，偏执电阻，以及程序烧录口P2_1,P2_2&#x27;，加上基本的&#x27;晶振&#x27;。&#x27;芯片就可以正常工作了！！&#x27; 如何控制 I/O 口输入/出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. i/o 口: 21个 1) P0_0 ~ P0_7 2) P1_0 ~ P1_7 3) p2_0 ~ P2_4 4) 所用引脚都可以作为普通 i/o 口。 5) 部分引脚有特殊功能，可以作为&#x27;片上外设&#x27;。 # 由相应的寄存器控制。 6) 要么某一时刻作为 i/o 要么作为 片上外设，不能冲突。2. P1_0 和 P1_1 有 20mA 的驱动能力。 其余引脚只有 4mA。3. 输出如何配置: 用 P1_0 来进行输出，控制 LED 灯。 1) 先让它处于 &#x27;普通I/O口模式&#x27;，而非片上外设。 * 两种模式的切换，是由寄存器进行控制的。 * &#x27;P0SEL&#x27; | P1SEL | P2SEL 这三个寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组引脚。 * &#x27;寄存器的&#x27;其中 &#x27;0~7 位&#x27;，对应&#x27;引脚 Px_0 ~ Px_7&#x27; 。 * 每一位&#x27;是 0&#x27;，表示对应引脚为 &#x27;普通 i/o 口&#x27;。 &#x27;1&#x27; 表示为 &#x27;片上外设口&#x27;。 * 注意 P2_1 和 P2_2 一般用来作为程序烧入口，不作为 普通I/O 口。 &#x27;其他口随便用&#x27;！ 2) 其次，让 P1_0 处于输出状态。 * 输入/出 状态的控制，也是由一组寄存器进行控制的。 * &#x27;P0DIR&#x27; | P1DIR | P2DIR 这桑寄存器分别管理 &#x27;P0&#x27; | P1 | P2 三组 I/O 口 输入或输出。 * 寄存器每一位 &#x27;0&#x27; 表示对应的引脚进行 &#x27;输出&#x27;。&#x27;1 表示&#x27;对应引脚进行 &#x27;输入&#x27;。 3) 最后，根据要求，让其处于 输出 高/低 点平。 * 设置 Px_x = 0 输出高电平， Px_X = 1 输出低电平。 4. # 以上两种寄存器 PxSEL and PxDIR 默认情况下的值都是 0x00;5. 输入如何配置: 读取 P0_6 状态，高电平表示&#x27;跳线帽&#x27;断开，低电平表示&#x27;跳线帽连接&#x27;GND。&#x27;见原理图 指针和等效光敏 模块&#x27;。 1) 让 p0_6 处于普通 I/O 口状态。 P0SEL = 0 2) 让 P0_6 处于输入状态。 P0DIR = 0 3) &#x27;让 P0_6 处于上拉、下拉或者三态 中的一种状态&#x27;。 * 上拉电路，很容易理解，就是引脚与外设之间，接一个电阻与VCC电源，来提高电压。 * 下拉电路，很容易理解，就是引脚与外设之间，接一个电阻与GND接地，来减低电压。 * 那什么是&#x27;三态呢？&#x27;，就是引脚与外设之间，接一个&#x27;无穷大的电阻&#x27;。 为什么要这样做，这样做有什么作用呢？ 当我们的引脚是需要&#x27;读取&#x27;外部设备的&#x27;电压值&#x27;的时候，接&#x27;上拉或者下拉&#x27;会&#x27;影响输入结果&#x27;。此时接一个无穷大的电阻，可以保证它想断路一样，不会分压，又可以通过连通读取到接入点的电压值。 例如: 使用&#x27;热敏电阻传感器&#x27;，或者&#x27;光敏电阻传感器&#x27;的时候，传感器电压值，会随着温度变化，分压也随之变化，我们单片机就需要采集到传感器与地之间的电压值，然后计算出外界环境的变化。&#x27;ADC采集的时候一定要接三态&#x27;。 4) 那么如何设置输入引脚是处于哪一种状态呢？ 用到了另外一组寄存器 &#x27;PxINP&#x27; * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;0&#x27; 表示 P0_6 处于 &#x27;上拉|下拉&#x27; 状态。 * &#x27;P0INP&#x27; 中的第六位 如果是 &#x27;1&#x27; 表示 P0_6 处于 &#x27;三态&#x27; 状态。 * 进一步确定，到底是处于上拉，还是下拉状态呢？ 这里用到了 &#x27;P2INP的高三位&#x27;！ * 因为 P2组 实际只存在五个引脚，&#x27;高三位不存在&#x27;，所以！&#x27;P2INP 高三位是闲置的&#x27;！！ * P2INP_5 --&gt; P0组的 上拉/下拉 P2INP_6 --&gt; P1组的 上拉/下拉 P2INP_7 --&gt; P2组的 上拉/下拉 5) 因为 PxSEL, PxDIR, PxINP 三个寄存器都是默认值为0. 所以，我们说这些引脚都是默认&#x27;普通IO口 上拉 输入&#x27;。 相关经验 目前所学的控制寄存器： PxSEL：控制三组引脚的作用，外设或者普通 I/O 口。 PxDIR：控制三组引脚的 I/O 状态，输入或输出。 PxINP：控制三组引脚的输入状态 上拉|下拉 或 三态。 P2INP 的高三位：控制三组引脚的 上拉或下拉 跳线帽 就是开发板上，连接了两个相邻排针的导体，类似给排针戴了顶帽子，所以叫做跳线帽。 zigbee 模块上，cc2580的 P0_6排针 与 GND排针 之间就有一个跳线帽。 zigbee 模块上，LED8 与 GND 之间也有一个跳线帽。 zigbee 常用引脚的位宏定义。 比如其中一个 P0_2 表示的就是 P0 组引脚中的 第三个引脚。 而单片机中，如果需要对寄存器位进行赋值操作，需要先声明一个位变量sbit P0_2 = P0^2 代码123456789101112131415161718192021222324252627#include &lt;iocc2530.h&gt;void delay(int x);void main()&#123; // 设置 P0_6 输入，确定 跳线帽的状态 P0SEL &amp;= 0xbe; // 设置 P0_6 , P0_0 为 i/o 口 1011 1110 P0DIR &amp;= 0xbf; // 设置 P0_6 输入 1011 1111 P0DIR |= 0x01; // 设置 P0_0 输出 0000 0001 P0INP &amp;= 0xbf; // 设置 P0_6 组引脚为 上/下拉 1011 1111 P2INP &amp;= 0xdf; // 110 11111 设置 P0 组引脚为上拉 while(1)&#123; //跳线帽插上，灯亮。跳线帽拔掉，灯灭。 if( P0_6 == 0) &#123; P0_0 = 1; &#125;else&#123; P0_0 = 0; &#125; &#125;&#125;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee环境搭建","date":"2020-09-10T12:46:25.000Z","path":"2020/09/10/2020.09.10 搭建开发环境编写及仿真/","text":"软件安装，程序编写运行，烧录IAR安装 12345678910111213141. IAR程序下载: 1) 不要从脚本之家之类的网站下载软件。否则，你的浏览器会被恶意串改主页。并且，电脑上会被恶意下载软件。 2) 从官网下载最新版的 IAR for 8051 就行了。 2. IAR程序破解: 教程：&quot; https://blog.csdn.net/qq_38351824/article/details/85005672 &quot; 1) 从可靠途径获得破解软件。 2) 运行破解软件，选择所需要破解的版本。生成密钥 3) 将密钥复制到 IAR程序密钥验证 步骤中，注意断网。 4) IAR 会在生成一个文本，给它放在桌面。 5) 将该文本路径填写到 破解软件 第二栏中，生成另外一个破解 文本。 6) 将破解文本填写到 IAR程序 注册所需文件中，然后一直下一步就行了。 # 注意，最后提取库文件的时候会失败，因为 IAR库文件 是需要另外一套 password 的。 # 但是也不需要担心，我们一般用不到库文件，或者即使要用，也是后期手动下载导入。 使用 新建工程： project -&gt; new project 选择新建一个 8051 的空白文件。 同时新建一个文件夹 lesson1 用来存储所有的工程文件。 工程名取名为 lessonp == lesson project 新建一个空白文件，取名为 lesson.c 用来存储程序文件。 右击工程，add -&gt; add lesson.c 导入源文件到工程。。 写个主函数，然后运行，弹出一个 工作区保存路径，填写 lessonw == lesson workspace 程序编写 1234567891011121314151617181920212223242526272829303132333435361. 头文件 #include &lt;iocc2530.h&gt;2. 配置工程文件: 1) 右击工程 -&gt; 修改常用选项中的 Device 驱动，找到在安装目录下 texas Instruments 中找到相应的 cpu cc2530F256。 2) 选择 linker -&gt; Output 勾选 Override default 和 Allow C-SPY-specific extra output file # 程序可以进行在线烧录，仿真。 3) 选择 Debugger 调试， 驱动器修改虚拟软件仿真 为 &#x27;Texas Instruments&#x27; 真正的硬件仿真器。 3. 安装仿真器(Texas Instruments)驱动。驱动所在路径：&quot; C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.1\\8051\\drivers\\Texas Instruments &quot;4. 仿真器上有两个红灯，其中一个是供电灯，另外一个是是否识别到 zigbee 芯片模块灯: 1) 当能够识别到硬件的时候，其中一个灯不亮。表示正常，可以进行下载程序。 2) 否则，如果两个灯都亮，就需要进行按键复位一下，重新识别硬件。5. IAR 中，先编译 --&gt; 再下载烧录程序。6. 调试: 1) 烧录程序后，直接进入程序执行状态。 2) 点击暂停按钮，可以进入 debug 状态。 3) 曲线图标：逐行运行 4) 向内∟图标: 逐行调试，遇到函数进入。 向外∟图标: 跳出当前所在函数。 5) 小三角加条竖线: 跳转到下一个标记节点。 7. 生成 hex 文件: 1) option -&gt; linker -&gt; extra Output 2) 勾选生成 Overide default文件名取名为 &#x27;lesson1.hex&#x27;。 3) 选择 OutPut fomat 格式为 &#x27;intel-extended&#x27;8. hex 文件作用: 1) 一种 16 进制程序文件，相当于源代码，但是可以不用再结果 IAR 编译器编译。 2) 可以直接使用烧录软件，烧录到 zigbee开发板 中。 3) flash Programmer 下载地址:&quot; https://www.ti.com/licreg/docs/swlicresults.tsp?countryName=China+%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&amp;eeq=Civil&amp;Certify=YES&amp;submitsubmit=Submit &quot; 4) 自动获取仿真驱动软件，选择好 hex 文件，点击开始烧录就行了！！ 相关经验 带排线的那个 zigbee 模块 ———— 是仿真用到。 最小的那个模块 ———— 抓取无线数据包的硬件工具 dongle 代码12345678910111213141516171819202122#include &lt;iocc2530.h&gt;void delay(int x)&#123; int i, j; for(i = 0; i &lt; 300; i++) for(j = 0; j &lt; x; j++);&#125;// P0组 低四位输出 各自连接一个led灯, 形成流水灯。P0SEL &amp;= 0xf0; // 最后四个引脚设置为 I/OP0DIR |= 0x0f; // 最后四个引脚进行输出int v = 0x01;while(1)&#123; P0 = v; delay(1000); P0 = 0x00; delay(1000); v = v &lt;&lt; 1; if(v == 0x10) v = 0x01;&#125;","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"zigbee概述","date":"2020-09-09T09:00:00.000Z","path":"2020/09/09/2020.09.09 zigbee 概述/","text":"zigbee组成12345678910111213141516171819202122232425262728293031321. zigbee 不像 51单片机 只需要理解里面的寄存器就可以玩转: 1) zigbee 最主要的是协议栈。它包含了很多的协议站，以及相关代码。这是最难的。 2) 资料方面，互联网上关于 zigbee 相关的深入浅出的资料很少。特别是关于讲解&#x27;协议栈&#x27;这一方面。2. 术语: 1) zigbee, zigbee通信方式，zigbee协议 三者都是一个意思。 2) 节点，无线模块，无线设备，三者都是一个意思。3. 计算机之间，局域网采用以太网协议: 1) zigbee之间通信，同样的，采用zigbee协议 2) 作用：&#x27;构建无线局域网！！&#x27;4. 如果一个无线局域网用于传感器的数据收集和监控，那么这个网络就叫做&#x27;无线传感器网络&#x27; 1) 也就是说，无线传感器网络是无线局域网的一个具体应用。5. 已经有了 蓝牙 和 wifi 为什么还要用 zigbee: 1) 蓝牙：功耗低，但是组件网络的节点数少 7~8个。 2) wifi：通信功率 比较大， 功耗大。 3) zigbee：可以组将大概模网络，节点可以上万个！功耗低(cc 2530 正常工作电流8mA, 最低工作达到几个uA)。 缺点：通信速率比较小，250 kbs。比较适合传感器的信息传送。6. 应用方面: 1) 家具方面：可以用电池，或者太阳能供电。 2) 工业方面：传统使用总线组将局域网，如果有zigbee的话，就可以无线组网。 3) 农业方面：组将无线传感器网络，温湿度传感器，二氧化碳浓度等传感器的数据组网收集。 4) 医疗方面：...... 5) 物联网时代，zigbee 使用十分频繁。7. zigbee 模块一般配合上位机构建控制系统: 1) 上位机可以是 pc，也可以是通过互联网的远程服务器。 2) 上位机可以实现对 zigbee 系统中的元件控制。 3) 主 zigbee 与 计算机之间 是&#x27;采用串口进行通信&#x27;的。也就是和 arduino 串口通信一样，需要使用一根数据线连接电脑。计算机获取数据。 zigbee组网组成12345678910111213141516171819202122232425262728291. 局域网内主要有三种成员: 1) 自顶向下：调节器，路由器，终端。三者都是使用zigbee模块来组成的。 2) 上位机主要是与主zigbee进行数据交互通信。 3) 远程服务器，是为了外出也能控制家里的物联网设备。2. 以太网协议通信条件: 1) 硬件：网卡 2) 软件：以太网协议栈（一堆程序代码？？？）3. zigbee 协议通信条件: 1) 软件上：zigbee协议栈（一堆程序代码） 2) 硬件上：&#x27;一种支持zigbee底层协议的芯片&#x27;。4. 几种关键字的含义: 1) zigbee联盟：ambare/飞思卡尔... 制定zigbee协议的一个协会组织，再美国的TI公司。 zigbee厂商，主要把zigbee协议用于推广和实际应用。 2) zstack TI：zigbee软件上&#x27;支持的协议栈&#x27;，由 TI 公司开发，并不是 zigbee 本身的底层协议. 3) cc2530：就是 TI 公司推出的&#x27;其中一&#x27;种&#x27;支持 zigbee 底层协议&#x27;的 &#x27;硬件芯片&#x27;。 4) IAR：编程软件，编译程序，下载烧录程序到 zigbee 开发板。5. cc2530芯片：cc2530F256 TI 50j.. # zigbee芯片上那块小的板子，中间的黑色正方形就是cc2530 1) F 标识flash，存储程序的rom 256kb 最大的一款。 2) 所有的种类芯片，ram 只有8K。 3) 50j：表示的是产品信息。6. 学习方法: 1) 记录学习笔记，做实验，抓包 2) 1~6 节可以按照顺序看，第七部分上半部分协议栈的使用学习完，可以直接先看第八部分 zigbee无线网络通信。熟悉这两部分之后，在学习 OSAL 以及对比学习其他通信方式。 3) 所有内容可以先粗看一遍，所有例子烧录进去观察现象，再来细看学习。 相关经验 手机是不能直接和 zigbee 进行数据通信的。 计算机的作用就是，将 zigbee 网络 与 互联网广域网 进行连接的中间。 国内用的一般都是 TI 公司的协议栈，以及硬件芯片cc2530。免费，稳定，可靠。","link":"","tags":[{"name":"zigbee","slug":"zigbee","permalink":"http://www.fangning.xyz.com/tags/zigbee/"}]},{"title":"Hello world","date":"2020-09-03T09:42:39.545Z","path":"2020/09/03/hexo 默认文章/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"http://www.fangning.xyz.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]